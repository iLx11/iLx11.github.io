<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:700px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:700px)" href="/css/stylePC.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>
<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <!-- <div class="bgimg"></div> -->
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            前端笔记
        </div>
        <div class="post-meta">
            2022-08-16
        </div>
    
<hr>
    <div class="post-md">
        <h2 id="前端笔记："><a href="#前端笔记：" class="headerlink" title="前端笔记："></a>前端笔记：</h2><h5 id="检测设备的宽度（html部分"><a href="#检测设备的宽度（html部分" class="headerlink" title="检测设备的宽度（html部分)"></a>检测设备的宽度（html部分)</h5><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;width = device-width,initial-scale = 1.0&quot;&gt;
</code></pre>
<h5 id="及添加css文件，font文件"><a href="#及添加css文件，font文件" class="headerlink" title="及添加css文件，font文件"></a>及添加css文件，font文件</h5><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;font/iconfont.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/common.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;font/iconfont.css&quot;&gt;
</code></pre>
<h5 id="conmon-css"><a href="#conmon-css" class="headerlink" title="conmon.css"></a>conmon.css</h5><pre><code class="css">* &#123;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
&#125;
@font-face &#123;
    font-family: &quot;youshe&quot;;
    src: url(&quot;../font/YSHaoShenTi.ttf&quot;);
&#125;
.icon &#123;
    width: 1.8em;
    height: 1.8em;
    vertical-align: -0.15em;
    fill: currentColor;
    overflow: hidden;
&#125;

a,
input:focus,
select:focus,
textarea:focus,
button:focus &#123;
    outline: none;
&#125;

li &#123;
    list-style-type: none;
&#125;
</code></pre>
<h5 id="background属性"><a href="#background属性" class="headerlink" title="background属性"></a>background属性</h5><pre><code class="css">  background: url(&quot;../img/4.png&quot;)no-repeat 0em -1.2em/55px 55px;
</code></pre>
<h5 id="input标签可改变本来的样式"><a href="#input标签可改变本来的样式" class="headerlink" title="input标签可改变本来的样式"></a>input标签可改变本来的样式</h5><pre><code class="html">&lt;input type=&quot;text&quot; name=&quot;&quot;  placeholder=&quot;&quot; v-model=&quot;doneList.content1&quot; @keyup.enter=&quot;add&quot; autofocus&gt;
</code></pre>
<h5 id="用css根据type属性获取"><a href="#用css根据type属性获取" class="headerlink" title="用css根据type属性获取"></a>用css根据type属性获取</h5><pre><code class="css">div input[type=&#39;text&#39;] &#123;
    width:100%;
&#125;
</code></pre>
<pre><code class="html">&lt;input type=&quot;checkbox&quot; name=&quot;&quot; v-model=&quot;&quot;&gt;
</code></pre>
<h5 id="更改type为checkbox的样式"><a href="#更改type为checkbox的样式" class="headerlink" title="更改type为checkbox的样式"></a>更改type为checkbox的样式</h5><pre><code class="css">input&#123;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 1px solid #000;
  -webkit-appearance: none;
    -moz-appearance: none;
&#125;
</code></pre>
<h3 id="filter属性"><a href="#filter属性" class="headerlink" title="filter属性"></a>filter属性</h3><p>CSS 中实现滤镜效果需要通过 filter 属性并配合一些函数来实现，如下所示：</p>
<table>
<thead>
<tr>
<th>滤镜</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>默认值，表示没有效果</td>
</tr>
<tr>
<td>blur(px)</td>
<td>为图像设置高斯模糊，默认值为 0，单位为像素，值较大越模糊</td>
</tr>
<tr>
<td>brightness(%)</td>
<td>调整图像的亮度，默认值为 100％，代表原始图像；0％ 表示没有亮度，图像将完全变黑；当值超过 100％ 时图像将变得更亮</td>
</tr>
<tr>
<td>contrast(%)</td>
<td>调整图像的对比度，默认值为 100％，代表原始图像；0％ 将使图像完全变黑；当值超过 100％ 时图像将获得更高的对比度</td>
</tr>
<tr>
<td>drop-shadow(h-shadow v-shadow blur spread color)</td>
<td>为图像添加阴影效果，参数说明如下：<br />h-shadow：必填值，指定水平方向阴影的像素值，若值为负，则阴影会出现在图像的左侧；<br />v-shadow：必填值，指定垂直方向阴影的像素值，若值为负，则阴影会出现在图像的上方；<br />blur：可选值，为阴影添加模糊效果，默认值为 0，单位为像素，值越大创建的模糊就越多（阴影会变得更大更亮），不允许使用负值；<br />spread：可选值，默认值为 0，单位为像素。若值为正，则阴影将会扩展并增大；若值为负，则阴影会缩小；<br />color：可选值，为阴影添加颜色，如未指定，则由浏览器来绝对，通常为黑色。<br />注意：Chrome、Safari 和 Opera 等浏览器不支持第 4 个参数，如果添加，则不会有任何效果</td>
</tr>
<tr>
<td>grayscale(%)</td>
<td>将图像转换为灰度图像，默认值为 0%，表示原始图像；100％ 表示将图像完全变成灰度图像（即黑白图像），不允许为负值</td>
</tr>
<tr>
<td>hue-rotate(deg)</td>
<td>给图像应用色相旋转，该值用来定义色环的度数，默认值为 0deg，代表原始图像，最大值为 360deg</td>
</tr>
<tr>
<td>invert(%)</td>
<td>反转图像，默认值为 0%，表示原始图像；100% 则表示完全反转，不允许使用负值</td>
</tr>
<tr>
<td>opacity(%)</td>
<td>设置图像的不透明度，默认值为 100%，表示原始图像；0% 表示完全透明，不允许使用负值</td>
</tr>
<tr>
<td>saturate(%)</td>
<td>设置图像的饱和度，默认值为 100%，表示原始图像；0% 表示图像完全不饱和，不允许使用负值</td>
</tr>
<tr>
<td>sepia(%)</td>
<td>将图像转换为棕褐色，默认值为 0%，表示原始图像；100% 表示图像完全变成棕褐色，不允许使用负值</td>
</tr>
<tr>
<td>url()</td>
<td>url() 函数用来指定一个 XML 文件，文件中设置了一个 SVG 滤镜，并且可以包含一个锚点来指定具体的滤镜元素</td>
</tr>
<tr>
<td>initial</td>
<td>将属性设置为其默认值</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承此属性的值</td>
</tr>
</tbody></table>
<h4 id="荧光效果"><a href="#荧光效果" class="headerlink" title="荧光效果"></a>荧光效果</h4><pre><code class="css">filter: drop-shadow(x, y, spread, color);
</code></pre>
<h3 id="keyframs"><a href="#keyframs" class="headerlink" title="@keyframs"></a>@keyframs</h3><pre><code class="css">@keyframes mymove
&#123;
0%   &#123;top:0px;&#125;
25%  &#123;top:200px;&#125;
50%  &#123;top:100px;&#125;
75%  &#123;top:200px;&#125;
100% &#123;top:0px;&#125;
&#125;

@-moz-keyframes mymove /* Firefox */

@-webkit-keyframes mymove /* Safari 和 Chrome */

@-o-keyframes mymove /* Opera */
</code></pre>
<h4 id="animation属性"><a href="#animation属性" class="headerlink" title="animation属性"></a>animation属性</h4><pre><code class="css">div
&#123;
    animation:mymove 5s infinite;
    -webkit-animation:mymove 5s infinite; /* Safari 和 Chrome */
&#125;
</code></pre>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_animation-name.asp">animation-name</a></em></td>
<td align="left">规定需要绑定到选择器的 keyframe 名称。。</td>
</tr>
<tr>
<td align="left"><em><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_animation-duration.asp">animation-duration</a></em></td>
<td align="left">规定完成动画所花费的时间，以秒或毫秒计。</td>
</tr>
<tr>
<td align="left"><em><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp">animation-timing-function</a></em></td>
<td align="left">规定动画的速度曲线。</td>
</tr>
<tr>
<td align="left"><em><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_animation-delay.asp">animation-delay</a></em></td>
<td align="left">规定在动画开始之前的延迟。</td>
</tr>
<tr>
<td align="left"><em><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp">animation-iteration-count</a></em></td>
<td align="left">规定动画应该播放的次数。</td>
</tr>
<tr>
<td align="left"><em><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_animation-direction.asp">animation-direction</a></em></td>
<td align="left">规定是否应该轮流反向播放动画。</td>
</tr>
</tbody></table>
<h3 id="animetion与transition结束事件"><a href="#animetion与transition结束事件" class="headerlink" title="animetion与transition结束事件"></a>animetion与transition结束事件</h3><pre><code class="js">/*transtion*/
dom.addEventListener(&#39;transitionend&#39;, () =&gt;&#123;
    console.log(&quot;346476&quot;)
&#125;);

/*animetion*/
dom.addEventListener(&#39;animetionend&#39;, () =&gt;&#123;
    console.log(&quot;346476&quot;)
&#125;);
</code></pre>
<h4 id="css计算属性"><a href="#css计算属性" class="headerlink" title="css计算属性"></a>css计算属性</h4><pre><code class="css">.box &#123;
    --x: 2;
    --y: 2;
&#125;

transform: translate(calc (6px * var(--x)), calc (6px * var(--x)))
</code></pre>
<h4 id="点击添加属性"><a href="#点击添加属性" class="headerlink" title="点击添加属性"></a>点击添加属性</h4><pre><code class="js">addEventListener(&#39;click&#39;)
document.classList.toggle(&quot;类名&quot;)

/*
css
.document.active &#123;
    xxx: xxx;
&#125;
*/
</code></pre>
<h4 id="使用图标时-font"><a href="#使用图标时-font" class="headerlink" title="使用图标时(font)"></a>使用图标时(font)</h4><p>引入js标签</p>
<pre><code class="html">&lt;script src=&quot;./font/iconfont.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>css添加</p>
<pre><code class="css">.icon &#123;
    width: 1.8em;
    height: 1.8em;
    vertical-align: -0.15em;
    fill: currentColor;
    overflow: hidden;
&#125;
</code></pre>
<p>使用时</p>
<pre><code class="html"> &lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;
         &lt;!--图标名：#icon-xxx--&gt;
       &lt;use xlink:href=&quot;#icon-tianjiayonghu&quot;&gt;&lt;/use&gt;
 &lt;/svg&gt;
</code></pre>
<h5 id="选择li的第几个孩子时可用"><a href="#选择li的第几个孩子时可用" class="headerlink" title="选择li的第几个孩子时可用"></a>选择li的第几个孩子时可用</h5><pre><code class="css">ul li:nth-child(n)&#123;

&#125;
</code></pre>
<h5 id="span标签内地文字不好设置居中，可更改为div，然后设置"><a href="#span标签内地文字不好设置居中，可更改为div，然后设置" class="headerlink" title="span标签内地文字不好设置居中，可更改为div，然后设置"></a>span标签内地文字不好设置居中，可更改为div，然后设置</h5><pre><code class="css">text-alien : center;
</code></pre>
<h5 id="根据li的数量，更改li的长度"><a href="#根据li的数量，更改li的长度" class="headerlink" title="根据li的数量，更改li的长度"></a>根据li的数量，更改li的长度</h5><pre><code class="css">ul&#123;
    height: auto;
      display: flex;        /*流动布局*/
      justify-content:space-around;
      flex-wrap: wrap;    /*设置换行*/
&#125;
li&#123;
  list-style-type:none;  /*去除li前的小点*/
&#125;
ui li&#123;
    flex-grow: 2;   /*重点部分，使li在有空间的地方”生长“*/
&#125;
</code></pre>
<h5 id="切割元素"><a href="#切割元素" class="headerlink" title="切割元素"></a>切割元素</h5><pre><code class="css">clip-path: polygon(0% 0%, 50% 0%, 50% 50%, 100% 50%, 100% 100%, 0% 100%);
/*每个逗号分割一个坐标*/
</code></pre>
<h4 id="单个字体居中对齐"><a href="#单个字体居中对齐" class="headerlink" title="单个字体居中对齐"></a>单个字体居中对齐</h4><pre><code class="css"> display: flex;
 justify-content: center;
 align-items: center;
</code></pre>
<h4 id="引入外部字体"><a href="#引入外部字体" class="headerlink" title="引入外部字体"></a>引入外部字体</h4><pre><code class="css">@font-face &#123;
    font-family: &quot;xsu&quot;;
    src:  url(&quot;../font/quan.ttf&quot;);
&#125;
</code></pre>
<h4 id="图片实现渐变"><a href="#图片实现渐变" class="headerlink" title="图片实现渐变"></a>图片实现渐变</h4><pre><code class="css">.bgimg &#123;
    width: 100%;
    height: 260px;
    position: absolute;
    top: 0px;
    background: var(--bg) no-repeat 0em -19em/100% 42em;
    left: 0;
    z-index: -1;
&#125;
/*覆盖一层渐变遮罩*/
.bgimg:after &#123;
    content: &quot;&quot;;
    width: 100%;
    height: 260px;
    position: absolute;
    top: 0;
    left: 0;
    background: linear-gradient(180deg, rgba(248, 252, 255, 0) 35%, rgba(255, 255, 255, 1) 85%);
    z-index: 1;
&#125;
</code></pre>
<h4 id="亮暗主题切换"><a href="#亮暗主题切换" class="headerlink" title="亮暗主题切换"></a>亮暗主题切换</h4><p>css部分</p>
<pre><code class="css">/*设置css变量*/ 
--bg-color-1: #eee;

[color-theme=&quot;dark&quot;] &#123;
      --bg-color-1: #fff;
&#125; 
[color-theme=&quot;light&quot;] &#123;
      --bg-color-1: #000;
&#125;
</code></pre>
<p>js</p>
<pre><code class="js">document.documentElement.setAttribute(&quot;color-theme&quot;, &quot;dark&quot;);
//or
document.documentElement.setAttribute(&quot;color-theme&quot;, &quot;light&quot;);
</code></pre>
<h2 id="js部分："><a href="#js部分：" class="headerlink" title="js部分："></a>js部分：</h2><h4 id="存储函数："><a href="#存储函数：" class="headerlink" title="存储函数："></a>存储函数：</h4><pre><code class="js">(function (w) &#123;
        var isSupportLocalStorage = !!window.localStorage, isSupportBehavior = false;
        if (!isSupportLocalStorage) &#123;
            var dataObj = document.createElement(&#39;input&#39;);
            dataObj.type = &#39;hidden&#39;;
            document.body.appendChild(dataObj);
            isSupportBehavior = !!dataObj.addBehavior;
            isSupportBehavior &amp;&amp; dataObj.addBehavior(&#39;#default#userData&#39;);
        &#125;
        var configs = &#123; storeName: &#39;editorContent&#39; &#125;;
        w.storage = &#123;
            retrieve: function (name) &#123;
                if (!isSupportLocalStorage &amp;&amp; isSupportBehavior) &#123;
                    dataObj.load(configs.storeName);
                    return dataObj.getAttribute(name);
                &#125; else &#123;
                    return w.localStorage.getItem(name);
                &#125;
                return null;
            &#125;,
            save: function (name, value) &#123;
                if (!isSupportLocalStorage &amp;&amp; isSupportBehavior) &#123;
                    dataObj.setAttribute(name, value);
                    dataObj.save(configs.storeName);
                    return true;
                &#125; else &#123;
                    w.localStorage.setItem(name, value);
                    return true;
                &#125;
                return false;
            &#125;
        &#125;;
    &#125;)(window);
</code></pre>
<p>调用时</p>
<pre><code class="js">storage.save(&quot;变量名&quot;,变量);//储存函数

storage.retrieve(&quot;变量名&quot;)//读取函数
</code></pre>
<h5 id="储存一些特殊数据时，需要用JSON转换数据"><a href="#储存一些特殊数据时，需要用JSON转换数据" class="headerlink" title="储存一些特殊数据时，需要用JSON转换数据"></a>储存一些特殊数据时，需要用JSON转换数据</h5><pre><code class="js">JSON.stringify(this.doneList));        //将目标转化为json字符

JSON.parse(storage.retrieve(&quot;data.doneList&quot;))    //将json字符转化为数组
</code></pre>
<h4 id="检测页面传回的参数"><a href="#检测页面传回的参数" class="headerlink" title="检测页面传回的参数"></a>检测页面传回的参数</h4><pre><code class="js">var current_user = getUrlQueryString(&#39;user&#39;);
    $(&#39;.ch_n&#39;).html(current_user);

    //检测跳转页面传回来的参数
    function getUrlQueryString(names, urls) &#123;
        urls = urls || window.location.href;
        urls &amp;&amp; urls.indexOf(&quot;?&quot;) &gt; -1 ? urls = urls
            .substring(urls.indexOf(&quot;?&quot;) + 1) : &quot;&quot;;
        var reg = new RegExp(&quot;(^|&amp;)&quot; + names + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);
        var r = urls ? urls.match(reg) : window.location.search.substr(1)
            .match(reg);
        if (r != null &amp;&amp; r[2] != &quot;&quot;)
            return unescape(r[2]);
        return null;
    &#125;
</code></pre>
<h4 id="浏览器宽度监测"><a href="#浏览器宽度监测" class="headerlink" title="浏览器宽度监测"></a>浏览器宽度监测</h4><pre><code class="js"> window.onresize = function() &#123;&#125;
</code></pre>
<h3 id="简单文章目录"><a href="#简单文章目录" class="headerlink" title="简单文章目录"></a>简单文章目录</h3><pre><code class="js">let h2 = document.querySelectorAll(&#39;h2&#39;);
let h3 = document.querySelectorAll(&#39;h3&#39;);
let h4 = document.querySelectorAll(&#39;h4&#39;);
let bgn = document.querySelector(&quot;.post-md&quot;).children[0];
let nav = document.querySelector(&#39;.nav&gt;ul&#39;);
navSet(bgn, nav);

console.log(bgn)
while ((bgn = bgn.nextElementSibling) != null) &#123;
    navSet(bgn, nav);
&#125;
function navSet(bgn, nav) &#123;
    if (bgn.tagName == &quot;H2&quot;) &#123;
        let nli = document.createElement(&quot;li&quot;);
        nli.innerHTML = `&lt;span class=&quot;h2T&quot;&gt;$&#123;bgn.innerHTML&#125;&lt;/span&gt;`;
        nav.appendChild(nli);
    &#125; else if (bgn.tagName == &quot;H3&quot;) &#123;
        let nli = document.createElement(&quot;li&quot;);
        nli.innerHTML = `&lt;span class=&quot;h3T&quot;&gt;-&gt;$&#123;bgn.innerHTML&#125;&lt;/span&gt;`;
        nav.appendChild(nli);
        // break;
    &#125; else if (bgn.tagName == &quot;H4&quot;) &#123;
        let nli = document.createElement(&quot;li&quot;);
        nli.innerHTML = `&lt;span class=&quot;h4T&quot;&gt;--&gt;$&#123;bgn.innerHTML&#125;&lt;/span&gt;`;
        nav.appendChild(nli);
    &#125; else &#123;
       return;
    &#125;
&#125;
let h2T = document.querySelectorAll(&#39;.nav&gt;ul&gt;li&gt;.h2T&#39;);
let h3T = document.querySelectorAll(&#39;.h3T&#39;);
let h4T = document.querySelectorAll(&#39;.h4T&#39;);
let shu = [h2T, h3T, h4T];
let zu = [h2, h3, h4];
console.log(shu)
for (let j = 0; j &lt; shu.length; j++) &#123;
    for (let i = 0; i &lt; shu[j].length; i++) &#123;
        shu[j][i].onclick = function() &#123;
            console.log(zu[j][i])
            let position = zu[j][i].offsetTop;
            window.scrollTo(0, position);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h4><pre><code class="js"> // var json = &#123;left: 10, right: 10&#125; 变异
    //json.left json.top
    function scroll() &#123;
        if(window.pageYOffset != null) // ie9+ 和其他浏览器
        &#123;
            return &#123;
                left: window.pageXOffset,
                top: window.pageYOffset
            &#125;
        &#125;
        else if(document.compatMode == &quot;CSS1Compat&quot;) // 声明的了 DTD
          // 检测是不是怪异模式的浏览器 -- 就是没有 声明&lt;!DOCTYPE html&gt;
        &#123;
            return &#123;
                left: document.documentElement.scrollLeft,
                top: document.documentElement.scrollTop
            &#125;
        &#125;
        return &#123; // 剩下的肯定是怪异模式的
            left: document.body.scrollLeft,
            top: document.body.scrollTop
        &#125;
    &#125;
    window.onscroll = function() &#123;
        console.log(scroll().top);
    &#125;
</code></pre>
<h4 id="获取元素页面位置"><a href="#获取元素页面位置" class="headerlink" title="获取元素页面位置"></a>获取元素<code>页面</code>位置</h4><pre><code class="js">function getTop(aa) &#123;
    let offset = aa.offsetTop;
    if (aa.offsetParent != null) offset += getTop(aa.offsetParent);
    return offset;
&#125;
</code></pre>
<h4 id="显示当前目录"><a href="#显示当前目录" class="headerlink" title="显示当前目录"></a>显示当前目录</h4><pre><code class="js">function showCurrent() &#123;
    let hs = document.querySelectorAll(&#39;h2, h3, h4&#39;);
    for (let i = 0; i &lt; hs.length; i++) &#123;
        if (hs[i].offsetTop &lt; scroll().top) &#123;
            if (scroll().top - hs[i].offsetTop &lt; 60 &amp;&amp; shuzu[0] == shuzu[1]) &#123;
                shuzu[set] = 1;
                let menuli = document.querySelectorAll(&#39;.menu&gt;ul&gt;li&gt;span&#39;);
                for (let j = 0; j &lt; menuli.length; j++) &#123;
                    menuli[j].style.color = &quot;#000&quot;;
                &#125;
                menuli[i].style.color = &quot;rgba(158, 215, 236, 0.9)&quot;;
                document.querySelector(&#39;.menu&gt;ul&#39;).scrollTo(0, menuli[i].offsetTop - 100);
                set++;
            &#125; else &#123;
                shuzu[set] = 0;
                set++;
            &#125;
            if (set &gt; 1) set = 0;

        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="AES对称加密"><a href="#AES对称加密" class="headerlink" title="AES对称加密"></a>AES对称加密</h3><pre><code class="js">//加密
function AESEncode(pw) &#123;
    pw = CryptoJS.enc.Utf8.parse(pw);
    //密钥
    let key = CryptoJS.enc.Utf8.parse(&quot;mishi137&quot;);
    //偏移向量
    let iv = CryptoJS.enc.Utf8.parse(&quot;pianyi137&quot;);
    return CryptoJS.AES.encrypt(pw, key, &#123;
        mode: CryptoJS.mode.CBC, // 加密模式
        padding: CryptoJS.pad.Pkcs7, // 填充方式
        iv: iv // 偏移向量
    &#125;).toString();
&#125;
//解密
function AESDecode(pw) &#123;
    //密钥
    let key = CryptoJS.enc.Utf8.parse(&quot;mishi137&quot;);
    //偏移向量
    let iv = CryptoJS.enc.Utf8.parse(&quot;pianyi137&quot;);
    let code = CryptoJS.AES.decrypt(pw, key, &#123;
        mode: CryptoJS.mode.CBC, // 加密模式
        padding: CryptoJS.pad.Pkcs7, // 填充方式
        iv: iv // 偏移向量
    &#125;).toString(CryptoJS.enc.Utf8);
    console.log(code)
    return code;
&#125;
</code></pre>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><pre><code class="js">function()&#123;&#125; --&gt; () =&gt;&#123;&#125;

fangfa:function()&#123;&#125; --&gt; fangfa()&#123;&#125;

this 指向正在调用的函数

字符串拼接 --&gt; `字符串$&#123;变量&#125;`
</code></pre>
<h5 id="定时函数计时的应用"><a href="#定时函数计时的应用" class="headerlink" title="定时函数计时的应用"></a>定时函数计时的应用</h5><pre><code class="js">var xh = setInterval(()=&gt;&#123;
            time++;
            $(&#39;&#39;).html(TimeFormat(time));
            &#125;,1000);
    var time = 0; //变量提升
    function TimeFormat(number)&#123;
            var minute = parseInt(number / 60);
            var second = parseInt(number % 60);
            var hour = parseInt(number / 3600);
            minute = minute &gt;= 10 ? minute : &#39;0&#39; + minute;
            if(minute &gt; 59)&#123;
                minute = parseInt(minute % 60);
            &#125;
            second = second &gt;= 10 ? second : &#39;0&#39; + second;
            hour = hour &gt;= 10 ? hour : &#39;0&#39; + hour;
            if(hour &gt; 23)&#123;
                hour = parseInt(hour % 24);
            &#125;
            return hour + &quot;:&quot;+ minute + &quot;:&quot; + second;
        &#125;

//定时器（适用于，时间在UI上分开的）
var second = 58;
    var minute = 58;
    var hour = 23;
    var time = setInterval(() =&gt; &#123;
        second += 1;

        if (timeCycle(second) == 0) &#123;
            second = 0;
            minute += 1;
            if (timeCycle(minute) == 0) &#123;
                minute = 0;
                hour += 1;
                if (timeCycle(hour, 1) == 0) &#123;
                    hour = 0;
                &#125;
                $(&#39;.shi&#39;).html(timeCycle(hour, 1));
            &#125;
            $(&#39;.fen&#39;).html(timeCycle(minute));
        &#125;
        $(&#39;.miaoshu&#39;).html(timeCycle(second));
    &#125;, 1);

    function timeCycle(n, a = 0) &#123;
        if (n &lt; 10) &#123;
            return &#39;0&#39; + n;
        &#125; else if (n &gt; 9 &amp;&amp; n &lt; 60 &amp;&amp; a == 0) &#123;
            return n;
        &#125; else if (n &gt; 59 &amp;&amp; a == 0) &#123;
            return 0;
        &#125;else if (n &gt; 9 &amp;&amp; n &lt; 24 &amp;&amp; a == 1) &#123;
            return n;
        &#125;else if (n &gt; 23 &amp;&amp; a == 1) &#123;
            return 0;
        &#125;
    &#125;;
</code></pre>
<p>vue真的很方便</p>
<h5 id="转换utf-8"><a href="#转换utf-8" class="headerlink" title="转换utf-8"></a>转换utf-8</h5><pre><code class="js">function toUtf8(str) &#123;
    var out, i, len, c;
    out = &quot;&quot;;
    len = str.length;
    for(i = 0; i &lt; len; i++) &#123;
        c = str.charCodeAt(i);
        if ((c &gt;= 0x0001) &amp;&amp; (c &lt;= 0x007F))&#123;
            out += str.charAt(i);
        &#125; else if (c &gt; 0x07FF) &#123;
            out += String.fromCharCode(0xE0 | ((c &gt;&gt; 12) &amp; 0x0F));
            out += String.fromCharCode(0x80 | ((c &gt;&gt;  6) &amp; 0x3F));
            out += String.fromCharCode(0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
        &#125; else&#123;
            out += String.fromCharCode(0xC0 | ((c &gt;&gt;  6) &amp; 0x1F));
            out += String.fromCharCode(0x80 | ((c &gt;&gt;  0) &amp; 0x3F));
        &#125;
    &#125;
    return out;
&#125;
以下示例：

var str = toUtf8(&quot;啦啦啦德玛西亚！&quot;);
</code></pre>
<h5 id="js文本转二维码"><a href="#js文本转二维码" class="headerlink" title="js文本转二维码"></a>js文本转二维码</h5><iframe width="100%" height="300" src="https://c.runoob.com/iframe/1586" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<h5 id="js文本转语音"><a href="#js文本转语音" class="headerlink" title="js文本转语音"></a>js文本转语音</h5><pre><code class="js">函数其一:
function transText(text)&#123;
            var url = &quot;http://tts.youdao.com/fanyivoice?le=zh&amp;keyfrom=speaker-target&amp;word=&#39;&quot; +encodeURI(text);
            new Audio(url).play();
        &#125;


函数其二:
        // getVoice(text);
            // setTimeout(()=&gt;&#123;
            //     bgm.play();
            // &#125;,300);
        function getVoice(text)&#123;
            $.ajax(&#123;
                method: &#39;GET&#39;,
                url: &#39;http://www.liulongbin.top:3006/api/synthesize&#39;,
                data: &#123;
                    text: text
                &#125;,
                success:function(res)&#123;
                    console.log(res)
                    if(res.status === 200) &#123;
                        $(&#39;#voice&#39;).attr(&#39;src&#39;,res.voiceUrl);
                    &#125;else&#123;
                        alert(&#39;请求失败&#39;);
                    &#125;
                &#125;
            &#125;)
        &#125;
</code></pre>
<h5 id="获取设备宽度及高度"><a href="#获取设备宽度及高度" class="headerlink" title="获取设备宽度及高度"></a>获取设备宽度及高度</h5><pre><code class="js">let clientW = document.documentElement.clientWidth;
let clientH = document.documentElement.clientHeight;
</code></pre>
<h2 id="gsap动画插件"><a href="#gsap动画插件" class="headerlink" title="gsap动画插件"></a>gsap动画插件</h2><p>CDN导入</p>
<pre><code class="html">&lt;script src=&quot;./js/gsap.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;./js/ScrollTrigger.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="scrollTrigger插件"><a href="#scrollTrigger插件" class="headerlink" title="scrollTrigger插件"></a>scrollTrigger插件</h3><pre><code class="js">//创建时间线，时间线后的动画会依次播放
let t6 = gsap.timeline(&#123;
    //scrollTrigger 配置
    scrollTrigger: &#123;
        //触发元素
        trigger: &quot;.pageList&quot;,
        //开始执行动画，滚动条的位置
        start: &quot;4200px&quot;,
        //动画的结束位置，与 scrub 有关，倒回滚动时会逆向播放。
        end: &quot;4320px&quot;,
        // 触发时的动作
        toggleActions: &quot;restart&quot;,
        //是否跟随鼠标滚动条的滚动，以及执行时间
        scrub: 1,
    &#125;
&#125;);
//时间线的下一个动画，传递元素以及动画效果
//to 表示目标样式 / from 表示从何种样式变换
t6.to(&quot;.hw-1 img:nth-child(1)&quot;, &#123;
    // xPercent: 50,
    opacity: 0,
    duration: 3,
    // x: -850
    scale: 0.6,
&#125;);
// 表示同时执行
gsap.from(&quot;.hw-1 img:nth-child(2)&quot;, &#123;
    scrollTrigger: &#123;
        trigger: &quot;.pageList&quot;,
        start: &quot;4200px&quot;,
        end: &quot;4320px&quot;,
        toggleActions: &quot;restart&quot;,
        scrub: 1,
    &#125;,
    opacity: 0,
    duration: 0.3,
    scale: 0.7,
&#125;);
</code></pre>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><pre><code class="js">var xhr = new XMLHttpRequest();

xhr.open(&#39;GET&#39;,&#39;url&#39;);

xhr.send();

xhr.onreadystatechange = function()&#123;
    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;
        console.log(xhr.responseText)
    &#125;
&#125;
</code></pre>
<h5 id="get加参数"><a href="#get加参数" class="headerlink" title="get加参数"></a>get加参数</h5><pre><code class="js">xhr.open(&#39;GET&#39;,&#39;url?id=1&amp;name=l&#39;);
</code></pre>
<h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><pre><code class="js">var xhr = XMLHttpRequest();

xhr.open(&#39;POST&#39;,&#39;url&#39;);

xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);

xhr.send(&#39;id=1&amp;name=l&#39;);

xhr.onreadystatechange = function()&#123;
    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;
        console.log(xhr.responseText)
    &#125;

&#125;
</code></pre>
<h3 id="jQuery-Ajax"><a href="#jQuery-Ajax" class="headerlink" title="jQuery Ajax"></a>jQuery Ajax</h3><pre><code class="js">$.get(url,&#123;data&#125;,function(res)&#123;
    console.log(res)
&#125;)
</code></pre>
<pre><code class="js">$.post(url,&#123;data&#125;,function(res)&#123;
    console.log(res)
&#125;)
</code></pre>
<pre><code class="js">$.ajax(&#123;
    type: &#39;GET/POST&#39;,
    url:&#39;&#39;,
    dataType:&quot;jsonp&quot;,    //包含可解决跨域问题
    data:&#123;
        text:text,
    &#125;,
    success: function(res)&#123;
        console.log(res)
    &#125;,
    error: function(res)&#123;
         console.log(res)
    &#125;
&#125;)
</code></pre>
<h3 id="百度翻译API"><a href="#百度翻译API" class="headerlink" title="百度翻译API"></a>百度翻译API</h3><pre><code class="js">        var n = &#39;hello&#39;;
        var sui = Math.ceil(Math.random()*100000000000);  //产生随机数
        var si = &#39;20220412001169490&#39;+ n + sui + &#39;6MVmVLtp9Hh7Hb2bKY2x&#39;; //百度接口id及密匙

        var xx = md5(si);  //MD5编码后生成sign

        $.ajax(&#123;
            method: &#39;GET&#39;,
            url: &#39;http://api.fanyi.baidu.com/api/trans/vip/translate&#39;,
            data:&#123;
                q:n,
                from:&#39;auto&#39;,
                to:&#39;auto&#39;,
                appid:&#39;20220412001169490&#39;,
                salt:sui,
                sign:xx,
            &#125;,
            success:function(res)&#123;
                console.log(res.trans_result[0].src)
                console.log(res.trans_result[0].dst)
            &#125;,
        &#125;)
</code></pre>
<h3 id="MD5编码"><a href="#MD5编码" class="headerlink" title="MD5编码"></a>MD5编码</h3><pre><code class="js">32 位小写
md5(&quot;test md5 加密&quot;)
//098f6bcd4621d373cade4e832627b4f6

32 位大写
md5(&quot;test md5 加密&quot;).toUpperCase()
//098F6BCD4621D373CADE4E832627B4F6

16 位小写
md5(&quot;test md5 加密&quot;).substring(8,24)
//4621d373cade4e83

16 位大写
md5(&quot;test md5 加密&quot;).substring(8,24).toUpperCase()
//4621D373CADE4E83


代码
function md5(string) &#123;
    function md5_RotateLeft(lValue, iShiftBits) &#123;
        return (lValue &lt;&lt; iShiftBits) | (lValue &gt;&gt;&gt; (32 - iShiftBits));
    &#125;

    function md5_AddUnsigned(lX, lY) &#123;
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = (lX &amp; 0x80000000);
        lY8 = (lY &amp; 0x80000000);
        lX4 = (lX &amp; 0x40000000);
        lY4 = (lY &amp; 0x40000000);
        lResult = (lX &amp; 0x3FFFFFFF) + (lY &amp; 0x3FFFFFFF);
        if (lX4 &amp; lY4) &#123;
            return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
        &#125;
        if (lX4 | lY4) &#123;
            if (lResult &amp; 0x40000000) &#123;
                return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
            &#125; else &#123;
                return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
            &#125;
        &#125; else &#123;
            return (lResult ^ lX8 ^ lY8);
        &#125;
    &#125;

    function md5_F(x, y, z) &#123;
        return (x &amp; y) | ((~x) &amp; z);
    &#125;

    function md5_G(x, y, z) &#123;
        return (x &amp; z) | (y &amp; (~z));
    &#125;

    function md5_H(x, y, z) &#123;
        return (x ^ y ^ z);
    &#125;

    function md5_I(x, y, z) &#123;
        return (y ^ (x | (~z)));
    &#125;

    function md5_FF(a, b, c, d, x, s, ac) &#123;
        a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_F(b, c, d), x), ac));
        return md5_AddUnsigned(md5_RotateLeft(a, s), b);
    &#125;;

    function md5_GG(a, b, c, d, x, s, ac) &#123;
        a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_G(b, c, d), x), ac));
        return md5_AddUnsigned(md5_RotateLeft(a, s), b);
    &#125;;

    function md5_HH(a, b, c, d, x, s, ac) &#123;
        a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_H(b, c, d), x), ac));
        return md5_AddUnsigned(md5_RotateLeft(a, s), b);
    &#125;;

    function md5_II(a, b, c, d, x, s, ac) &#123;
        a = md5_AddUnsigned(a, md5_AddUnsigned(md5_AddUnsigned(md5_I(b, c, d), x), ac));
        return md5_AddUnsigned(md5_RotateLeft(a, s), b);
    &#125;;

    function md5_ConvertToWordArray(string) &#123;
        var lWordCount;
        var lMessageLength = string.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount &lt; lMessageLength) &#123;
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) &lt;&lt; lBytePosition));
            lByteCount++;
        &#125;
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 &lt;&lt; lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength &lt;&lt; 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength &gt;&gt;&gt; 29;
        return lWordArray;
    &#125;;

    function md5_WordToHex(lValue) &#123;
        var WordToHexValue = &quot;&quot;, WordToHexValue_temp = &quot;&quot;, lByte, lCount;
        for (lCount = 0; lCount &lt;= 3; lCount++) &#123;
            lByte = (lValue &gt;&gt;&gt; (lCount * 8)) &amp; 255;
            WordToHexValue_temp = &quot;0&quot; + lByte.toString(16);
            WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        &#125;
        return WordToHexValue;
    &#125;;

    function md5_Utf8Encode(string) &#123;
        string = string.replace(/\r\n/g, &quot;\n&quot;);
        var utftext = &quot;&quot;;
        for (var n = 0; n &lt; string.length; n++) &#123;
            var c = string.charCodeAt(n);
            if (c &lt; 128) &#123;
                utftext += String.fromCharCode(c);
            &#125; else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) &#123;
                utftext += String.fromCharCode((c &gt;&gt; 6) | 192);
                utftext += String.fromCharCode((c &amp; 63) | 128);
            &#125; else &#123;
                utftext += String.fromCharCode((c &gt;&gt; 12) | 224);
                utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128);
                utftext += String.fromCharCode((c &amp; 63) | 128);
            &#125;
        &#125;
        return utftext;
    &#125;;
    var x = Array();
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
    var S21 = 5, S22 = 9, S23 = 14, S24 = 20;
    var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
    var S41 = 6, S42 = 10, S43 = 15, S44 = 21;
    string = md5_Utf8Encode(string);
    x = md5_ConvertToWordArray(string);
    a = 0x67452301;
    b = 0xEFCDAB89;
    c = 0x98BADCFE;
    d = 0x10325476;
    for (k = 0; k &lt; x.length; k += 16) &#123;
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = md5_FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
        d = md5_FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
        c = md5_FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
        b = md5_FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
        a = md5_FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
        d = md5_FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
        c = md5_FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
        b = md5_FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
        a = md5_FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
        d = md5_FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
        c = md5_FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = md5_FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = md5_FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = md5_FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = md5_FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = md5_FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = md5_GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
        d = md5_GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
        c = md5_GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = md5_GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
        a = md5_GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
        d = md5_GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = md5_GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = md5_GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
        a = md5_GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
        d = md5_GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = md5_GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
        b = md5_GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
        a = md5_GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = md5_GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
        c = md5_GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
        b = md5_GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = md5_HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
        d = md5_HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
        c = md5_HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = md5_HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = md5_HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
        d = md5_HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
        c = md5_HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
        b = md5_HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = md5_HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = md5_HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
        c = md5_HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
        b = md5_HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
        a = md5_HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
        d = md5_HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = md5_HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = md5_HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
        a = md5_II(a, b, c, d, x[k + 0], S41, 0xF4292244);
        d = md5_II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
        c = md5_II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = md5_II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
        a = md5_II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = md5_II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
        c = md5_II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = md5_II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
        a = md5_II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
        d = md5_II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = md5_II(c, d, a, b, x[k + 6], S43, 0xA3014314);
        b = md5_II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = md5_II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
        d = md5_II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = md5_II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
        b = md5_II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
        a = md5_AddUnsigned(a, AA);
        b = md5_AddUnsigned(b, BB);
        c = md5_AddUnsigned(c, CC);
        d = md5_AddUnsigned(d, DD);
    &#125;
    return (md5_WordToHex(a) + md5_WordToHex(b) + md5_WordToHex(c) + md5_WordToHex(d)).toLowerCase();
&#125;
</code></pre>
<h3 id="复制内容"><a href="#复制内容" class="headerlink" title="复制内容"></a>复制内容</h3><p>首先在HTML文件中包含</p>
<pre><code class="html">&lt;textarea id=&quot;input&quot; style=&quot;width: 0px; height: 0px;&quot;&gt;&lt;/textarea&gt;
</code></pre>
<p>在js中编写</p>
<pre><code class="js"> function copyText() &#123;
          var text = dom.html();    //想要复制的内容
          var textarea = document.getElementById(&quot;input&quot;);
          textarea.value = text; // 修改文本框的内容
          textarea.select(); // 选中文本
          document.execCommand(&quot;copy&quot;); // 执行浏览器复制命令
          alert(&quot;复制成功&quot;);
        &#125;;
</code></pre>
<h3 id="连点键盘事件"><a href="#连点键盘事件" class="headerlink" title="连点键盘事件"></a>连点键盘事件</h3><pre><code class="js">let ot = 0;
    document.onkeydown = (e) =&gt; &#123;        //键盘点击事件
        if(e.keyCode == 8)&#123;

            let nt = new Date().getTime();
            let ct = nt - ot;
            if (ct &gt; 0 &amp;&amp; ct &lt; 150) &#123;    //调整连点的时间端
                document.getElementsByTagName(&#39;textarea&#39;)[0].value = &#39;&#39;;
            &#125;
        
            ot = nt;   //记录第一次点击时间
        &#125;
    &#125;
    //常用keycode
    
</code></pre>
<h3 id="数字以时间格式化"><a href="#数字以时间格式化" class="headerlink" title="数字以时间格式化"></a>数字以时间格式化</h3><pre><code class="js">function TimeFormat(number)&#123;
            var minute = parseInt(number / 60);
            var second = parseInt(number % 60);
            var hour = parseInt(number / 3600);
            minute = minute &gt;= 10 ? minute : &#39;0&#39; + minute;
            if(minute &gt; 59)&#123;
                minute = parseInt(minute % 60);
                minute = minute &gt;= 10 ? minute : &#39;0&#39; + minute;
            &#125;
            second = second &gt;= 10 ? second : &#39;0&#39; + second;
            hour = hour &gt;= 10 ? hour : &#39;0&#39; + hour;
            if(hour &gt; 23)&#123;
                hour = parseInt(hour % 24);
            &#125;
            return hour + &quot;:&quot;+ minute + &quot;:&quot; + second;
        &#125;
</code></pre>
<h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><p>引入文件</p>
<pre><code class="html"> &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;

 &lt;div&gt;&#123;&#123;变量/方法&#125;&#125;&lt;/div&gt;
</code></pre>
<p>创建对象</p>
<pre><code class="js">var duixiang = new Vue(&#123;
    //元素id
     el: &#39;#done&#39;,
    //定义变量
     data: &#123;
            bianliang: [],       
     &#125;,
    /*
        或者写为
        data() &#123;
            return &#123;
                bianliang: [],
            &#125;
        &#125;
    */
    //页面加载后就执行的函数
     mounted: function() &#123;&#125;,
     methods: &#123;
         fangfa() &#123;
             console.log(&quot;Vue&quot;);
         &#125;,
     &#125;
&#125;);
</code></pre>
<h4 id="v-clock-去除闪动问题"><a href="#v-clock-去除闪动问题" class="headerlink" title="v-clock(去除闪动问题)"></a>v-clock(去除闪动问题)</h4><pre><code class="css">[v-clock] &#123;
    display: none;
&#125;
</code></pre>
<pre><code class="html">&lt;div v-clock&gt;...&lt;/div&gt;
</code></pre>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>动态绑定属性/简写为“:”</p>
<p>标签属性</p>
<pre><code class="js"> &lt;a v-bind:href=&quot;变量&quot;&gt; &lt;img v-bind:src=&quot;变量&quot;&gt;&lt;/a&gt;
</code></pre>
<p>class属性</p>
<pre><code class="js"> v-bind:class=&quot;&#123;类名1:boolean,类名2:boolean&#125;&quot; 

//结合数组
 v-bind:class=&quot;[类名,类名,&#123;类名1:boolean,类名2:boolean&#125;]&quot; 
</code></pre>
<p>style属性</p>
<pre><code class="js"> //用驼峰命名，或是用单引号‘’
:style=&quot;&#123;key(attributeName):value(attributeValue),&#125;

//数组语法
:style=&quot;[object1,object2,…]
 object1: &#123;color: red&#125;;
</code></pre>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>事件监听/简写为@</p>
<pre><code class="html"> &lt;button @click=&quot;方法()&quot;&gt;&lt;/button&gt;
</code></pre>
<p>访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法</p>
<pre><code class="js">@click=&quot;show(&#39;vue&#39;,$event)&quot;
//作为最后一个参数显示传递，只用函数传递则默认传递事件

//获取事件类型
console.log(event.type)
// 事件源，就是发生事件的元素；
console.log(event.target)
</code></pre>
<p>修饰符</p>
<pre><code class="js">&lt;!-- 阻止单击事件继续传播 --&gt;
&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;

&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;

&lt;!-- 点击事件将只会触发一次 --&gt;
&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;
</code></pre>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>判断条件渲染内容</p>
<pre><code class="html">&lt;h2 v-if=&quot;条件或boolean&quot;&gt;&#123;&#123;excellent&#125;&#125;&lt;/h2&gt;
&lt;h2 v-else-if=&quot;条件或boolean&quot;&gt;&#123;&#123;good&#125;&#125;&lt;/h2&gt;
&lt;h2 v-else&gt;&#123;&#123;变量&#125;&#125;&lt;/h2&gt;
</code></pre>
<p>v-show 与 v-if 差不多相同</p>
<h5 id="v-if-与-v-show区别"><a href="#v-if-与-v-show区别" class="headerlink" title="v-if 与 v-show区别"></a>v-if 与 v-show区别</h5><blockquote>
<p>v-if控制元素是否渲染</p>
<p>v-show控制元素是否显示</p>
</blockquote>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>遍历数组</p>
<pre><code class="html"> &lt;ul v-for=&quot;(item,index) in 数组&quot;&gt;//(v,k)
        &lt;li&gt;&#123;&#123;item&#125;&#125; index=&#123;&#123;index&#125;&#125;&lt;/li&gt;
 &lt;/ul&gt;
</code></pre>
<p>:key的作用：帮助vue区分不同元素，以提高性能</p>
<pre><code class="html">&lt;ul v-for=&quot;(item,index) in 数组&quot; :key=&quot;item.id&quot;&gt;//(v,k)&gt;&lt;/ul&gt;
</code></pre>
<p>遍历对象</p>
<pre><code class="html">&lt;ul v-for=&#39;(v.k.i) in obj&#39;&gt;&lt;/ul&gt;
</code></pre>
<p>添加条件</p>
<pre><code class="html">&lt;ul v-if=&#39;v==xx&#39; v-for=&#39;(v.k.i) in obj&#39;&gt;&lt;/ul&gt;
</code></pre>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>表单和数据双向绑定，数据变化则同时变化</p>
<pre><code class="js">msg&#123;&#123;msg&#125;&#125;

v-model=&quot;msg&quot;
</code></pre>
<pre><code class="html">&lt;!--复选框--&gt;
&lt;select v-model=&quot;selected&quot; multiple &gt;
        &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;
        &lt;option&gt;选项&lt;/option&gt;
    &lt;/select&gt;
</code></pre>
<p>修饰符</p>
<p>**.number: ** 自动将用户的输入值转为数值类型</p>
<pre><code class="html">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;
</code></pre>
<p>.trim : 自动过滤用户输入的首尾空白字符</p>
<pre><code class="html">&lt;input v-model.trim=&quot;msg&quot;&gt;
</code></pre>
<h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><pre><code class="js">Vue.set(vm.list, 2, &quot;xxx&quot;);
vm.$set(list, 1, &quot;xxx&quot;);
</code></pre>
<h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><pre><code class="js">data: &#123;
    name:&#39;&#39;,
&#125;,
watch: &#123;
   name: function() &#123;
       console.log(&quot;aaa&quot;)
   &#125;
&#125;
</code></pre>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><pre><code class="js">computed: &#123;
    total() &#123;
        return a + b;
    &#125;
&#125;
//&#123;&#123;total&#125;&#125;
</code></pre>
<h3 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h3><h4 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h4><h5 id="全局组件（所有Vue实例化中都可以使用）"><a href="#全局组件（所有Vue实例化中都可以使用）" class="headerlink" title="全局组件（所有Vue实例化中都可以使用）"></a>全局组件（所有Vue实例化中都可以使用）</h5><pre><code class="js">//组件不支持驼峰

Vue.component(&#39;组件名&#39;,&#123;//组件的名称
    data: function() &#123;
          return: &#123;&#125;  
    &#125;,
     template:&#39;&lt;h2&gt;全局组件&lt;/h2&gt;&#39;//template是创建模板
    method: &#123;
        
    &#125;
&#125;)
/*
    或者
    const cnpC = Vue.extend(&#123;
        template: `&lt;div&gt;
                         &lt;h2&gt;标题&lt;/h2&gt;
                         &lt;p&gt;模板内容&lt;/p&gt;
                  &lt;div/&gt;`
    &#125;);
    // 2.注册全局组件(tagName,component)
    
    Vue.component(&#39;my-cmp&#39;, cnpC);
*/

//全局组件需定义在Vue实例化之前
</code></pre>
<h5 id="局部组件-只能当前实例化可用"><a href="#局部组件-只能当前实例化可用" class="headerlink" title="局部组件(只能当前实例化可用)"></a>局部组件(只能当前实例化可用)</h5><pre><code class="js"> new Vue(&#123;
     el:&#39;#app&#39;,
     // 局部组件注册是components带s，注册全局组件不用带s
     components:&#123;         
             &quot;组件名&quot;:&#123;        //组件名称                 
                 template:&#39;&lt;div&gt;&lt;h2&gt;标题&lt;/h2&gt; &lt;p&gt;模板内容&lt;/p&gt;&lt;div/&gt;&#39;//模板                
             &#125;
      &#125;
&#125;)
</code></pre>
<h5 id="用模板注册组件"><a href="#用模板注册组件" class="headerlink" title="用模板注册组件"></a>用模板注册组件</h5><pre><code class="html">&lt;template id = &quot;tempid&quot;&gt;
   &lt;div&gt;
      &lt;h2&gt;标题&lt;/h2&gt;
       &lt;p&gt;模板内容&lt;/p&gt;
   &lt;div/&gt;`
&lt;/template&gt;
  
&lt;!--
    在全局和局部组件中
    template: &#39;tempid&#39;,

--&gt;
    
</code></pre>
<h4 id="使用时"><a href="#使用时" class="headerlink" title="使用时"></a>使用时</h4><pre><code class="html">&lt;组件名&gt;&lt;/组件名&gt;
</code></pre>
<h4 id="组件嵌套"><a href="#组件嵌套" class="headerlink" title="组件嵌套"></a>组件嵌套</h4><pre><code class="js">new Vue(&#123;
 el:&quot;#app&quot;,
 components:&#123;
     father:&#123;          //father是个组件
         template:&#39;&lt;div&gt;这是father组件... &lt;son&gt;&lt;/son&gt;&lt;/div&gt;&#39;,
               components:&#123;  //这个components是在father组件里面的
                   son:&#123;   //又定义一个组件son
                         template:&#39;&lt;div&gt;这是son组件...&lt;/div&gt;&#39;
                    &#125;       
               &#125;
         &#125;
   &#125;
&#125;)
//使用时
//&lt;father&gt;&lt;/father&gt;
</code></pre>
<h2 id="组件之间传值"><a href="#组件之间传值" class="headerlink" title="组件之间传值"></a>组件之间传值</h2><h5 id="父传参数给子（单向数据流）"><a href="#父传参数给子（单向数据流）" class="headerlink" title="父传参数给子（单向数据流）"></a>父传参数给子（单向数据流）</h5><h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><pre><code class="js">data: &#123;
    mag:mag,
&#125;,
components:&#123;
     zi:&#123;
         template:&#39;&lt;div&gt;这是father组件... &lt;son&gt;&lt;/son&gt;&lt;/div&gt;&#39;, 
         props:[&#39;mag&#39;],//也可以传对象
      &#125;
&#125;

//使用时
//&lt;zi :msg=&quot;mag&quot;&gt;&lt;/zi&gt;
</code></pre>
<h5 id="子传参数给父"><a href="#子传参数给父" class="headerlink" title="子传参数给父"></a>子传参数给父</h5><pre><code class="js">//&lt;zi @click=&quot;$emit(&#39;fudo&#39;, can)/zido()&quot;&gt;&lt;/zi&gt;
method: &#123;
    zido() &#123;
       this.$emit(&#39;fudo&#39;, can);
    &#125;
&#125;
//&lt;fu @fudo=&quot;fudo&quot;&gt;
</code></pre>
<h5 id="非父子组件传值"><a href="#非父子组件传值" class="headerlink" title="非父子组件传值"></a>非父子组件传值</h5><pre><code class="js">//事件中心
var eventHub = new Vue();

//监听与销毁事件
eventHub.$on(&#39;add-do&#39;, do);
eventHub.$off(&#39;add-do&#39;, do);

//传递数据
eventHub.$emit(&#39;add-do&#39;,传值/&#123;&#125;);

//&lt;div @add-do=&#39;do($event)&#39;&gt;&lt;/&gt;
</code></pre>
<h4 id="父组件调用子组件"><a href="#父组件调用子组件" class="headerlink" title="父组件调用子组件"></a>父组件调用子组件</h4><pre><code class="js">/*
    使用子组件内部的方法
    &lt;!--给组件绑上一个ref属性，例如tree--&gt;
    &lt;Tree :data=&quot;data2&quot; ref=&quot;tree&quot; show-checkbox&gt;&lt;/Tree&gt;
*/

//然后就可以使用组件里的方法获取返回值
console.log(this.$refs.tree.getCheckedNodes())
this.$refs.tree.show()
</code></pre>
<h4 id="子组件调用父组件方法"><a href="#子组件调用父组件方法" class="headerlink" title="子组件调用父组件方法"></a>子组件调用父组件方法</h4><blockquote>
<p>1、this.$parent.event 来调用父组件的方法。</p>
</blockquote>
<p>父组件</p>
<pre><code class="js"> methods: &#123;
      fatherMethod() &#123;
        console.log(&#39;调用父组件方法&#39;);
      &#125;
 &#125;
</code></pre>
<p>子组件</p>
<pre><code class="js">//&lt;button @click=&quot;childClick()&quot;&gt;点击&lt;/button&gt;

childClick() &#123;
  this.$parent.fatherMethod();
&#125;
</code></pre>
<blockquote>
<p>2、在子组件里用 $emit向父组件触发一个事件，父组件监听这个事件。</p>
</blockquote>
<p>父组件</p>
<pre><code class="js">//&lt;child @fatherMethod=&quot;fatherMethod&quot;&gt;&lt;/child&gt;


methods: &#123;
   fatherMethod() &#123;
      console.log(&#39;调用父组件方法&#39;);
   &#125;
 &#125;
</code></pre>
<p>子组件</p>
<pre><code class="js">//&lt;button @click=&quot;childClick()&quot;&gt;点击&lt;/button&gt;

methods: &#123;
      childClick() &#123;
        this.$emit(&#39;fatherMethod&#39;);
      &#125;
 &#125;
</code></pre>
<blockquote>
<p>3、父组件把方法传入子组件中，在子组件里直接调用这个方法。</p>
</blockquote>
<p>父组件</p>
<pre><code class="html">  &lt;child :fatherMethod=&quot;fatherMethod&quot;&gt;&lt;/child&gt;
</code></pre>
<p>子组件</p>
<pre><code class="js">//&lt;button @click=&quot;childClick()&quot;&gt;点击&lt;/button&gt;

props: &#123;
    fatherMethod: &#123;
        type: Function,
        default: null
    &#125;
&#125;,
methods: &#123;
    childClick() &#123;
        if (this.fatherMethod) &#123;
          this.fatherMethod();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h3><ul>
<li>在祖先组件定义<code>provide</code>属性，返回传递的值</li>
<li>在后代组件通过<code>inject</code>接收组件传递过来的值</li>
</ul>
<p>祖先组件</p>
<pre><code class="javascript">provide()&#123;  
    return &#123;  
        foo:&#39;foo&#39;  
    &#125;  
&#125;
</code></pre>
<p>后代组件</p>
<pre><code class="javascript">inject:[&#39;foo&#39;] // 获取到祖先组件传递过来的值
</code></pre>
<h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><ul>
<li> 适用场景: 复杂关系的组件数据传递 </li>
<li> <code>Vuex</code>作用相当于一个用来存储共享变量的容器</li>
</ul>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h5 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h5><pre><code class="html">&lt;template id=&quot;template&quot;&gt;
     &lt;div&gt;
         &lt;slot name=&quot;slot1&quot;&gt;我是插槽&lt;/slot&gt;
     &lt;/div&gt;
&lt;/template&gt;

&lt;!--使用时--&gt;
&lt;zujian&gt;
    &lt;p slot=&quot;slot1&quot;&gt;
        自动替换插槽
    &lt;/p&gt;
&lt;/zujian&gt;
&lt;!--
    或者
&lt;zujian&gt;
    &lt;template v-slot:slot1&gt;
        &lt;p slot=&quot;slot1&quot;&gt;
            自动替换插槽
        &lt;/p&gt;
    &lt;/template&gt;
&lt;zujian&gt;
--&gt;
</code></pre>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>处理异步任务</p>
<pre><code class="js">var p = new Promise(function(resolve, reject) &#123;
    let xml = new XMLHttpRequest();
    //成功调用resolve(xml.responseText)否则reject(&#39;xxx&#39;)
&#125;);
p.then(function(ret) &#123;
    //从resolve得到正常结果
    &#125;,function()(ret) &#123;
    //从reject得到错误结果
     &#125;
)
/*
     = 
     .then(function() &#123;
    &#125;)
    .catch(function() &#123;

    &#125;);
*/
.then(function() &#123;
    console.log()
&#125;)
</code></pre>
<h5 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h5><pre><code class="js">//并发处理异步任务，所有任务执行完后得到结果
Promist.all([p1.p2.p3]).then((result) =&gt; &#123;
    console.log(result)
&#125;)

//并发处理异步任务，只要有一个任务执行完后得到结果
Promist.all([p1.p2.p3]).then((result) =&gt; &#123;    console.log(result)
&#125;)
</code></pre>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><pre><code class="js">fetch(&#39;url&#39;,&#123;
    method: &#39;DELETE//&#39;,
    body: &#39;=&amp;=&#39;,
    headers: &#123;
        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39; 
    &#125;
&#125;)
.then(function() &#123;
&#125;)
.then();
</code></pre>
<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><pre><code class="js">axios.get(&#39;url&#39;,&#123;
    params:&#123;
        name: &quot;&quot;,
    &#125;
&#125;).then(function(res) &#123;
        console.log(res.data)
&#125;);

axios.post(&#39;url&#39;,&#123;
    //默认json格式
    name:&quot;&quot;,
&#125;)
//传递表单参数
const params = new URLSearchParams();
params.append(&#39;param1&#39;,&#39;value1&#39;);
axios.post(&#39;url&#39;, params).then()
</code></pre>
<h5 id="基准URL地址"><a href="#基准URL地址" class="headerlink" title="基准URL地址"></a>基准URL地址</h5><pre><code class="js">axios.defaults.baseURL = &#39;http://localhost:3000/&#39;;
</code></pre>
<h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p>请求拦截器</p>
<pre><code class="js">axios.interceptors.request.use(function(config) &#123;
    config.headers.mytoken = &#39;nihao&#39;;
    return config;
&#125;, function(err) &#123;
    console.log(err)
&#125;)
axios.get()
</code></pre>
<p>响应拦截器</p>
<pre><code class="js">axios.interceptors.response.use(function(res) &#123;
    return res.data
&#125;,function()&#123;&#125;)
</code></pre>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><pre><code class="js">//async返回值是Promise实例对象
async function queryData() &#123;
    let res = await.axios.get(&#39;data&#39;);
    return res.data;
&#125;

queryData().then(function(data) &#123;
    console.log(data)
&#125;)
</code></pre>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h5 id="监听window的onhashchange事件"><a href="#监听window的onhashchange事件" class="headerlink" title="监听window的onhashchange事件"></a>监听window的onhashchange事件</h5><pre><code class="js">window.onhashchange = function()&#123;
    console.log(location.hash)
&#125;
</code></pre>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><h5 id="路由链接"><a href="#路由链接" class="headerlink" title="路由链接"></a>路由链接</h5><pre><code class="html">&lt;!--router-link默认会被渲染成a标签--&gt;
&lt;!--to会被渲染成href属性--&gt;
&lt;!--to属性值会被渲染为#开头的hash地址--&gt;
&lt;router-link to=&quot;/user&quot; &gt;user&lt;/router-link&gt;
</code></pre>
<h5 id="路由占位"><a href="#路由占位" class="headerlink" title="路由占位"></a>路由占位</h5><pre><code class="html">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
<h5 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h5><pre><code class="js">var router = new VueRouter(&#123;
    //path表示当前路由规则的hash地址
    //component表示路由规则对应展示的组件
    routes: [
        &#123;path:&#39;/user&#39;, component: User&#125;
    ]
&#125;)
</code></pre>
<h5 id="挂载路由实例对象"><a href="#挂载路由实例对象" class="headerlink" title="挂载路由实例对象"></a>挂载路由实例对象</h5><pre><code class="js">el: &#39;#app&#39;,
router: router,
</code></pre>
<h5 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h5><pre><code class="js">routes: [
    &#123;path: &#39;/&#39;, redirect: &#39;/user&#39;&#125;,
]
</code></pre>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><h5 id="子级路由模板"><a href="#子级路由模板" class="headerlink" title="子级路由模板"></a>子级路由模板</h5><pre><code class="js">template: `&lt;router-link to=&quot;/fu/zi1&quot;&gt;&lt;/router-link&gt;
//子路由占位符
&lt;router-view&gt;&lt;/&gt; `
</code></pre>
<h4 id="路由规则-1"><a href="#路由规则-1" class="headerlink" title="路由规则"></a>路由规则</h4><pre><code class="js">&#123;
    path: &#39;/fu&#39;,
    component: fu,
    children: [
        &#123;path: &#39;/fu/zi&#39;, component: zi&#125;,
    ]
&#125;
</code></pre>
<h4 id="动态匹配"><a href="#动态匹配" class="headerlink" title="动态匹配"></a>动态匹配</h4><pre><code class="js">routes: [
    &#123;path: &#39;/user/:id&#39;, component: User&#125;
]

//组件中
template:     `&lt;div&gt;User &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;`

//另一种
routes: [
    &#123;path: &#39;/user/:id&#39;, component: User, props: true&#125;
]
user = &#123;
    props: [&#39;id&#39;],
    template: `&#123;&#123;id&#125;&#125;`
&#125;
</code></pre>
<h5 id="props指定类型"><a href="#props指定类型" class="headerlink" title="props指定类型"></a>props指定类型</h5><pre><code class="js">props: route =&gt; (&#123;xxx: &#39;xx&#39;, xx: &#39;xx&#39;, xx: route.params.xx&#125;)
</code></pre>
<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><pre><code class="js">routes: [
    &#123;
        path:  &#39;&#39;,
        name: &#39;user&#39;,
    &#125;
]
</code></pre>
<pre><code class="html">&lt;router-link :to=&quot;&#123;name :&#39;user&#39;, params:&#123;id;xx&#125;&#125;&quot;&gt;&lt;/router-link&gt;
</code></pre>
<h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h4><pre><code class="js">this.$route.push(&#39;/path&#39;)
//命名路由带参数
//.push(&#123;name: &#39;&#39;, params: &#123;id: xxx&#125;&#125;)

//带查询参数  /xxx?id=xxx
//.push(&#123;path: &#39;&#39;, query: &#123;id: xxx&#125;&#125;)
this.$route.go()
</code></pre>
<h3 id="减小入口文件体积"><a href="#减小入口文件体积" class="headerlink" title="减小入口文件体积"></a>减小入口文件体积</h3><p>常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加</p>
<p><img src="https://static.vue-js.com/486cee90-3acc-11eb-ab90-d9ae814b240d.png" alt="img"></p>
<p>在<code>vue-router</code>配置路由的时候，采用动态加载路由的形式</p>
<pre><code class="javascript">routes:[ 
    path: &#39;Blogs&#39;,
    name: &#39;ShowBlogs&#39;,
    component: () =&gt; import(&#39;./components/ShowBlogs.vue&#39;)
]
</code></pre>
<p>以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件</p>
<h1 id="webpack-Vue"><a href="#webpack-Vue" class="headerlink" title="webpack + Vue"></a>webpack + Vue</h1><h3 id="下载yarn"><a href="#下载yarn" class="headerlink" title="下载yarn"></a>下载yarn</h3><p>下载地址:  <a target="_blank" rel="noopener" href="https://yarn.bootcss.com/docs/install/#windows-stable">https://yarn.bootcss.com/docs/install/#windows-stable</a> </p>
<ul>
<li><p>mac - 通过homebrew安装</p>
<ul>
<li><p>mac如果没安装过homeBrew先运行这个命令</p>
<pre><code class="bash">/usr/bin/ruby -e &quot;$(curl -fsSL http://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot;
</code></pre>
</li>
</ul>
</li>
<li><p>上面命令不行: 试试这个: curl -o- -L <a target="_blank" rel="noopener" href="https://yarnpkg.com/install.sh">https://yarnpkg.com/install.sh</a> | bash (直接安装yarn)</p>
</li>
</ul>
<h3 id="使用yarn"><a href="#使用yarn" class="headerlink" title="使用yarn"></a>使用yarn</h3><p>与npm类似,</p>
<pre><code class="bash"># 1. 初始化, 得到package.json文件(终端路径所在文件夹下)
yarn init

# 2. 添加依赖(下包)
# 命令: yarn add [package]
# 命令: yarn add [package]@[version]
yarn add jquery
yarn add jquery@3.5.1

# 3. 移除包
# 命令: yarn remove [package]
yarn remove jquery
             
# 4. 安装项目全部依赖(一般拿到别人的项目时, 缺少node_modules)          
yarn
# 会根据当前项目package.json记录的包名和版本, 全部下载到当前工程中

# 5. 全局
# 安装: yarn global add [package]
# 卸载: yarn global remove [package]
# 注意: global一定在add左边
yarn global add @vue/cli
</code></pre>
<h3 id="webpack基础使用"><a href="#webpack基础使用" class="headerlink" title="webpack基础使用"></a>webpack基础使用</h3><p>默认入口: ./src/index.js</p>
<p>默认出口: ./dist/main.js</p>
<p>==注意:路径上, 文件夹, 文件名不能叫webpack/其他已知的模块名==</p>
<ol>
<li><p>初始化包环境</p>
<pre><code class="bash">yarn init
</code></pre>
</li>
<li><p>安装依赖包</p>
<pre><code class="bash">yarn add webpack webpack-cli -D
</code></pre>
</li>
<li><p>配置scripts(自定义命令)</p>
<pre><code class="bash">scripts: &#123;
    &quot;build&quot;: &quot;webpack&quot;
&#125;
== &#123;
    &quot;dev&quot; :&quot;webpack&quot;
&#125;
      #npm run dev
</code></pre>
</li>
<li><p>新建目录src</p>
</li>
<li><p>新建src/add/add.js - 定义求和函数导出（按需导出和导入）</p>
<pre><code class="js">export const addFn = (a, b) =&gt; a + b
</code></pre>
</li>
<li><p>新建src/index.js导入使用</p>
<pre><code class="js">import &#123;addFn&#125; from &#39;./add/add&#39;

console.log(addFn(10, 20));

//import &#123;addFn as &quot;别名&quot;&#125; from &#39;./add/add&#39;
</code></pre>
</li>
<li><p>运行打包命令</p>
<pre><code class="bash">yarn build
#或者 npm run build
</code></pre>
</li>
</ol>
<blockquote>
<p>总结: src并列处, 生成默认dist目录和打包后默认main.js文件</p>
</blockquote>
<h3 id="webpack-入口和出口"><a href="#webpack-入口和出口" class="headerlink" title="webpack-入口和出口"></a>webpack-入口和出口</h3><blockquote>
<p>目标: 告诉webpack从哪开始打包, 打包后输出到哪里</p>
</blockquote>
<p>默认入口: ./src/index.js</p>
<p>默认出口: ./dist/main.js</p>
<p>webpack配置 - webpack.config.js(默认)</p>
<ol>
<li>新建src并列处, webpack.config.js</li>
<li>填入配置项</li>
</ol>
<pre><code class="js">const path = require(&quot;path&quot;)

module.exports = &#123;
    entry: &quot;./src/main.js&quot;, // 入口
    output: &#123; 
        path: path.join(__dirname, &quot;dist&quot;), // 出口路径
        filename: &quot;bundle.js&quot; // 出口文件名
    &#125;
&#125;
</code></pre>
<p>在src/main.js引入jquery</p>
<pre><code class="bash">yarn add jquery
</code></pre>
<p> 引入jquery</p>
<pre><code class="js">import $ from &#39;jquery&#39;
</code></pre>
<p>html引用js （打包生成后的js)</p>
<pre><code class="html">&lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h3 id="加载器-处理css文件"><a href="#加载器-处理css文件" class="headerlink" title="加载器 - 处理css文件"></a>加载器 - 处理css文件</h3><blockquote>
<p> loaders加载器, 可让webpack处理其他类型的文件, 打包到js中</p>
</blockquote>
<p>原因: webpack默认只认识 js 文件和 json文件</p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/style-loader/">style-loader文档</a></p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/css-loader/">css-loader文档</a></p>
<ol>
<li><p>安装依赖</p>
<pre><code>yarn add style-loader css-loader -D
</code></pre>
</li>
<li><p>webpack.config.js 配置</p>
<pre><code class="js">const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

module.exports = &#123;
    // ...其他代码
    module: &#123; 
        rules: [ // loader的规则
          &#123;
            test: /\.css$/, // 匹配所有的css文件
            // use数组里从右向左运行
            // 先用 css-loader 让webpack能够识别 css 文件的内容并打包
            // 再用 style-loader 将样式, 把css插入到dom中
            use: [ &quot;style-loader&quot;, &quot;css-loader&quot;]
          &#125;
        ]
    &#125;
&#125;
</code></pre>
</li>
<li><p>新建src/css/li.css - 去掉li默认样式</p>
<pre><code class="css">ul, li&#123;
    list-style: none;
&#125;
</code></pre>
</li>
<li><p>引入到main.js (因为这里是入口需要产生关系, 才会被webpack找到打包起来)</p>
<pre><code class="js">import &quot;./css/index.css&quot;
</code></pre>
<blockquote>
<p>引到入口, 才会被webpack打包, css打包进js中, 然后被嵌入在style标签插入dom上</p>
</blockquote>
</li>
</ol>
<h3 id="加载器-处理less文件"><a href="#加载器-处理less文件" class="headerlink" title="加载器 - 处理less文件"></a>加载器 - 处理less文件</h3><blockquote>
<p>目标: less-loader让webpack处理less文件, less模块翻译less代码</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/less-loader/">less-loader文档</a></p>
<ol>
<li><p>下载依赖包</p>
<pre><code class="bash">yarn add less less-loader -D
</code></pre>
</li>
<li><p>webpack.config.js 配置</p>
<pre><code class="js">module: &#123;
  rules: [ // loader的规则
    // ...省略其他
    &#123;
        test: /\.less$/,
        // 使用less-loader, 让webpack处理less文件, 内置还会用less翻译less代码成css内容
        use: [ &quot;style-loader&quot;, &quot;css-loader&quot;, &#39;less-loader&#39;]
    &#125;
  ]
&#125;
</code></pre>
</li>
<li><p>src/less/index.less  - 设置li字体大小24px</p>
<pre><code class="less">@size:24px;

ul, li&#123;
    font-size: @size
&#125;
</code></pre>
</li>
<li><p>引入到main.js中</p>
<pre><code class="js">import &quot;./less/index.less&quot;
</code></pre>
</li>
<li><p>打包运行dist/index.html 观察效果</p>
</li>
</ol>
<blockquote>
<p>总结: 只要找到对应的loader加载器, 就能让webpack处理不同类型文件</p>
</blockquote>
<h3 id="加载器-处理图片文件"><a href="#加载器-处理图片文件" class="headerlink" title="加载器 - 处理图片文件"></a>加载器 - 处理图片文件</h3><blockquote>
<p>目标: 用asset module方式(webpack5版本新增)</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/asset-modules/">asset module文档</a></p>
<p>如果使用的是webpack5版本的, 直接配置在webpack.config.js - 的 rules里即可</p>
<pre><code class="js">&#123;
    test: /\.(png|jpg|gif|jpeg)$/i,
    type: &#39;asset&#39;
&#125;
</code></pre>
<p>如果你用的是webpack4及以前的, 请使用者里的配置</p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/url-loader/">url-loader文档</a></p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/file-loader/">file-loader文档</a></p>
<ol>
<li><p>下载依赖包</p>
<pre><code class="bash">yarn add url-loader file-loader -D
</code></pre>
</li>
<li><p>webpack.config.js 配置</p>
<pre><code class="js">&#123;
  test: /\.(png|jpg|gif|jpeg)$/i,
  use: [
    &#123;
      loader: &#39;url-loader&#39;, // 匹配文件, 尝试转base64字符串打包到js中
      // 配置limit, 超过8k, 不转, file-loader复制, 随机名, 输出文件
      options: &#123;
        limit: 8 * 1024,
      &#125;,
    &#125;,
  ],
&#125;
</code></pre>
<p>图片转成 base64 字符串</p>
<ul>
<li>好处就是浏览器不用发请求了，直接可以读取</li>
<li>坏处就是如果图片太大，再转<code>base64</code>就会让图片的体积增大 30% 左右</li>
</ul>
</li>
<li><p>src/assets/准备老师发的2个图文件</p>
</li>
<li><p>在css/less/index.less - 把小图片用做背景图</p>
<pre><code class="less">body&#123;
    background: url(../assets/logo_small.png) no-repeat center;
&#125;
</code></pre>
</li>
<li><p>在src/main.js - 把大图插入到创建的img标签上, 添加body上显示</p>
<pre><code class="js">// 引入图片-使用
import imgUrl from &#39;./assets/1.gif&#39;
const theImg = document.createElement(&quot;img&quot;)
theImg.src = imgUrl
document.body.appendChild(theImg)
</code></pre>
</li>
<li><p>打包运行dist/index.html观察2个图片区别</p>
</li>
</ol>
<blockquote>
<p>总结:  url-loader 把文件转base64 打包进js中, 会有30%的增大, file-loader 把文件直接复制输出</p>
</blockquote>
<h3 id="webpack加载文件优缺点"><a href="#webpack加载文件优缺点" class="headerlink" title="webpack加载文件优缺点"></a>webpack加载文件优缺点</h3><p>图片转成 base64 字符串</p>
<ul>
<li>好处就是浏览器不用发请求了，直接可以读取</li>
<li>坏处就是如果图片太大，再转<code>base64</code>就会让图片的体积增大 30% 左右</li>
</ul>
<h3 id="加载器-处理字体文件"><a href="#加载器-处理字体文件" class="headerlink" title="加载器 - 处理字体文件"></a>加载器 - 处理字体文件</h3><blockquote>
<p>目标: 用asset module技术, asset/resource直接输出到dist目录下</p>
</blockquote>
<p>webpack5使用这个配置</p>
<pre><code class="js">&#123; // webpack5默认内部不认识这些文件, 所以当做静态资源直接输出即可
    test: /\.(eot|svg|ttf|woff|woff2)$/,
    type: &#39;asset/resource&#39;,
    generator: &#123;
        filename: &#39;font/[name].[hash:6][ext]&#39;
    &#125;
&#125;
</code></pre>
<p>webpack4及以前使用下面的配置</p>
<ol>
<li><p>webpack.config.js - 准备配置</p>
<pre><code class="js"> &#123; // 处理字体图标的解析
     test: /\.(eot|svg|ttf|woff|woff2)$/,
         use: [
             &#123;
                 loader: &#39;url-loader&#39;,
                 options: &#123;
                     limit: 2 * 1024,
                     // 配置输出的文件名
                     name: &#39;[name].[ext]&#39;,
                     // 配置输出的文件目录
                     outputPath: &quot;fonts/&quot;
                 &#125;
             &#125;
         ]
 &#125;
</code></pre>
</li>
<li><p>src/assets/ - 放入字体库fonts文件夹</p>
</li>
<li><p>在main.js引入iconfont.css</p>
<pre><code class="js">// 引入字体图标文件
import &#39;./assets/fonts/iconfont.css&#39;
</code></pre>
</li>
<li><p>在public/index.html使用字体图标样式</p>
<pre><code class="html">&lt;i class=&quot;iconfont icon-weixin&quot;&gt;&lt;/i&gt;
</code></pre>
</li>
<li><p>执行打包命令-观察打包后网页效果</p>
</li>
</ol>
<blockquote>
<p>总结: url-loader和file-loader 可以打包静态资源文件</p>
</blockquote>
<h3 id="加载器-处理高版本js语法"><a href="#加载器-处理高版本js语法" class="headerlink" title="加载器 - 处理高版本js语法"></a>加载器 - 处理高版本js语法</h3><blockquote>
<p>目标: 让webpack对高版本 的js代码, 降级处理后打包</p>
</blockquote>
<p>写代码演示: 高版本的js代码(箭头函数), 打包后, 直接原封不动打入了js文件中, 遇到一些低版本的浏览器就会报错</p>
<p>原因: <strong>webpack 默认仅内置了 模块化的 兼容性处理</strong>   <code>import  export</code></p>
<p>babel 的介绍 =&gt; 用于处理高版本 js语法 的兼容性  <a target="_blank" rel="noopener" href="https://www.babeljs.cn/">babel官网</a></p>
<p>解决: 让webpack配合babel-loader 对js语法做处理</p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/loaders/babel-loader/">babel-loader文档</a></p>
<ol>
<li><p>安装包</p>
<pre><code class="bash">yarn add -D babel-loader @babel/core @babel/preset-env
</code></pre>
</li>
<li><p>配置规则</p>
<pre><code class="js">module: &#123;
  rules: [
    &#123;
        test: /\.js$/,
        exclude: /(node_modules|bower_components)/,
        use: &#123;
            loader: &#39;babel-loader&#39;,
            options: &#123;
                presets: [&#39;@babel/preset-env&#39;] // 预设:转码规则(用bable开发环境本来预设的)
            &#125;
        &#125;
    &#125;
  ]
&#125;
</code></pre>
</li>
<li><p>在main.js中使用箭头函数(高版本js)</p>
<pre><code class="js">// 高级语法
const fn = () =&gt; &#123;
  console.log(&quot;你好babel&quot;);
&#125;
console.log(fn) // 这里必须打印不能调用/不使用, 不然webpack会精简成一句打印不要函数了/不会编译未使用的代码
// 没有babel集成时, 原样直接打包进lib/bundle.js
// 有babel集成时, 会翻译成普通函数打包进lib/bundle.js
</code></pre>
</li>
<li><p>打包后观察lib/bundle.js - 被转成成普通函数使用了 - 这就是babel降级翻译的功能</p>
</li>
</ol>
<blockquote>
<p>总结: babel-loader 可以让webpack 对高版本js语法做降级处理后打包</p>
</blockquote>
<h3 id="webpack-dev-server自动刷新"><a href="#webpack-dev-server自动刷新" class="headerlink" title="webpack-dev-server自动刷新"></a>webpack-dev-server自动刷新</h3><blockquote>
<p>目标: 启动本地服务, 可实时更新修改的代码, 打包<strong>变化代码</strong>到内存中, 然后直接提供端口和网页访问</p>
</blockquote>
<ol>
<li><p>下载包</p>
<pre><code class="bash">yarn add webpack-dev-server -D
</code></pre>
</li>
<li><p>配置自定义命令</p>
<pre><code class="js">scripts: &#123;
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;serve&quot;: &quot;webpack serve&quot;
&#125;
</code></pre>
</li>
<li><p>运行命令-启动webpack开发服务器</p>
<pre><code class="bash">yarn serve
#或者 npm run serve
</code></pre>
</li>
</ol>
<blockquote>
<p>以后改了src下的资源代码, 就会直接更新到内存打包, 然后反馈到浏览器上了</p>
</blockquote>
<h3 id="webpack-dev-server配置"><a href="#webpack-dev-server配置" class="headerlink" title="webpack-dev-server配置"></a>webpack-dev-server配置</h3><ol>
<li><p>在webpack.config.js中添加服务器配置</p>
<p>更多配置参考这里: <a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/dev-server/#devserverafter">https://webpack.docschina.org/configuration/dev-server/#devserverafter</a></p>
<pre><code class="js">module.exports = &#123;
    // ...其他配置
    devServer: &#123;
      port: 3000 // 端口号
    &#125;
&#125;
</code></pre>
</li>
</ol>
<h1 id="vue-cli脚手架"><a href="#vue-cli脚手架" class="headerlink" title="vue/cli脚手架"></a>vue/cli脚手架</h1><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>开箱即用</p>
<p>0配置webpack</p>
<p>babel支持</p>
<p>css, less支持</p>
<p>开发服务器支持</p>
<h4 id="全局安装命令"><a href="#全局安装命令" class="headerlink" title="全局安装命令"></a>全局安装命令</h4><pre><code class="bash">yarn global add @vue/cli
# OR
npm install -g @vue/cli
</code></pre>
<h5 id="查看脚手架版本"><a href="#查看脚手架版本" class="headerlink" title="查看脚手架版本"></a>查看脚手架版本</h5><pre><code class="bash">vue -V
</code></pre>
<h3 id="vue-cli-创建项目启动服务"><a href="#vue-cli-创建项目启动服务" class="headerlink" title="@vue/cli 创建项目启动服务"></a>@vue/cli 创建项目启动服务</h3><blockquote>
<p>目标: 使用vue命令, 创建脚手架项目</p>
</blockquote>
<p>==注意: 项目名不能带大写字母, 中文和特殊符号==</p>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><pre><code class="bash"># vue和create是命令, vuecli-demo是文件夹名
vue create vuecli-demo

#手动选择需要的
Manually select features

#（*）空格选择
# no history mode -&gt; hash模式
# Standard config
# lint in save
# dedicated config files
# Sava preset(模板)
</code></pre>
<h4 id="图形化创建"><a href="#图形化创建" class="headerlink" title="图形化创建"></a>图形化创建</h4><pre><code class="bash">vue ui

#选择手动配置
#babel,router,linter/Formatter,使用配置文件
#与以上相同
</code></pre>
<p>进入脚手架项目下, 启动内置的热更新本地服务器</p>
<pre><code class="bash">cd vuecil-demo

npm run serve
# 或
yarn serve
</code></pre>
<p>打开浏览器输入上述地址</p>
<p><img src="https://gitee.com/iLx1/resource-img/raw/master/image-20210116233035582.png" alt="image-20210116233035582"></p>
<h3 id="目录和代码分析"><a href="#目录和代码分析" class="headerlink" title="目录和代码分析"></a>目录和代码分析</h3><pre><code class="bash"> vuecil-demo        # 项目目录
    ├── node_modules # 项目依赖的第三方包
    ├── public       # 静态文件目录
      ├── favicon.ico# 浏览器小图标
      └── index.html # 单页面的html文件(网页浏览的是它)
    ├── src          # 业务文件夹
      ├── assets     # 静态资源
        └── logo.png # vue的logo图片
      ├── components # 组件目录
        └── HelloWorld.vue # 欢迎页面vue代码文件 
      ├── App.vue    # 整个应用的根组件
      └── main.js    # 入口js文件
    ├── .gitignore   # git提交忽略配置
    ├── babel.config.js  # babel配置
    ├── package.json  # 依赖包列表
    ├── README.md    # 项目说明
    └── yarn.lock    # 项目包版本锁定和缓存地址
</code></pre>
<h3 id="vue-cli-自定义配置"><a href="#vue-cli-自定义配置" class="headerlink" title="@vue/cli 自定义配置"></a>@vue/cli 自定义配置</h3><blockquote>
<p>目标：项目中没有webpack.config.js文件，因为@vue/cli用的vue.config.js</p>
</blockquote>
<p>src并列处新建vue.config.js</p>
<pre><code class="jsx">/* 覆盖webpack的配置 */
module.exports = &#123;
  devServer: &#123; // 自定义服务配置
    open: true, // 自动打开浏览器
    port: 3000
  &#125;
&#125;
</code></pre>
<h3 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element-UI"></a>Element-UI</h3><p>安装依赖</p>
<pre><code class="bash">yarn add element-ui -S
</code></pre>
<p>导入资源</p>
<pre><code class="js">//组件库
import ElementUI from &#39;element-ui&#39;;
//导入样式
import &#39;element-ui/lib/theme-chalk/index.css&#39;;
//配置插件
Vue.use(ElementUI)
</code></pre>
<p>图形化安装</p>
<p>vue-cli-plugin-element</p>
<h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>代码检查工具</p>
<h5 id="暂时关闭"><a href="#暂时关闭" class="headerlink" title="暂时关闭"></a>暂时关闭</h5><p>方式1: 手动解决掉错误, 以后项目中会讲如何自动解决</p>
<p>方式2: 暂时关闭eslint检查(因为现在主要精力在学习Vue语法上), 在vue.config.js中配置后重启服务</p>
<pre><code class="js">module.exports = &#123;
    lintOnSave: false,//关闭eslint检查
&#125;
</code></pre>
<h5 id="安装less依赖"><a href="#安装less依赖" class="headerlink" title="安装less依赖"></a>安装less依赖</h5><p>less-loader -&gt; less</p>
<h4 id="导入element表单"><a href="#导入element表单" class="headerlink" title="导入element表单"></a>导入element表单</h4><pre><code class="js">import &#123;Form, FormItem, Input&#125; from &#39;element-ui&#39;

Vue.use(Form)
Vue.use(FormItem)
Vue.use(Input)
</code></pre>
<h4 id="导入弹框提示组件"><a href="#导入弹框提示组件" class="headerlink" title="导入弹框提示组件"></a>导入弹框提示组件</h4><pre><code class="js">import &#123;Message&#125; from &#39;element-ui&#39;

//挂载到原型对象
Vue.prototype.$message = Message

this.$message.success(&quot;NIHAO&quot;)

//解决空白弹窗问题
import &#123; Message &#125; from &#39;element-ui&#39;

Vue.component(Message.name, Message)
              
Vue.prototype.$message = Message
</code></pre>
<h3 id="配置axios"><a href="#配置axios" class="headerlink" title="配置axios"></a>配置axios</h3><pre><code class="js">import axios from &#39;axios&#39;

axios.defaults.baseURL = &#39;127.0.0.1&#39;

Vue.prototype.$http = axios

//调用时
async () =&gt; 
//结构赋值
const &#123;data: res&#125; = await this.$http.post(&#39;&#39;,data)
</code></pre>
<h5 id="编程式导航-1"><a href="#编程式导航-1" class="headerlink" title="编程式导航"></a>编程式导航</h5><pre><code class="js">this.$router.push(&#39;/&#39;)
</code></pre>
<h5 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h5><pre><code class="js">router.beforeEach((to, from, next) =&gt; &#123;
    //to为访问的路径
    //from为从哪个路径跳转
    //next表示放行
    if(to.path == &#39;/&#39;) return next() //next(&#39;/&#39;)
&#125;)
</code></pre>
<h5 id="路由重定向-1"><a href="#路由重定向-1" class="headerlink" title="路由重定向"></a>路由重定向</h5><pre><code class="js">&#123;
  path: &#39;/admin&#39;, redirect: &#39;/admin/control&#39;,
&#125;,
</code></pre>
<h5 id="格式化文档"><a href="#格式化文档" class="headerlink" title="格式化文档"></a>格式化文档</h5><p>根目录创建”.prettierrc”（修改引号和分号）</p>
<pre><code class="json">&#123;
       &quot;semi&quot;: false,
    &quot;singleQuete&quot;: true
&#125;
</code></pre>
<h5 id="confirm闪退问题"><a href="#confirm闪退问题" class="headerlink" title="$confirm闪退问题"></a>$confirm闪退问题</h5><pre><code class="html">&lt;!--将a标签改为--&gt;
&lt;a href=&quot;javascript:viod(0)&quot;&gt;&lt;/a&gt;
</code></pre>
<h4 id="访问其他组件成员"><a href="#访问其他组件成员" class="headerlink" title="访问其他组件成员"></a>访问其他组件成员</h4><pre><code class="js">import zujian = from &#39;/path&#39;

zujian.data().成员
</code></pre>
<h4 id="打包好的VUE项目空白"><a href="#打包好的VUE项目空白" class="headerlink" title="打包好的VUE项目空白"></a>打包好的VUE项目空白</h4><p>vue.config.js文件</p>
<pre><code class="js">module.exports = defineConfig(&#123;
  assetsDir: &#39;static&#39;,
  parallel: false,
  publicPath: &#39;./&#39;,
&#125;)
</code></pre>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>