<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:600px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:600px)" href="/css/style.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <div class="bgimg"></div>
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            Arduino笔记
        </div>
        <div class="post-meta">
            2022-08-16
        </div>
    
<hr>
    <div class="post-md">
        <h3 id="点亮led灯"><a href="#点亮led灯" class="headerlink" title="点亮led灯"></a>点亮led灯</h3><h5 id="io输入"><a href="#io输入" class="headerlink" title="io输入"></a>io输入</h5><pre><code class="c">//int deng = 2;                        //IO2（D4）
int deng = 14;                       //IO14（D5）

void setup() &#123;
  pinMode(deng, OUTPUT);             //设置指定io为输出模式
  digitalWrite(deng, 0);             //初始化为低电平，关闭灯状态
  delay(3000);                       //先暂停3秒钟，保持关闭状态

//  digitalWrite(deng, HIGH); 
//  digitalWrite(deng, LOW);
&#125;

void loop() &#123;
  digitalWrite(deng, 1);              //置引脚高电平，点亮LED
&#125;
</code></pre>
<h5 id="io输出"><a href="#io输出" class="headerlink" title="io输出"></a>io输出</h5><pre><code class="c">  pinMode(button,INPUT_PULLUP);      //设置按钮引脚为上拉模式
  pinMode(deng, OUTPUT);             //设置指定io为输出模式
  digitalWrite(deng, 0);             //初始化为低电平，关闭灯状态
</code></pre>
<pre><code class="c">if(digitalRead(button)==0)&#123;        //如果读取到按钮引脚为低电平，视为按钮被按下
    digitalWrite(deng, 1);           //置引脚高电平，点亮LED
  &#125;
</code></pre>
<h3 id="串口监视器"><a href="#串口监视器" class="headerlink" title="串口监视器"></a>串口监视器</h3><pre><code class="c">void setup()&#123;  
Serial.begin(115200);             //开启串口监视器，设置波特率115200
  Serial.println(&quot;&quot;);               //打印输出一个空换行
  Serial.println(&quot;程序开始运行&quot;);    //打印输出一句话
&#125;
</code></pre>
<h3 id="模拟输出"><a href="#模拟输出" class="headerlink" title="模拟输出"></a>模拟输出</h3><pre><code class="c">  for(int i=0;i&lt;=1023;i++)&#123;           //模拟输出0-1023，对应电源电压0V-5V
    analogWrite(deng, i);             //i的值不断变大，LED亮度逐渐提高
    delay(1);                         //暂停时间，单位毫秒，用来延缓过程，展现效果
  &#125;
</code></pre>
<h5 id="舵机"><a href="#舵机" class="headerlink" title="舵机"></a>舵机</h5><pre><code class="c">#include &lt;Servo.h&gt;                  //加载舵机库         
Servo myservo;                      //定义一个舵机对象
int _servo = 14;                    //IO14（D5）
void setup() &#123;
  myservo.attach(_servo);           //设置指定io为舵机
  myservo.write(0);                 //开机设置舵机为0度
&#125;

void loop() &#123;
  for(int i=0;i&lt;=90;i++)&#123;           //控制舵机角度由0度旋转到90度    
    myservo.write(i);               //i的值不断变大，角度偏转
    delay(50);                      //暂停时间，单位毫秒，用来延缓过程，展现效果
  &#125;
  for(int i=90;i&gt;=0;i--)&#123;           //控制舵机角度由90度返回到0度          
    myservo.write(i);               //i的值不断变小，角度偏转
    delay(50);                      //暂停时间，单位毫秒，用来延缓过程，展现效果
  &#125;  
&#125;
</code></pre>
<h3 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h3><h5 id="读取电位器的输入"><a href="#读取电位器的输入" class="headerlink" title="读取电位器的输入"></a>读取电位器的输入</h5><pre><code class="c">int analogPin = A0;                     // 模拟引脚A0
int ledPin = 14;                        // LED引脚（D5）
void setup() &#123;
//  Serial.begin(115200);
//  Serial.println();
  pinMode(ledPin, OUTPUT);
&#125;

void loop() &#123;
  //ESP8266的模拟输入是0V-1V，区别于UNO和Nano的0V-5V
  //ESP8266的模拟输入和模拟输出一样也是0-1023，同样区别于UNO和Nano的0-255
  
  int analogValue = analogRead(analogPin);    //整形变量接收模拟值  
  analogWrite(ledPin, analogValue);           //把接收到的模拟值，设置为LED的模拟输出值，改变LED亮度
  delay(1);
  
//  delay(500);
//  Serial.println(analogValue);
&#125;
</code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code class="c">bool bl=0;      //布尔值，0和1

byte be=1;      //一个字节存储8位无符号数，从0到255。

int  i=2;       //整数，占用2字节。整数的范围为-32,768到32,767

long l=3;       //长整数,占用4字节，从-2,147,483,648到2,147,483,647。 

float f=3.14;   //浮点型数据，就是有一个小数点的数字。

char c=&#39;a&#39;;     //一个字符

String s=&quot;hello world!&quot;;   //特殊类型，字符串，字符的集合，拥有丰富的处理函数，可以对数据判断分析

unsigned int ui=3;         //（无符号整型）与整型数据同样大小，占据2字节。它只能用于存储正数而不能存储负数，范围0-65,535

unsigned long ul=4;       //（无符号长整型）与标准长整型不同，无符号长整型无法存储负数，其范围从0-4,294,967,295

const int abc=1;          //const前缀为常量，这里定义了整形常量，常量的定义后，不能对它的值再去改变
</code></pre>
<h3 id="EEPROM储存"><a href="#EEPROM储存" class="headerlink" title="EEPROM储存"></a>EEPROM储存</h3><h5 id="byte-与-bool-类型储存"><a href="#byte-与-bool-类型储存" class="headerlink" title="byte 与 bool 类型储存"></a>byte 与 bool 类型储存</h5><pre><code class="c">#include &lt;EEPROM.h&gt;         //加载EEPROM的库

bool is=1;                  //布尔类型值
byte byte_1=220;            //byte类型数值
char char_1= &#39;a&#39;;           //char字符 
</code></pre>
<pre><code class="c">void setup()&#123;

 EEPROM.begin(1024);                  //开启EEPROM，开辟1024个位空间 

  //1.读取与保存byte类型，bool类型值的0和1包含0-255内
  EEPROM.write(0,byte_1);              //给EEPROM 第0位，写入byte_1的值
  EEPROM.commit();                     //保存EEPROM改变，区别于uno和nano，esp8266需要使用此函数   保存EEPROM 
  byte byte_2=EEPROM.read(0);          //用byte类型读取接收EEPROM的值
  Serial.print(&quot;byte_2的值：&quot;); 
  Serial.println(byte_2);              //打印输出byte_2的值,等同于byte_1的值
  
  //2.读取与保存char类型,和byte类型大致一样，读取时需要转换一下类型
  EEPROM.write(0,char_1);              //给EEPROM 第0位，写入char_1的值
  EEPROM.commit();                     //保存EEPROM改变，区别于uno和nano，esp8266需要使用此函数   保存EEPROM 
  char char_2=char(EEPROM.read(0));    //如果用char类型读取，需要转换接收EEPROM的值的类型
  Serial.print(&quot;char_2的值：&quot;); 
  Serial.println(char_2);              //打印输出abc_2的值,等同于char_1的值
&#125;
</code></pre>
<h5 id="int-型储存"><a href="#int-型储存" class="headerlink" title="int 型储存"></a>int 型储存</h5><pre><code class="c">#include &lt;EEPROM.h&gt; 
int a=1234;
//使用union结构，多个不同类型变量，共用一个内存空间
union int_value&#123;        //int 类型，定义一个结构
  int i;                //int类型成员变量
  byte b[2];            //byte类型数组成员
&#125;;
int_value e_int;        //定义一个结构对象
void setup() &#123;
  Serial.begin(115200); 
  Serial.println(&quot;&quot;);   
  EEPROM.begin(1024);         //开启EEPROM，开辟1024个位空间

  //一个字节保存不了的int，我们把它拆为2个字节保存，最后可以再组装回来，实现对int类型的保存和读取
  
  e_int.i=a;                       //给e_int.i重新赋值为a
  EEPROM.write(0,e_int.b[0]);     //给EEPROM 第0位，写入e_int.b[0]的值
  EEPROM.write(1,e_int.b[1]);     //给EEPROM 第1位，写入e_int.b[1]的值
  EEPROM.commit();                //保存EEPROM改变
  byte a1=EEPROM.read(0);         //a1获取EEPROM 0 位的值
  byte a2=EEPROM.read(1);         //a2获取EEPROM 1 位的值
  e_int.b[0]=a1;
  e_int.b[1]=a2;
  Serial.print(&quot;e_int.i的值：&quot;); 
  Serial.println(e_int.i);        //这里打印输出的e_int.i，其实就是间接的a

  //最后说一下，long类型和int一样，用union类型操作，只是把成员改一下，long占用4个字节，读取和写入对应的一样的道理，这里就不再展示了
  //float类型和long类型一样
&#125;

void loop() &#123;

&#125;
</code></pre>
<h5 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h5><pre><code class="c">#include &lt;EEPROM.h&gt; 
String str=&quot;hello&quot;;                        //String字符串

void setup() &#123;
  Serial.begin(115200); 
  Serial.println(&quot;&quot;);   
  EEPROM.begin(1024);                      //开启EEPROM，开辟1024个位空间
  
  //String类型，更会复杂，需要加点技巧，实现保存和读取
  
  Serial.print(&quot;str的值：&quot;);
  Serial.println(str);                     //先打印输出初始的str字符串的值 
  str=&quot;hello world&quot;;                       //重新给str字符串赋值
  set_String(0,1,str);                     //保存str字符串到EEPROM(长度位，起始位，字符串)
  String s=get_String(EEPROM.read(0),1);  //读取EEPROM里的str字符串(所取位数，起始位)

  Serial.print(&quot;s的值：&quot;); 
  Serial.println(s);                      //打印输出此时的s对应str字符串的值  
&#125;

void loop() &#123;

&#125;

//用EEPROM的a位保存字符串的长度，字符串的从EEPROM的b位开始保存，str为要保存的字符串
void set_String(int a,int b,String str)&#123;
  EEPROM.write(a, str.length());//EEPROM第a位，写入str字符串的长度
  //通过一个for循环，把str所有数据，逐个保存在EEPROM
  for (int i = 0; i &lt; str.length(); i++)&#123;
    EEPROM.write(b + i, str[i]);
  &#125;
  EEPROM.commit();//执行保存EEPROM
&#125;

//获取指定EEPROM位置的字符串，a是字符串长度，b是起始位，从EEPROM的b位开始读取
String get_String(int a, int b)&#123; 
  String data = &quot;&quot;;
  //通过一个for循环，从EEPROM中逐个取出每一位的值，并连接起来
  for (int i = 0; i &lt; a; i++)&#123;
    data += char(EEPROM.read(b + i));
  &#125;
  return data;
&#125;
</code></pre>
<h3 id="AP模式"><a href="#AP模式" class="headerlink" title="AP模式"></a>AP模式</h3><pre><code class="c">#include &lt;ESP8266WiFi.h&gt;      
const char *ssid = &quot;&quot;;             //AP的SSID（WiFi名字）
const char *password = &quot;&quot;;            //AP的密码
int led=14;                                   //设置指示灯io，D5
void setup() &#123;
  Serial.begin(115200);
  Serial.println(&quot;&quot;);
  pinMode(led,OUTPUT);
  digitalWrite(led,0);  
  WiFi.mode(WIFI_AP);                         //设置为AP模式
  WiFi.softAP(ssid, password);                //配置AP信息，并开启AP
  
  //默认IP为192.168.4.1 , 这里我自定义设置AP的ip段
  IPAddress softLocal(192,168,1,1);           //IP地址，用以设置IP第4字段
  IPAddress softGateway(192,168,1,1);         //IP网关，用以设置IP第3字段
  IPAddress softSubnet(255,255,255,0);
  //配置自定义的IP信息
  WiFi.softAPConfig(softLocal, softGateway, softSubnet);  
  IPAddress myIP = WiFi.softAPIP();           //用变量myIP接收AP当前的IP地址
  Serial.println(myIP);                       //打印输出myIP的IP地址

&#125;
void loop() &#123; 
  int gotoAP=WiFi.softAPgetStationNum();    //获取当前连接到AP的设备数量  
  //如果没有设备连接到AP，熄灭LED灯，否则点亮LED灯
  if(gotoAP==0)&#123;                            //连接数为0，说明AP没有设备连接 
    digitalWrite(led,0);                    //熄灭LED灯
  &#125;else&#123;
    digitalWrite(led,1);                    //点亮LED灯
  &#125;  
&#125;
</code></pre>
<h3 id="超声波模块"><a href="#超声波模块" class="headerlink" title="超声波模块"></a>超声波模块</h3><pre><code class="c">#include &quot;SR04.h&quot;                 //超声波库
int E=4;                          //IO4(D2),Echo  获取返回的超声波时间差
int T=5;                          //IO5(D1),Trig  给超声波模块发送指令
SR04 sr04 = SR04(E,T);            //配置超声波的IO引脚
int deng = 14;                    //IO14（D5），LED指示灯 
void setup() &#123;
  Serial.begin(115200);
  Serial.println(&quot;&quot;);
  pinMode(deng, OUTPUT);          //设置指定io为输出模式
  digitalWrite(deng, 0);          //初始化为低电平，关闭灯状态
&#125;

void loop() &#123;
  int a=sr04.Distance();          //获取当前距离值，返回给a
  //如果距离小于等于10厘米，点亮led，如果距离大于10厘米，再次熄灭led
  if(a&lt;=10)&#123;
    digitalWrite(deng, 1); 
  &#125;
  else&#123;
    digitalWrite(deng, 0); 
  &#125;
  //打印输出拼接格式，例如：  距离：24厘米
  Serial.print(&quot;距离:&quot;);
  Serial.print(a);
  Serial.println(&quot;厘米&quot;);
  delay(500);
&#125; 
</code></pre>
<h2 id="oled显示屏"><a href="#oled显示屏" class="headerlink" title="oled显示屏"></a>oled显示屏</h2><h4 id="Adafruit库"><a href="#Adafruit库" class="headerlink" title="Adafruit库"></a>Adafruit库</h4><pre><code class="c">#include &lt;Wire.h&gt;  
#include &lt;Adafruit_GFX.h&gt;
#include &lt;Adafruit_SSD1306.h&gt;
#define SDA_PIN 8

#define SCL_PIN 9

Adafruit_ssd1306syp display(SDA_PIN,SCL_PIN);

#define SCREEN_WIDTH 128 // 设置OLED宽度,单位:像素

#define SCREEN_HEIGHT 64 // 设置OLED高度,单位:像素
 
// 自定义重置引脚,虽然教程未使用,但却是Adafruit_SSD1306库文件所必需的
#define OLED_RESET 3
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);
</code></pre>
<pre><code class="c"> // 初始化OLED并设置其IIC地址为 0x3C
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
</code></pre>
<pre><code class="c">display.update(); //画面更新，也就是保存更改，在你制定显示内容后一定要调用此函数才能显示

display.clear(); //清空显示

display.setTextColor(WHITE); //设置颜色（白色，取决于你的显示屏） display.setTextColor(BLACK, WHITE); //反白，白底黑字
display.setCursor(0, 0); //设置光标位置

display.setTextSize(1); //设置字号

display.print(&quot;123&quot;); //打印文字，不换行

display.println(“123”); //打印文字，换行

display.println(0xDEADBEEF, HEX); //以HEX格式输出

display.drawLine(0, 0, 127, 63,WHITE); 画线，从坐标（0,0)画直线到坐标(127,63)
    
display.display();
</code></pre>
<h5 id="显示汉字"><a href="#显示汉字" class="headerlink" title="显示汉字"></a>显示汉字</h5><pre><code class="c">#define SCREEN_WIDTH 128 // 设置OLED宽度,单位:像素
#define SCREEN_HEIGHT 64 // 设置OLED高度,单位:像素
#define OLED_RESET 3
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &amp;Wire, OLED_RESET);
static const unsigned char PROGMEM hans_ni[] = &#123;
    0x08,0x80,0x08,0x80,0x08,0x80,0x11,0xFE,0x11,0x02,0x32,0x04,0x34,0x20,0x50,0x20,
0x91,0x28,0x11,0x24,0x12,0x24,0x12,0x22,0x14,0x22,0x10,0x20,0x10,0xA0,0x10,0x40,/*&quot;你&quot;,0*/
&#125;;

static const unsigned char PROGMEM hans_hao[] = &#123;
    0x10,0x00,0x10,0xFC,0x10,0x04,0x10,0x08,0xFC,0x10,0x24,0x20,0x24,0x20,0x25,0xFE,
0x24,0x20,0x48,0x20,0x28,0x20,0x10,0x20,0x28,0x20,0x44,0x20,0x84,0xA0,0x00,0x40,/*&quot;好&quot;,0*/
&#125;;

void loop()
&#123;
    hans_display_0();
&#125;
 
void hans_display_0(void)
&#123;
    // 显示之前清屏
    display.clearDisplay();
 
    // 显示文字 (左上角x坐标,左上角y坐标, 图形数组, 图形宽度像素点, 图形高度像素点, 设置颜色)
    display.drawBitmap(20 * 1, 16, hans_ni, 16, 16, 1);
    display.drawBitmap(20 * 2, 16, hans_hao, 16, 16, 1);
 
    //显示图形
    display.display();
    delay(2000);
&#125;
</code></pre>
<img src="https://gitee.com/iLx1/resource-img/raw/master/Snipaste_2022-02-27_20-28-11.png" style="zoom: 50%; float: left;" />

<img src="https://gitee.com/iLx1/resource-img/raw/master/Snipaste_2022-02-27_20-31-23.png" alt="Snipaste_2022-02-27_20-31-23" style="zoom: 50%; float: left;" />

<img src="https://gitee.com/iLx1/resource-img/raw/master/Snipaste_2022-02-27_20-32-03.png" alt="Snipaste_2022-02-27_20-32-03" style="zoom: 50%; float:left;" />

<h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p>需要bmp格式的单色图片</p>
<h4 id="U8库"><a href="#U8库" class="headerlink" title="U8库"></a>U8库</h4><pre><code class="c">#include &lt;U8g2lib.h&gt;
#include &lt;Wire.h&gt;
</code></pre>
<h5 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h5><pre><code class="c">#define SCL 5
#define SDA 4
U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(U8G2_R0, /*clock=*/SCL, /*data=*/SDA, /*reset=*/U8X8_PIN_NONE);
</code></pre>
<p>setup</p>
<pre><code class="c">  u8g2.begin();
  u8g2.setFont(u8g2_font_unifont_t_symbols);
  u8g2.firstPage();
  u8g2.enableUTF8Print();//enable UTF8
  u8g2.setFont(u8g2_font_wqy12_t_gb2312b);//设置中文字符集
  do
  &#123;
    u8g2.setCursor(0, 15); //指定显示位置
    u8g2.print(&quot;WELCOME&quot;); //使用print来显示字符串
    u8g2.setCursor(0, 30); //指定显示位置
    u8g2.print(&quot;MASTER&quot;); //使用print来显示字符串
  &#125; while (u8g2.nextPage());
</code></pre>
<p>更多使用方法</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15542275?spm_id_from=333.788.b_636f6d6d656e74.16">https://www.bilibili.com/read/cv15542275?spm_id_from=333.788.b_636f6d6d656e74.16</a></p>
<h1 id="建立web服务器，用页面控制硬件"><a href="#建立web服务器，用页面控制硬件" class="headerlink" title="建立web服务器，用页面控制硬件"></a>建立web服务器，用页面控制硬件</h1><pre><code class="c">#include &lt;ESP8266WiFi.h&gt;
#include &lt;ESP8266WiFiMulti.h&gt;
#include &lt;ESP8266WebServer.h&gt;
#include &lt;FS.h&gt;  

ESP8266WiFiMulti wifiMulti;     // 建立ESP8266WiFiMulti对象

ESP8266WebServer esp8266_server(80);    // 建立网络服务器对象，该对象用于响应HTTP请求。监听端口（80）
</code></pre>
<h5 id="连接wifi"><a href="#连接wifi" class="headerlink" title="连接wifi"></a>连接wifi</h5><pre><code class="c">wifiMulti.addAP(&quot;lnettwo&quot;, &quot;lhl15352319937&quot;); // 将需要连接的一系列WiFi ID和密码输入这里
</code></pre>
<h5 id="判断wifi是否连接"><a href="#判断wifi是否连接" class="headerlink" title="判断wifi是否连接"></a>判断wifi是否连接</h5><pre><code class="c">int i = 0;  
  while (wifiMulti.run() != WL_CONNECTED) &#123; // 尝试进行wifi连接。
    delay(1000);
    Serial.print(i++); Serial.print(&#39; &#39;);//打印连接时长
  &#125;
</code></pre>
<h5 id="连接成功后打印ip"><a href="#连接成功后打印ip" class="headerlink" title="连接成功后打印ip"></a>连接成功后打印ip</h5><pre><code class="c"> // WiFi连接成功后将通过串口监视器输出连接成功信息 
  Serial.println(&#39;\n&#39;);
  Serial.print(&quot;Connected to &quot;);
  Serial.println(WiFi.SSID());              // 通过串口监视器输出连接的WiFi名称
  Serial.print(&quot;IP address:\t&quot;);
  Serial.println(WiFi.localIP());           // 通过串口监视器输出ESP8266-NodeMCU的IP
</code></pre>
<h5 id="启动闪存系统"><a href="#启动闪存系统" class="headerlink" title="启动闪存系统"></a>启动闪存系统</h5><p>Serial Peripheral Interface Flash File System（SPIFFS）</p>
<pre><code class="c++">#include &lt;FS.h&gt;
</code></pre>
<pre><code class="c"> if(SPIFFS.begin())&#123;                       // 启动闪存文件系统
    Serial.println(&quot;SPIFFS Started.&quot;);
  &#125; else &#123;
    Serial.println(&quot;SPIFFS Failed to Start.&quot;);
  &#125;
</code></pre>
<p><a target="_blank" rel="noopener" href="http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-c/spiffs/upload-files/">安装教程</a></p>
<p>上传代码前需要点ESP8266 Sketch  Data upload</p>
<h4 id="esp8266-server服务器对象"><a href="#esp8266-server服务器对象" class="headerlink" title="esp8266_server服务器对象"></a>esp8266_server服务器对象</h4><pre><code class="c">esp8266_server.on(&quot;/LED-Control&quot;, handleLEDControl); // 告知系统如何处理/LED-Control请求
</code></pre>
<p>同时html包含</p>
<pre><code class="html">&lt;form action=&quot;LED-Control&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;LED控制&quot;&gt;&lt;/form&gt;
</code></pre>
<pre><code class="html">&lt;form action=&quot;/LED-Control&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;value1&quot;&gt;
        &lt;/br&gt;
        &lt;input type=&quot;text&quot; name=&quot;value2&quot;&gt;
        &lt;/br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;OK&quot;&gt;
    &lt;/form&gt;
</code></pre>
<h4 id="通过Ajax控制及传输数据"><a href="#通过Ajax控制及传输数据" class="headerlink" title="通过Ajax控制及传输数据"></a>通过Ajax控制及传输数据</h4><pre><code class="c">  esp8266_server.on(&quot;/setLED&quot;, handleLED);
  esp8266_server.on(&quot;/readADC&quot;, handleADC);
</code></pre>
<pre><code class="c">void handleLED() &#123;
 String ledState = &quot;OFF&quot;;
 String LED_State = esp8266_server.arg(&quot;LEDstate&quot;); //参考xhttp.open(&quot;GET&quot;, &quot;setLED?LEDstate=&quot;+led, true);
 Serial.println(LED_State);
 
 if(LED_State != &quot;0&quot;)&#123;
  digitalWrite(LED_BUILTIN,LOW); //LED 点亮
  ledState = &quot;ON&quot;; //反馈参数
 &#125; else &#123;
  digitalWrite(LED_BUILTIN,HIGH); //LED 熄灭
  ledState = &quot;OFF&quot;; //反馈参数
 &#125;
 esp8266_server.send(200, &quot;text/plain&quot;, ledState); //发送网页
&#125;


void handleADC() &#123;
 int a = analogRead(A0);
 String adcValue = String(a);
 
 esp8266_server.send(200, &quot;text/plain&quot;, adcValue); //发送模拟输入引脚到客户端ajax请求
&#125;
</code></pre>
<h5 id="在js中"><a href="#在js中" class="headerlink" title="在js中"></a>在js中</h5><pre><code class="js">&lt;button type=&quot;button&quot; onclick=&quot;sendData(1)&quot;&gt;点亮 LED&lt;/button&gt;
&lt;button type=&quot;button&quot; onclick=&quot;sendData(0)&quot;&gt;关闭 LED&lt;/button&gt;&lt;br&gt;
</code></pre>
<pre><code class="js">//-------------js原生方法----------------------------------------------------------------
function sendData(led) &#123;
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() &#123;
    if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;
      document.getElementById(&quot;LEDState&quot;).innerHTML =
      this.responseText;
    &#125;
  &#125;;
  xhttp.open(&quot;GET&quot;, &quot;setLED?LEDstate=&quot;+led, true);
  xhttp.send();
&#125;
//------------jq方法----------------------------------------------------------------------
 function sendData(led)&#123;
    $.ajax(&#123;
      type:&#39;GET&#39;,
      url:&#39;setLED&#39;,
      data:&#123;
        LEDstate:led,
      &#125;,
      success:(res)=&gt;&#123;
        if(res.status == 200)&#123;
          console.log(res);
          document.getElementById(&quot;LEDState&quot;).innerHTML = res;
          var text = &#39;灯已打开&#39;;
          if(res == &quot;ON&quot;)&#123;
          transText(text);
        &#125;else&#123;
        text = &#39;灯已关闭&#39;;
          transText(text);
        &#125;
        &#125;
      &#125;,
    &#125;)
 &#125;

//结合文本转语音
 function transText(text)&#123;
      var url = &quot;http://tts.youdao.com/fanyivoice?le=zh&amp;keyfrom=speaker-target&amp;word=&#39;&quot; +encodeURI(text);
      new Audio(url).play();
    &#125;
setInterval(function() &#123;
  // Call a function repetatively with 2 Second interval
  getData();
&#125;, 2000); //2000mSeconds update rate
 
function getData() &#123;
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() &#123;
    if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;
      document.getElementById(&quot;ADCValue&quot;).innerHTML =
      this.responseText;
    &#125;
  &#125;;
  xhttp.open(&quot;GET&quot;, &quot;readADC&quot;, true);
  xhttp.send();
&#125;
</code></pre>
<h5 id="处理GET请求"><a href="#处理GET请求" class="headerlink" title="处理GET请求"></a>处理GET请求</h5><pre><code class="c">       esp8266_server.on(&quot;/ledHandle&quot;, ledHandle);
    esp8266_server.onNotFound(handleUserRequet);      // 告知系统如何处理用户请求

      esp8266_server.begin();                           // 启动网站服务
      Serial.println(&quot;HTTP server started&quot;);
</code></pre>
<h5 id="处理用户请求"><a href="#处理用户请求" class="headerlink" title="处理用户请求"></a>处理用户请求</h5><pre><code class="c">void loop(void) &#123;
  esp8266_server.handleClient();                    // 处理用户请求
&#125;
</code></pre>
<h4 id="处理-LED-Control请求"><a href="#处理-LED-Control请求" class="headerlink" title="处理/LED-Control请求"></a>处理/LED-Control请求</h4><pre><code class="c">void handleLEDControl()&#123;
   bool ledStatus = digitalRead(LED_BUILTIN);     // 此变量用于储存LED状态     
   ledStatus == HIGH ? digitalWrite(LED_BUILTIN, LOW) : digitalWrite(LED_BUILTIN, HIGH);  // 点亮或者熄灭LED  
     
   esp8266_server.sendHeader(&quot;Location&quot;, &quot;/LED.html&quot;);       
   esp8266_server.send(303);  
&#125;
</code></pre>
<h5 id="从浏览器发送的信息中获取控制数值（字符串格式）"><a href="#从浏览器发送的信息中获取控制数值（字符串格式）" class="headerlink" title="从浏览器发送的信息中获取控制数值（字符串格式）"></a>从浏览器发送的信息中获取控制数值（字符串格式）</h5><pre><code class="c">  String value1 = esp8266_server.arg(&quot;value1&quot;); 
  String value2 = esp8266_server.arg(&quot;value2&quot;);
</code></pre>
<h5 id="获取数值后赋值"><a href="#获取数值后赋值" class="headerlink" title="获取数值后赋值"></a>获取数值后赋值</h5><pre><code class="c">// 从浏览器发送的信息中获取PWM控制数值（字符串格式）
  String ledPwm = esp8266_server.arg(&quot;ledPwm&quot;); 

  // 将字符串格式的PWM控制数值转换为整数
  int ledPwmVal = ledPwm.toInt();

  // 实施引脚PWM设置
  analogWrite(LED_BUILTIN, ledPwmVal);
</code></pre>
<pre><code class="c"> // 建立基本网页信息显示当前数值以及返回链接
  String httpBody = &quot;value1: &quot; + value1 + &quot;&lt;br&gt; value2: &quot; + value2 + &quot;&lt;p&gt;&lt;a             href=\&quot;/LED.html\&quot;&gt;&lt;-LED Page&lt;/a&gt;&lt;/p&gt;&quot;;           
  esp8266_server.send(200, &quot;text/html&quot;, httpBody);
</code></pre>
<h4 id="处理用户浏览器的HTTP访问"><a href="#处理用户浏览器的HTTP访问" class="headerlink" title="处理用户浏览器的HTTP访问"></a>处理用户浏览器的HTTP访问</h4><pre><code class="c">void handleUserRequet() &#123;         
     
  // 获取用户请求网址信息
  String webAddress = esp8266_server.uri();

  // 通过handleFileRead函数处处理用户访问
  bool fileReadOK = handleFileRead(webAddress);

  // 如果在SPIFFS无法找到用户访问的资源，则回复404 (Not Found)
  if (!fileReadOK)&#123;                                                 
    esp8266_server.send(404, &quot;text/plain&quot;, &quot;404 Not Found&quot;); 
  &#125;
&#125;
</code></pre>
<h4 id="处理浏览器HTTP访问"><a href="#处理浏览器HTTP访问" class="headerlink" title="处理浏览器HTTP访问"></a>处理浏览器HTTP访问</h4><pre><code class="c">bool handleFileRead(String path) &#123;            //处理浏览器HTTP访问

  if (path.endsWith(&quot;/&quot;)) &#123;                   // 如果访问地址以&quot;/&quot;为结尾
    path = &quot;/index.html&quot;;                     // 则将访问地址修改为/index.html便于SPIFFS访问
  &#125; 
    
  String contentType = getContentType(path);  // 获取文件类型
  
  if (SPIFFS.exists(path)) &#123;                     // 如果访问的文件可以在SPIFFS中找到
    File file = SPIFFS.open(path, &quot;r&quot;);          // 则尝试打开该文件
    esp8266_server.streamFile(file, contentType);// 并且将该文件返回给浏览器
    file.close();                                // 并且关闭文件
    return true;                                 // 返回true
  &#125;
  return false;                                  // 如果文件未找到，则返回false
&#125;
</code></pre>
<h4 id="获取文件类型"><a href="#获取文件类型" class="headerlink" title="获取文件类型"></a>获取文件类型</h4><pre><code class="c">// 获取文件类型
String getContentType(String filename)&#123;
  if(filename.endsWith(&quot;.htm&quot;)) return &quot;text/html&quot;;
  else if(filename.endsWith(&quot;.html&quot;)) return &quot;text/html&quot;;
  else if(filename.endsWith(&quot;.css&quot;)) return &quot;text/css&quot;;
  else if(filename.endsWith(&quot;.js&quot;)) return &quot;application/javascript&quot;;
  else if(filename.endsWith(&quot;.png&quot;)) return &quot;image/png&quot;;
  else if(filename.endsWith(&quot;.gif&quot;)) return &quot;image/gif&quot;;
  else if(filename.endsWith(&quot;.jpg&quot;)) return &quot;image/jpeg&quot;;
  else if(filename.endsWith(&quot;.ico&quot;)) return &quot;image/x-icon&quot;;
  else if(filename.endsWith(&quot;.xml&quot;)) return &quot;text/xml&quot;;
  else if(filename.endsWith(&quot;.pdf&quot;)) return &quot;application/x-pdf&quot;;
  else if(filename.endsWith(&quot;.zip&quot;)) return &quot;application/x-zip&quot;;
  else if(filename.endsWith(&quot;.gz&quot;)) return &quot;application/x-gzip&quot;;
  return &quot;text/plain&quot;;
&#125;
</code></pre>
<h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><pre><code class="c">#include &lt;DNSServer.h&gt;
</code></pre>
<pre><code class="c">const char *ssid = &quot;webcontrol&quot;;             //AP的SSID（WiFi名字）
const char *password = &quot;12345678&quot;;            //AP的密码

const byte DNS_PORT = 53; //DNS服务端口号，一般为53
DNSServer dnsServer;
</code></pre>
<h5 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h5><pre><code class="c">  IPAddress softLocal(192, 168, 3, 6);        //IP地址，用以设置IP第4字段
  IPAddress softGateway(192, 168, 3, 6);      //IP网关，用以设置IP第3字段
  IPAddress softSubnet(255, 255, 255, 0);

  WiFi.mode(WIFI_AP_STA);                 //设置为AP模式(热点)
  WiFi.softAPConfig(softLocal, softGateway, softSubnet);
  WiFi.softAP(ssid, password);

 dnsServer.start(DNS_PORT, &quot;www.me.com&quot;, softLocal);
</code></pre>
<h5 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h5><pre><code class="c">dnsServer.processNextRequest();//处理DNS请求服务
</code></pre>
<h2 id="UDP协"><a href="#UDP协" class="headerlink" title="UDP协"></a>UDP协</h2><pre><code class="c">//UDP定义
IPAddress sta_client;                        //保存sta设备的ip地址
unsigned int localUdp = 1234;     //监听端口
unsigned int remoteUdp = 4321;     //发送端口
unsigned int remoteUdp1 = 4322;     //发送端口
char comPacket[255];                 //数据缓存
WiFiUDP Udp;                        //定义udp
</code></pre>
<h5 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h5><pre><code class="c">void udpBegin() &#123;
  if (Udp.begin(localUdp)) &#123; //启动Udp监听服务
    Serial.println(&quot;监听成功&quot;);
    //打印本地的ip地址，在UDP工具中会使用到
    //WiFi.localIP().toString().c_str()用于将获取的本地IP地址转化为字符串
    Serial.printf(&quot;现在收听IP：%s, UDP端口：%d\n&quot;, WiFi.localIP().toString().c_str(), localUdp);
  &#125; else &#123;
    Serial.println(&quot;监听失败&quot;);
  &#125;
&#125;
</code></pre>
<h5 id="发送接收函数"><a href="#发送接收函数" class="headerlink" title="发送接收函数"></a>发送接收函数</h5><pre><code class="c">//UDP发送函数
void sendBack(const char *buffer, int xx) &#123;
  if (xx == 1) &#123;
    Udp.beginPacket(remoteIp1, remoteUdp);//配置远端ip地址和端口
  &#125; else if (xx == 2) &#123;
    Udp.beginPacket(remoteIp2, remoteUdp);
  &#125;
  //  Udp.write(buffer); //把数据写入发送缓冲区
  Udp.print(buffer);
  Udp.endPacket(); //发送数据
&#125;
void udpDo() &#123;
  //解析Udp数据包
  int packetSize = Udp.parsePacket();//获得解析包
  if (packetSize)//解析包不为空
  &#123;
    //收到Udp数据包
    //Udp.remoteIP().toString().c_str()用于将获取的远端IP地址转化为字符串
    Serial.printf(&quot;收到来自远程IP：%s（远程端口：%d）的数据包字节数：%d\n&quot;, Udp.remoteIP().toString().c_str(), Udp.remotePort(), packetSize);

    // 读取Udp数据包并存放在incomingPacket
    int len = Udp.read(comPacket, 255);//返回数据包字节数
    if (len &gt; 0)
    &#123;
      comPacket[len] = 0;//清空缓存
      Serial.printf(&quot;UDP数据包内容为: %s\n&quot;, comPacket);//向串口打印信息

      //strcmp函数是string compare(字符串比较)的缩写，用于比较两个字符串并根据比较结果返回整数。
      //基本形式为strcmp(str1,str2)，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。
      if (strcmp(comPacket, &quot;LED_OFF&quot;) == 0) // 命令LED_OFF
      &#123;
        //        digitalWrite(LED_BUILTIN, HIGH); // 熄灭LED
        //        sendBack(&quot;LED has been turn off\n&quot;);
      &#125;
      else if (strcmp(comPacket, &quot;LED_ON&quot;) == 0) //如果收到LED_ON
      &#123;
        //        digitalWrite(LED_BUILTIN, LOW); // 点亮LED
        //        sendBack(&quot;LED has been turn on\n&quot;);
      &#125;
      else // 如果指令错误，调用sendCallBack
      &#123;
        //        sendBack(&quot;Command Error!&quot;);
      &#125;
    &#125;
  &#125;
&#125;
</code></pre>
<h2 id="闪存系统操作"><a href="#闪存系统操作" class="headerlink" title="闪存系统操作"></a>闪存系统操作</h2><h5 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h5><pre><code class="c">File dataFile = SPIFFS.open(file_name, &quot;w&quot;);// 建立File对象用于向SPIFFS中的file对象写入信息

  dataFile.println(&quot;Hello IOT World.&quot;);       // 向dataFile写入字符串信息
  dataFile.close();                           // 完成文件写入后关闭文件
  Serial.println(&quot;Finished Writing data to SPIFFS&quot;);
</code></pre>
<h5 id="确认闪存中是否有file-name文件"><a href="#确认闪存中是否有file-name文件" class="headerlink" title="确认闪存中是否有file_name文件"></a>确认闪存中是否有file_name文件</h5><pre><code class="c"> **if** (SPIFFS.exists(file_name))&#123;

  **Serial**.print(file_name);

  **Serial**.println(&quot; FOUND.&quot;);

 &#125; **else** &#123;

  **Serial**.print(file_name);

  **Serial**.print(&quot; NOT FOUND.&quot;);

 &#125;
</code></pre>
<h5 id="建立File对象用于从SPIFFS中读取文件"><a href="#建立File对象用于从SPIFFS中读取文件" class="headerlink" title="建立File对象用于从SPIFFS中读取文件"></a>建立File对象用于从SPIFFS中读取文件</h5><pre><code class="c">File dataFile = SPIFFS.open(file_name, &quot;r&quot;); 
</code></pre>
<h5 id="读取文件内容并且通过串口监视器输出文件信息"><a href="#读取文件内容并且通过串口监视器输出文件信息" class="headerlink" title="读取文件内容并且通过串口监视器输出文件信息"></a>读取文件内容并且通过串口监视器输出文件信息</h5><pre><code class="c"> File dataFile = SPIFFS.open(file_name, &quot;r&quot;); 

**for**(int i=0; i&lt;dataFile.size(); i++)&#123;

  **Serial**.print((char)dataFile.read());    //dataFile.read()将会读取dataFile文件内容

 &#125;
</code></pre>
<h5 id="增加信息"><a href="#增加信息" class="headerlink" title="增加信息"></a>增加信息</h5><pre><code class="c"> File dataFile = SPIFFS.open(file_name, &quot;a&quot;);// 建立File对象用于向SPIFFS中的file对象（即/notes.txt）写入信息
    dataFile.println(&quot;This is Appended Info.&quot;); // 向dataFile添加字符串信息
    dataFile.close();                           // 完成文件操作后关闭文件   
    Serial.println(&quot;Finished Appending data to SPIFFS&quot;);
</code></pre>
<h5 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h5><pre><code>String folder_name = &quot;/taichi-maker&quot;;     //被读取的文件夹
</code></pre>
<pre><code> Dir dir = SPIFFS.openDir(folder_name); // 建立“目录”对象


 **while** (dir.next()) &#123; // dir.next()用于检查目录中是否还有“下一个文件”

  **Serial**.println(dir.fileName()); // 输出文件名

 &#125;
</code></pre>
<h4 id="从闪存中删除file-name文件"><a href="#从闪存中删除file-name文件" class="headerlink" title="从闪存中删除file_name文件"></a>从闪存中删除file_name文件</h4><pre><code class="c">if** (SPIFFS.remove(file_name))&#123;

  **Serial**.print(file_name);

  **Serial**.println(&quot; remove sucess&quot;);

 &#125; **else** &#123;

  **Serial**.print(file_name);

  **Serial**.println(&quot; remove fail&quot;);
 &#125;            
</code></pre>
<h4 id="显示闪存文件系统信息"><a href="#显示闪存文件系统信息" class="headerlink" title="显示闪存文件系统信息"></a>显示闪存文件系统信息</h4><pre><code class="c">FSInfo fs_info;            //建立了FSInfo 对象，用于存储闪存状态信息
 
  // 闪存文件系统信息
  SPIFFS.info(fs_info);
 
  // 可用空间总和（单位：字节）
  Serial.print(&quot;totalBytes: &quot;);     
  Serial.print(fs_info.totalBytes); 
  Serial.println(&quot; Bytes&quot;); 
 
  // 已用空间（单位：字节）
  Serial.print(&quot;usedBytes: &quot;); 
  Serial.print(fs_info.usedBytes);
  Serial.println(&quot; Bytes&quot;); 
 
  // 最大文件名字符限制（含路径和&#39;\0&#39;）
  Serial.print(&quot;maxPathLength: &quot;); 
  Serial.println(fs_info.maxPathLength);
 
  // 最多允许打开文件数量
  Serial.print(&quot;maxOpenFiles: &quot;); 
  Serial.println(fs_info.maxOpenFiles);
 
  // 存储块大小
  Serial.print(&quot;blockSize: &quot;); 
  Serial.println(fs_info.blockSize);
 
  // 存储页大小
  Serial.print(&quot;pageSize: &quot;);
  Serial.println(fs_info.pageSize);
</code></pre>
<h3 id="字符串转-char数组"><a href="#字符串转-char数组" class="headerlink" title="字符串转 char数组"></a>字符串转 char数组</h3><pre><code class="c">const char* aa = str.c_str();
</code></pre>
<h3 id="IP地址转字符串"><a href="#IP地址转字符串" class="headerlink" title="IP地址转字符串"></a>IP地址转字符串</h3><pre><code class="c">String aa = WiFi.localIP().toString().c_str();
</code></pre>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>