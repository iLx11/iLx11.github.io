<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:600px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:600px)" href="/css/style.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <!-- <div class="bgimg"></div> -->
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            算法笔记
        </div>
        <div class="post-meta">
            2022-11-30
        </div>
    
<hr>
    <div class="post-md">
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>左右闭区间</p>
<pre><code class="c++">void main() &#123;
    int a[10]&#123;&#125;;
    search(a, 3)
&#125;
int search(int &amp;a, target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int mid, left = 0, right = length - 1;
    //[left, right] -- [left, right) -&gt; left&lt;right
    while(left &lt;= right) &#123;
        mid = left + ((right - left) &gt;&gt; 1);
        if(a[mid] &gt; target) &#123;
            //闭区间
            right = mid - 1;
        &#125;else if(a[mid] &lt; target) &#123;
            //闭区间
            left = mid + 1;
        &#125;else if(a[mid] == target) &#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><pre><code class="c++">int main() &#123;
    int a[10]&#123;&#125;;
    remove(a, 3);
&#125;
int remove(int&amp; a, target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    for(int i = 0; i &lt; length; i++) &#123;
        if(a[i] == target) &#123;
            for(int j = i + 1; j &lt; length; j++) &#123;
                a[j - 1] = a[j];
            &#125;
            i--;
            length--;
        &#125;
    &#125;
    return length;
&#125;
</code></pre>
<h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h5><pre><code class="c++">int remove(int&amp; a, int target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int slow = 0;
    for(int fast = 0; fast &lt; length; fast ++) &#123;
        if(a[fast] != target) &#123;
            a[slow] = a[fast];
            slow ++;
        &#125;
    &#125;
    return slow;
&#125;
</code></pre>
<h5 id="双向指针法"><a href="#双向指针法" class="headerlink" title="双向指针法"></a>双向指针法</h5><pre><code class="c++">int remove(int&amp; a, int target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int left = 0;
    int right = length - 1;
    while(left &lt;= right) &#123;
        if(a[left] == target) &#123;
            a[left] == a[right];
            right --;
        &#125;
        left ++;
        while(left &lt;= right &amp;&amp; a[rigth] == target) &#123;
            right --;
        &#125;
    &#125;
    return left;
&#125;
</code></pre>
<h5 id="有序数组平方"><a href="#有序数组平方" class="headerlink" title="有序数组平方"></a>有序数组平方</h5><p>将数组内元素平方之后进行排序</p>
<pre><code class="c++">int* dou(int&amp; a) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int left = 0, right = length - 1, k = length;
    int newArr[length]&#123;&#125;;
    for(int i = 0; i &lt; length; i ++) &#123;
        if(a[left] * a[left] &lt; a[right] * a[right]) &#123;
            newArr[k --] =  a[right] * a[right];
            right --;
        &#125;else &#123;
            newArr[k --] =  a[left] * a[left];
            left --;
        &#125;
        a = newArr;
        return a;
    &#125;
&#125;
</code></pre>
<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><h5 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h5><pre><code class="c++">int minSubArrayLen(int s, int&amp; a) &#123;
    int len = sizeof(a) / sizeof(a[0]);
    int result&#123;INT32_MAX&#125;;
    int sum&#123;0&#125;, subLength&#123;0&#125;;
    for(int i = 0; i &lt; len; i ++) &#123;
        sum = 0; 
        for(int j = i; j &lt; len; j ++) &#123;
            sum += a[j];
            if(sum &gt;= s) &#123;
                subLength = j - i + 1;
                result = result &lt; subLength ? result : subLength;
                break; //执行完退出
            &#125;
        &#125;
    &#125;
    return result == IN32_MAX ? 0 : result; 
&#125;
</code></pre>
<h5 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h5><pre><code class="c++">int minSubArrayLen(int s, int&amp; a) &#123;
    int result = IN32_MAX;
    int len = sizeof(a) / sizeof(a[0]);
    int i&#123;0&#125;, subLength&#123;0&#125;, sum&#123;0&#125;;
    for(int j = 0; j &lt; len; j ++) &#123;
        sum += a[j];
        while(sum &gt;= s) &#123;
            subLength = j - i + 1;
            result = result &lt; subLength ? result : subLength;
            sum -= a[i];
            i ++;
        &#125;
    &#125;
    return result == IN32_MAX ? 0 : result;
&#125;
</code></pre>
<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><pre><code class="c++">void generateMatrix(int n, int *array) &#123;
    int loop &#123;0&#125;;
    int startx &#123;0&#125;;
    int starty &#123;0&#125;;
    int mid &#123;n / 2&#125;;
    int offset &#123;1&#125;;
    int count &#123;1&#125;;
    while(loop ++ &lt; n / 2) &#123;
        i = startx;
        j = starty;
        
        //从左往右
        for(int i = startx; i &lt; n - offset; i ++) &#123;
            array[startx][i] = count ++;
        &#125;
        //从上往下
        for(int j = starty; j &lt; n - offset; j ++) &#123;
            array[i][j] = count ++;
        &#125;
        //从右往左
        for(; i &gt; startx; i --) &#123;
            array[i][j] = count ++;
        &#125;
           //从下往上
        for(; j &gt; starty; j --) &#123;
            array[i][j] = count ++;
        &#125;
        startx ++;
        starty ++;
        //收缩1
        offset ++;
    &#125;
    if(n % 2) &#123;
        array[mid][mid] = count;
    &#125;
&#125;
int main() &#123;
    int *a&#123;new int[5][5]&#125;;
    geerateMatrix(5);
&#125; 
</code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表定义</p>
<pre><code class="C++">struct ListNode &#123;
    int val;
    ListNode* next;
    //构造函数初始化
    ListNode(int x) : val(x), next(NULL) &#123;&#125;;
&#125;
</code></pre>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h5 id="处理头节点"><a href="#处理头节点" class="headerlink" title="处理头节点"></a>处理头节点</h5><pre><code class="c++">ListNode* delNode(ListNode* head, int val) &#123;
    //删除头节点
    while(head != NULL &amp;&amp; head-&gt;val == val) &#123;
        ListNode* temp = head;
        head = head-&gt;next;
        delete temp;
    &#125;
    //删除相同元素
    ListNode* cur = head;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delete temp;
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    return head;
&#125;
</code></pre>
<h5 id="设置虚拟头节点"><a href="#设置虚拟头节点" class="headerlink" title="设置虚拟头节点"></a>设置虚拟头节点</h5><pre><code class="c++">ListNode* delNode(ListNode* head, int val) &#123;
    //设置虚拟头节点
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* cur = vhead;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delet tempo;
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
     head = vhead-&gt;next;
     delete vhead;
     return head;
&#125;
</code></pre>
<h5 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h5><pre><code class="C++">struct ListNode* delNode(struct ListNode* head, int val) &#123;
    while(head != NULL &amp;&amp; head-&gt;val == val) &#123;
        struct ListNode* temp = head;
        head = head-&gt;next;
        free(temp);
    &#125;
    struct ListNode* cur = head;
       while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            struct ListNode* temp = cur-&gt;next;
            cur-next = cur-&gt;next-&gt;next;
            free(temp);
        &#125;
    &#125;
    return head;
&#125; 

//虚拟头节点方法
struct ListNode* delNode(struct ListNode* head, int val() &#123;
    typedef struct ListNode ListNode;
    ListNode *vhead = (ListNode *) malloc(sizeof(ListNode));
    vhead-&gt;next = head;
    ListNode *cur = vhead;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode *temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            free(temp);
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    head = vhead-&gt;next;
    free(vhead);
    return head;
&#125;
</code></pre>
<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><blockquote>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
</blockquote>
<pre><code class="c++">class LinkedList &#123;
    private:
        int _size;
        ListNode* _vhead;
    public:
        struct ListNode &#123;
            int val;
            ListNode* next;
            ListNode(int val): val(val), next(nullptr)&#123;&#125;
        &#125;;
        //构造函数
        LinkedList() &#123;
               _vhead = new ListNode(0);
            _size = 0;
        &#125;
        //获取index数值
        int getVal(int index) &#123;
            if(index &lt; 0 || index &gt; _size - 1) &#123;
                return -1;
            &#125;
            //后移节点确保最后cur为index
            ListNode* cur = _vhead-&gt;next;
            while(index--) &#123;
                   cur = cur-&gt;next;
            &#125;
            return cur-&gt;val;
        &#125;
        //头部添加节点
        void popNode(int val) &#123;
            ListNode* newNode = new ListNode(val);
            newNode-&gt;next = _vhead-&gt;next;
            -vhead-&gt;next = newNode;
            _size ++;
        &#125;
        //尾部添加节点
        void pushNode(int val) &#123;
            ListNode* newNode = new ListNode(val);
            ListNode* cur = _vhead;
            while(cur-&gt;next != NULL) &#123;
                cur = cur-&gt;next;
            &#125;
            cur-&gt;next = newNode;
            _size ++;
        &#125;
        //删除 index 节点
        void delIndexNode(int index) &#123;
               ListNode* cur = _vhead;
            while(index --) &#123;
                cur = cur-&gt;next;
            &#125;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
               delete temp;
            _size --;
        &#125;
        //添加 index 节点
        void addIndexNode(int index) &#123;
            ListNode* newNode = new ListNode(val);
            ListNode* cur = _vhead;
            while(index --) &#123;
                cur = cur-&gt;next;
            &#125;
            newNode-&gt;next = cur-&gt;next;
            cur-next = newNode;
            _size ++;
        &#125;
        //遍历链表
        void showLinked() &#123;
            ListNode* cur = _vhead;
               while(cur-&gt;next != NULL) &#123;
                cout &lt;&lt;&quot;val == &quot; &lt;&lt; cur-&gt;next-&gt;val;
                cur = cur-&gt;next;
            &#125;
            cout &lt;&lt; endl;
        &#125;
&#125;
</code></pre>
<h5 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">typedef struct &#123;
    int val;
    struct ListNode* next;
&#125;ListNode;
</code></pre>
<h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><h5 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h5><pre><code class="c++">ListNode* reverseList(ListNode* head) &#123;
    ListNode* pre = NULL;
    ListNode* cur = head;
    ListNode* temp = NULL;
    while(cur != NULL) &#123;
        temp = cur-&gt;next;
        cur-&gt;next = pre;
        pre = cur;
        cur = temp;
    &#125;
    return pre;
&#125;
</code></pre>
<h3 id="两两交换链表的节点"><a href="#两两交换链表的节点" class="headerlink" title="两两交换链表的节点"></a>两两交换链表的节点</h3><pre><code class="c++">ListNode* changeDouble(ListNode* head) &#123;
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* cur = vhead;
    while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;
           ListNode* temp1 = cur-&gt;next;
        ListNode* temp2 = cur-&gt;next-&gt;next;
        //开始交换
        cur-&gt;next = temp2;
        cur-&gt;next-&gt;next = temp1;
        cur-&gt;next-&gt;next-&gt;next = temp2-&gt;next;
        //向后移动两位
        cur = cur-&gt;next-&gt;next;
    &#125;
       return vhead-&gt;next;
&#125;
</code></pre>
<h3 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h3><pre><code class="c++">ListNode* delReverseN(ListNode* head, int N) &#123;
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* slowp = vhead;
    ListNode* fastp = vhead;
    while(n-- &amp;&amp; fastp-&gt;next) &#123;
        fastp = fastp-&gt;next;
    &#125;
    fastp = fastp-&gt;next;
    while(fastp) &#123;
        fastp = fastp-&gt;next;
        slowp = slowp-next;
    &#125;
    //删除节点，释放内存
    ListNode* temp = slowp-&gt;next;
    slowp-&gt;next = slow-&gt;next-next;
    delete temp;
    retrun vhead-&gt;next;
&#125; 
</code></pre>
<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><pre><code class="c++">ListNode* sameLinked(ListNode* linA, ListNode* linB) &#123;
    ListNode* lA = linA;
    ListNode* lB = linB;
    int alen&#123;0&#125;, blen&#123;0&#125;;
    //计算链表长度
    while(lA != NULL) &#123;
        lA = lA-&gt;next;
        alen ++;
    &#125;
    while(lB != NULL) &#123;
        lB = lB-&gt;next;
        blen ++;
    &#125;
    //使 A， B指向头部
    lA = linA;
    lB = linB;
    //保持A指向较长的链表
    if(blen &gt; alen) &#123;
        //交换值
        swap(blen, alen);
        swap(lB, lA);
    &#125;
    while(alen --) &#123;
        lA = lA-&gt;next;
    &#125;
    //寻找相交
    while(lA != NULL) &#123;
        if(lA == lB) &#123;
            return lA;
        &#125;
        lA = lA-&gt;next;
        lB = lB-&gt;next;
    &#125;
    retrun NULL;
&#125;
</code></pre>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>