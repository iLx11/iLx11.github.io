<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:600px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:600px)" href="/css/style.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <!-- <div class="bgimg"></div> -->
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            算法笔记
        </div>
        <div class="post-meta">
            2022-11-30
        </div>
    
<hr>
    <div class="post-md">
        <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>左右闭区间</p>
<pre><code class="c++">void main() &#123;
    int a[10]&#123;&#125;;
    search(a, 3)
&#125;
int search(int &amp;a, target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int mid, left = 0, right = length - 1;
    //[left, right] -- [left, right) -&gt; left&lt;right
    while(left &lt;= right) &#123;
        mid = left + ((right - left) &gt;&gt; 1);
        if(a[mid] &gt; target) &#123;
            //闭区间
            right = mid - 1;
        &#125;else if(a[mid] &lt; target) &#123;
            //闭区间
            left = mid + 1;
        &#125;else if(a[mid] == target) &#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><pre><code class="c++">int main() &#123;
    int a[10]&#123;&#125;;
    remove(a, 3);
&#125;
int remove(int&amp; a, target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    for(int i = 0; i &lt; length; i++) &#123;
        if(a[i] == target) &#123;
            for(int j = i + 1; j &lt; length; j++) &#123;
                a[j - 1] = a[j];
            &#125;
            i--;
            length--;
        &#125;
    &#125;
    return length;
&#125;
</code></pre>
<h5 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h5><pre><code class="c++">int remove(int&amp; a, int target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int slow = 0;
    for(int fast = 0; fast &lt; length; fast ++) &#123;
        if(a[fast] != target) &#123;
            a[slow] = a[fast];
            slow ++;
        &#125;
    &#125;
    return slow;
&#125;
</code></pre>
<h5 id="双向指针法"><a href="#双向指针法" class="headerlink" title="双向指针法"></a>双向指针法</h5><pre><code class="c++">int remove(int&amp; a, int target) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int left = 0;
    int right = length - 1;
    while(left &lt;= right) &#123;
        if(a[left] == target) &#123;
            a[left] == a[right];
            right --;
        &#125;
        left ++;
        while(left &lt;= right &amp;&amp; a[rigth] == target) &#123;
            right --;
        &#125;
    &#125;
    return left;
&#125;
</code></pre>
<h5 id="有序数组平方"><a href="#有序数组平方" class="headerlink" title="有序数组平方"></a>有序数组平方</h5><p>将数组内元素平方之后进行排序</p>
<pre><code class="c++">int* dou(int&amp; a) &#123;
    int length = sizeof(a) / sizeof(a[0]);
    int left = 0, right = length - 1, k = length;
    int newArr[length]&#123;&#125;;
    for(int i = 0; i &lt; length; i ++) &#123;
        if(a[left] * a[left] &lt; a[right] * a[right]) &#123;
            newArr[k --] =  a[right] * a[right];
            right --;
        &#125;else &#123;
            newArr[k --] =  a[left] * a[left];
            left --;
        &#125;
        a = newArr;
        return a;
    &#125;
&#125;
</code></pre>
<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><h5 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h5><pre><code class="c++">int minSubArrayLen(int s, int&amp; a) &#123;
    int len = sizeof(a) / sizeof(a[0]);
    int result&#123;INT32_MAX&#125;;
    int sum&#123;0&#125;, subLength&#123;0&#125;;
    for(int i = 0; i &lt; len; i ++) &#123;
        sum = 0; 
        for(int j = i; j &lt; len; j ++) &#123;
            sum += a[j];
            if(sum &gt;= s) &#123;
                subLength = j - i + 1;
                result = result &lt; subLength ? result : subLength;
                break; //执行完退出
            &#125;
        &#125;
    &#125;
    return result == IN32_MAX ? 0 : result; 
&#125;
</code></pre>
<h5 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h5><pre><code class="c++">int minSubArrayLen(int s, int&amp; a) &#123;
    int result = IN32_MAX;
    int len = sizeof(a) / sizeof(a[0]);
    int i&#123;0&#125;, subLength&#123;0&#125;, sum&#123;0&#125;;
    for(int j = 0; j &lt; len; j ++) &#123;
        sum += a[j];
        while(sum &gt;= s) &#123;
            subLength = j - i + 1;
            result = result &lt; subLength ? result : subLength;
            sum -= a[i];
            i ++;
        &#125;
    &#125;
    return result == IN32_MAX ? 0 : result;
&#125;
</code></pre>
<h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><pre><code class="c++">void generateMatrix(int n, int *array) &#123;
    int loop &#123;0&#125;;
    int startx &#123;0&#125;;
    int starty &#123;0&#125;;
    int mid &#123;n / 2&#125;;
    int offset &#123;1&#125;;
    int count &#123;1&#125;;
    while(loop ++ &lt; n / 2) &#123;
        i = startx;
        j = starty;
        
        //从左往右
        for(int i = startx; i &lt; n - offset; i ++) &#123;
            array[startx][i] = count ++;
        &#125;
        //从上往下
        for(int j = starty; j &lt; n - offset; j ++) &#123;
            array[i][j] = count ++;
        &#125;
        //从右往左
        for(; i &gt; startx; i --) &#123;
            array[i][j] = count ++;
        &#125;
           //从下往上
        for(; j &gt; starty; j --) &#123;
            array[i][j] = count ++;
        &#125;
        startx ++;
        starty ++;
        //收缩1
        offset ++;
    &#125;
    if(n % 2) &#123;
        array[mid][mid] = count;
    &#125;
&#125;
int main() &#123;
    int *a&#123;new int[5][5]&#125;;
    geerateMatrix(5);
&#125; 
</code></pre>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表定义</p>
<pre><code class="C++">struct ListNode &#123;
    int val;
    ListNode* next;
    //构造函数初始化
    ListNode(int x) : val(x), next(NULL) &#123;&#125;;
&#125;
</code></pre>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h5 id="处理头节点"><a href="#处理头节点" class="headerlink" title="处理头节点"></a>处理头节点</h5><pre><code class="c++">ListNode* delNode(ListNode* head, int val) &#123;
    //删除头节点
    while(head != NULL &amp;&amp; head-&gt;val == val) &#123;
        ListNode* temp = head;
        head = head-&gt;next;
        delete temp;
    &#125;
    //删除相同元素
    ListNode* cur = head;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delete temp;
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    return head;
&#125;
</code></pre>
<h5 id="设置虚拟头节点"><a href="#设置虚拟头节点" class="headerlink" title="设置虚拟头节点"></a>设置虚拟头节点</h5><pre><code class="c++">ListNode* delNode(ListNode* head, int val) &#123;
    //设置虚拟头节点
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* cur = vhead;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delet tempo;
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
     head = vhead-&gt;next;
     delete vhead;
     return head;
&#125;
</code></pre>
<h5 id="C语言版本"><a href="#C语言版本" class="headerlink" title="C语言版本"></a>C语言版本</h5><pre><code class="C++">struct ListNode* delNode(struct ListNode* head, int val) &#123;
    while(head != NULL &amp;&amp; head-&gt;val == val) &#123;
        struct ListNode* temp = head;
        head = head-&gt;next;
        free(temp);
    &#125;
    struct ListNode* cur = head;
       while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            struct ListNode* temp = cur-&gt;next;
            cur-next = cur-&gt;next-&gt;next;
            free(temp);
        &#125;
    &#125;
    return head;
&#125; 

//虚拟头节点方法
struct ListNode* delNode(struct ListNode* head, int val() &#123;
    typedef struct ListNode ListNode;
    ListNode *vhead = (ListNode *) malloc(sizeof(ListNode));
    vhead-&gt;next = head;
    ListNode *cur = vhead;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode *temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            free(temp);
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    head = vhead-&gt;next;
    free(vhead);
    return head;
&#125;
</code></pre>
<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><blockquote>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
</blockquote>
<pre><code class="c++">class LinkedList &#123;
    private:
        int _size;
        ListNode* _vhead;
    public:
        struct ListNode &#123;
            int val;
            ListNode* next;
            ListNode(int val): val(val), next(nullptr)&#123;&#125;
        &#125;;
        //构造函数
        LinkedList() &#123;
               _vhead = new ListNode(0);
            _size = 0;
        &#125;
        //获取index数值
        int getVal(int index) &#123;
            if(index &lt; 0 || index &gt; _size - 1) &#123;
                return -1;
            &#125;
            //后移节点确保最后cur为index
            ListNode* cur = _vhead-&gt;next;
            while(index--) &#123;
                   cur = cur-&gt;next;
            &#125;
            return cur-&gt;val;
        &#125;
        //头部添加节点
        void popNode(int val) &#123;
            ListNode* newNode = new ListNode(val);
            newNode-&gt;next = _vhead-&gt;next;
            -vhead-&gt;next = newNode;
            _size ++;
        &#125;
        //尾部添加节点
        void pushNode(int val) &#123;
            ListNode* newNode = new ListNode(val);
            ListNode* cur = _vhead;
            while(cur-&gt;next != NULL) &#123;
                cur = cur-&gt;next;
            &#125;
            cur-&gt;next = newNode;
            _size ++;
        &#125;
        //删除 index 节点
        void delIndexNode(int index) &#123;
               ListNode* cur = _vhead;
            while(index --) &#123;
                cur = cur-&gt;next;
            &#125;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
               delete temp;
            _size --;
        &#125;
        //添加 index 节点
        void addIndexNode(int index) &#123;
            ListNode* newNode = new ListNode(val);
            ListNode* cur = _vhead;
            while(index --) &#123;
                cur = cur-&gt;next;
            &#125;
            newNode-&gt;next = cur-&gt;next;
            cur-next = newNode;
            _size ++;
        &#125;
        //遍历链表
        void showLinked() &#123;
            ListNode* cur = _vhead;
               while(cur-&gt;next != NULL) &#123;
                cout &lt;&lt;&quot;val == &quot; &lt;&lt; cur-&gt;next-&gt;val;
                cur = cur-&gt;next;
            &#125;
            cout &lt;&lt; endl;
        &#125;
&#125;
</code></pre>
<h5 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">typedef struct &#123;
    int val;
    struct ListNode* next;
&#125;ListNode;
</code></pre>
<h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><h5 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h5><pre><code class="c++">ListNode* reverseList(ListNode* head) &#123;
    ListNode* pre = NULL;
    ListNode* cur = head;
    ListNode* temp = NULL;
    while(cur != NULL) &#123;
        temp = cur-&gt;next;
        cur-&gt;next = pre;
        pre = cur;
        cur = temp;
    &#125;
    return pre;
&#125;
</code></pre>
<h3 id="两两交换链表的节点"><a href="#两两交换链表的节点" class="headerlink" title="两两交换链表的节点"></a>两两交换链表的节点</h3><pre><code class="c++">ListNode* changeDouble(ListNode* head) &#123;
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* cur = vhead;
    while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;
           ListNode* temp1 = cur-&gt;next;
        ListNode* temp2 = cur-&gt;next-&gt;next;
        //开始交换
        cur-&gt;next = temp2;
        cur-&gt;next-&gt;next = temp1;
        cur-&gt;next-&gt;next-&gt;next = temp2-&gt;next;
        //向后移动两位
        cur = cur-&gt;next-&gt;next;
    &#125;
       return vhead-&gt;next;
&#125;
</code></pre>
<h3 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h3><pre><code class="c++">ListNode* delReverseN(ListNode* head, int N) &#123;
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* slowp = vhead;
    ListNode* fastp = vhead;
    while(n-- &amp;&amp; fastp-&gt;next) &#123;
        fastp = fastp-&gt;next;
    &#125;
    fastp = fastp-&gt;next;
    while(fastp) &#123;
        fastp = fastp-&gt;next;
        slowp = slowp-next;
    &#125;
    //删除节点，释放内存
    ListNode* temp = slowp-&gt;next;
    slowp-&gt;next = slow-&gt;next-&gt;next;
    delete temp;
    retrun vhead-&gt;next;
&#125; 
</code></pre>
<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><pre><code class="c++">ListNode* sameLinked(ListNode* linA, ListNode* linB) &#123;
    ListNode* lA = linA;
    ListNode* lB = linB;
    int alen&#123;0&#125;, blen&#123;0&#125;;
    //计算链表长度
    while(lA != NULL) &#123;
        lA = lA-&gt;next;
        alen ++;
    &#125;
    while(lB != NULL) &#123;
        lB = lB-&gt;next;
        blen ++;
    &#125;
    //使 A， B指向头部
    lA = linA;
    lB = linB;
    //保持A指向较长的链表
    if(blen &gt; alen) &#123;
        //交换值
        swap(blen, alen);
        swap(lB, lA);
    &#125;
    int comp = alen - blen;
    while(comp --) &#123;
        lA = lA-&gt;next;
    &#125;
    //寻找相交
    while(lA != NULL) &#123;
        if(lA == lB) &#123;
            return lA;
        &#125;
        lA = lA-&gt;next;
        lB = lB-&gt;next;
    &#125;
    retrun NULL;
&#125;
</code></pre>
<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>(x + y) * 2 = x + y + n (y + z)</p>
<p>x = (n - 1) (y + z) + z</p>
<p>当 n = 0 时</p>
<p>x = z</p>
<pre><code class="c++">ListNode* findSycle (ListNode* head) &#123;
    ListNode* slow = head;
    ListNode* fast = head;
    while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        //判断是否相遇
        while(slow == fast) &#123;
            ListNode* index1 = fast;
            ListNode* index2 = head;
            //寻找环的入口节点， 相遇点开始各移一个，之后相交则为入口节点
            while(index1 != index2) &#123;
                   index1 = index1-&gt;next;
                index2 = index2-&gt;next;
            &#125;
            return index2;
        &#125;
        retrun NULL;
    &#125;
&#125;
</code></pre>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>C++ 给提供了如下三种可用的数据结构：</p>
<ul>
<li>std::set</li>
<li>std::multiset</li>
<li>std::unordered_set</li>
</ul>
<h3 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h3><p>“eat -&gt; “ate”</p>
<pre><code class="c++">bool wordDiff(String s, String t) &#123;
    int word[26] = &#123;0&#125;;
    for(int i = 0; i &lt; s.sise(); i ++) &#123;
        word[s[i] - &#39;a&#39;] ++;
    &#125;
    for(int i = 0; i &lt; t.sizs(); i ++) &#123;
        word[t[i] - &#39;a&#39;] --;
    &#125;
       for(int i = 0; i &lt; 26; i ++) &#123;
        if(word[i] != 0) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h3 id="两个数组交集"><a href="#两个数组交集" class="headerlink" title="两个数组交集"></a>两个数组交集</h3><p>有范围限制时</p>
<pre><code class="c++">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; shu1, vector&lt;int&gt;&amp; shu2) &#123;
    unorded_set&lt;int&gt; reult_set;
    int hash[1005] = &#123;0&#125;;
    for(int num : shu1) &#123;
        hash[num] = 1;
    &#125;
    for(int num : shu2) &#123;
        if(hash[num] == 1) &#123;
            result_set.insert(num);
        &#125; 
    &#125;
    return vector&lt;int&gt; (result_set.begin(), result_set.end());
&#125;
int main() &#123;
       vector&lt;int&gt; shu1 = &#123;&#125;;
    intersection(shu1);
&#125;
</code></pre>
<h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><pre><code class="c++">int getSum(int n) &#123;
    int sum &#123;0&#125;;
    while(n) &#123;
        sum += (n % 10) * (n % 10);
        n = n / 10;
    &#125;
    return sum;
&#125;
bool isHappy(int n) &#123;
   int sum = 0;
   unordered_set&lt;int&gt; = set;
    while(1) &#123;
        sum = getSum(n);
        if (sum == 1) &#123;
            return true;
        &#125;
        // 查找存储在 set 内的值，若找到怎说明陷入了循环
           if (set.find(sum) != set.end()) &#123;
            retrun false;
        &#125;else &#123;
            set.insert(sum);
        &#125;
        n = sum;
    &#125;
&#125;
</code></pre>
<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p><strong>示例:</strong></p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
<pre><code class="c++">vector&lt;int&gt; doubleSum(vector&lt;int&gt;&amp; num, int target) &#123;
    unordered_map&lt;int, int&gt; map;
    for(int i = 0; i &lt; num.size(), i ++) &#123;
        auto shu = map.find(target - num[i]);
        if(shu != map.end()) &#123;
            //在map内找到直接返回两个数
            //shu-&gt;second 返回值; -&gt;first 返回键
            return &#123;shu-&gt;second, i&#125;;
        &#125;
        //未找到则添加
        map.insert(pair&lt;int, int&gt; (num[i], i))
    &#125;
&#125;
</code></pre>
<h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p>输入:</p>
<ul>
<li>A = [ 1, 2]</li>
<li>B = [-2,-1]</li>
<li>C = [-1, 2]</li>
<li>D = [ 0, 2]</li>
</ul>
<p>输出:</p>
<p>2</p>
<p><strong>解释:</strong></p>
<p>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li>
</ol>
<pre><code class="c++">int fourSum(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;
    unordered_map&lt;int, int&gt; umap;
    int count;
    for(int a : A) &#123;
           for(int b : B) &#123;
            //键为 a + b 值为 1
            //umap.insert(pair&lt;int , int&gt; ((a + b), 1);
            umap[a + b] ++;
        &#125;
    &#125;
    for(int c : C) &#123;
        for(int d : D) &#123;
            int temp = c + d;
            if(map.find(0 - temp) != umap.end()) &#123;
                count += umap[0 - temp];
            &#125;
        &#125;
    &#125;
    return count;
&#125;
</code></pre>
<h3 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h3><pre><code class="c++">bool mes(string ransomNote, string magazine) &#123;
    int word[26] &#123;0&#125;;
    if(ransomNote.size() &gt; magazine.size()) &#123;
        return false;
    &#125;
    for(int i = 0; i &lt; ransomNote.length(); i ++) &#123;
        word[ransomNote[i] - &#39;a&#39;] ++;
    &#125;
    for(int i = 0; i &lt; magazine.length(); i ++) &#123;
        word[magazine[i] - &#39;a&#39;]--;
        //判断方式一
        if(word[magazine[i] - &#39;a&#39;] &lt; 0) &#123;
            return false;
        &#125;
    &#125;
    //判断方式二
    for(int i = 0; i &lt; 26; i ++) &#123;
        if(word[i] == 1) &#123;
            return false;
        &#125;
    &#125;
    
    return true;
&#125;
</code></pre>
<h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h4 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h4><pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; num) &#123;
   vector&lt;vector&lt;int&gt;&gt; result;    
    //排序    
    sort(num.begin(), num.end());
    for(int i = 0; i &lt; num.size(); i ++) &#123;
        if(num[i] &gt; 0) &#123;
            continue;
        &#125;
        //去重,保证3个数不与之前的重复
        if(i &gt; 0 &amp;&amp; num[i] == num[i - 1]) &#123;
            continue;
        &#125;
        unordered_set&lt;int&gt; set;
        for(int j = 0; j &lt; num.size(); j ++) &#123;
            if(j &gt; i + 2 &amp;&amp; num[i] == num[j - 1] &amp;&amp;
                  num[j - 1] == num[j - 2]) &#123;
                continue;
            &#125;
            int c = 0 - (num[i] + num[j]);
               if(set.find(c) != set.end()) &#123;
                result.push_back(&#123;num[i], num[j], c&#125;);
                set.erase(c);
            &#125;else &#123;
                set.insert(num[j]);
            &#125;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h4 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h4><pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; num) &#123;
    //排序
    sort(num.begin(), num.end());
    vector&lt;vector&lt;int&gt;&gt; result;
    for(int i = 0; i &lt; num.sizes(); i ++) &#123;
        if(num[i] &gt; 0) &#123;
            continue;
        &#125;
        //去重
        if(i &gt; 0 &amp;&amp; num[i] &lt; num[i - 1]) &#123;
            continue;
        &#125;
        int left = i + 1;
        int right = num.size() - 1;
           while(left &lt; right) &#123;
            if((num[left] + num[i] + num[right]) &gt; 0) &#123;
                right --;
            &#125;else if((num[left] + num[i] + num[right]) &lt; 0) &#123;
                left ++;
            &#125;else &#123;
                result.push_back(&#123;num[left], num[i], num[right]&#125;);
                //去重
                while(left &lt; right &amp;&amp; num[left] == num[left + 1])
                    left ++;
                while(left &lt; right &amp;&amp; num[right] == num[right - 1])
                    right --;
                //同时向内缩进
                left ++;
                right --;
            &#125;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h3 id="四数之和-1"><a href="#四数之和-1" class="headerlink" title="四数之和"></a>四数之和</h3><p>双指针法</p>
<pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; num, int target) &#123;
    //排序
    sort(num.begin(), num.end());
       vector&lt;vector&lt;int&gt;&gt; result;
    for(int i = 0; i &lt; num.size(); i ++) &#123;
        //剪枝
        if(num[i] &gt; target &amp;&amp; num[i] &gt;= 0) &#123;
               break;
        &#125;
        //去重
        if(i &gt; 0 &amp;&amp; num[i] == num[i - 1]) &#123;
            continue;
        &#125;
        for(int j = 0; j &lt; num.size(); j ++) &#123;
            //2次剪枝
            if(num[i] + num[j] &gt; target &amp;&amp; num[i] + num[j] &gt;= 0) &#123;
                break;
            &#125;
            //去重
            if(j &gt; i + 1 &amp;&amp; num[j] == num[j - 1]) &#123;
                continue;
            &#125; 
               int left = j + 1;
            int right = num.size() - 1;
            while(left &lt; right) &#123;
                //相加会超限，使用转换
                if((long) num[i] + num[j] + num[left] + num[right] &gt; target) &#123;
                    right --;
                &#125; else if((long) num[i]  + num[j] + num[left] + num[right] &lt; target) &#123;
                    left ++;
                &#125; else &#123;
                    result.push_back(vector&lt;int&gt; &#123;num[i], num[j], num[left], num[right]&#125;);
                    //去重
                    while(left &lt; right &amp;&amp; num[left] == num[left + 1])
                           left ++;
                    while(left &lt; right &amp;&amp; num[right] == num[right - 1])
                        right --;
                    
                    right --;
                       left ++;
                &#125;
            &#125;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><pre><code class="c++">void reverse(vector&lt;char&gt;&amp; charN) &#123;
    for(int i = 0, int j = charN.size() - 1; i &lt; charN.size() / 2; i ++, j --) &#123;
        int temp = charN[i];
        charN[i] = charN[j];
        charN[j] = temp;
        /*
            位运算,异或
            charN[i] ^= charN[j];
            charN[j] ^= charN[i];
            charN[i] ^= charN[j];
        */
    &#125;
&#125;
</code></pre>
<h3 id="反转字符串-1"><a href="#反转字符串-1" class="headerlink" title="反转字符串"></a>反转字符串</h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p>
<pre><code class="c++">void reverse(string&amp; s, int start, int end) &#123;
    for(int i = start, j = end; i &lt; s.size() / 2; i ++, j --) &#123;
        int temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    &#125;
&#125; 
string reverseString(string s, int k) &#123;
    for(int i = 0; i &lt; s.size; i += (2 * k)) &#123;
        //判断尾部的字符串是否大于K, 大于则相加后小于size
        if(i + k &lt;= s.size()) &#123;
            reverse(s, i, i + k);
            continue;
        &#125;
        //尾部字符串小于K， 相加后大于size
        reverse(s, i, size() - 1);
    &#125;
&#125;
</code></pre>
<h4 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h4><h5 id="C语言版"><a href="#C语言版" class="headerlink" title="C语言版"></a>C语言版</h5><pre><code class="c">char* reverse(char* s, int k) &#123;
    int len = strlen(s);
    for(int i = 0; i &lt; len; i += (2 * K)) &#123;
        int left = i;
        int right = i + k - 1;
        while(left &lt; right) &#123;
            int temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left ++;
            right --;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<pre><code class="c++">string replaceSpace(string s) &#123;
    int oldSize = s.size();
    int count&#123;0&#125;;
    //计算空格数量
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] == &#39; &#39;) &#123;
            count ++;
        &#125;
    &#125;
    //重新分配内存
    s.resize(malloc(oldSize + (count * 2)));
    int newSize = s.size();
    for(int i = oledSize - 1, j = newSize - 1; i &lt; j; i --, j --) &#123;
        if(s[i] == &#39; &#39;) &#123;
            s[j] = &#39;%&#39;;
            s[j - 1] = &#39;2&#39;;
            s[j - 2] = &#39;0&#39;;
            //跳过填充
            j -= 2;
        &#125;else &#123;
            s[j] = s[i];
        &#125;
    &#125;
    return s;
&#125;
</code></pre>
<h4 id="C语言-1"><a href="#C语言-1" class="headerlink" title="C语言"></a>C语言</h4><pre><code class="c">char* replaceSpace(char* s) &#123;
    int oldSize = strlen(s);
    int count = 0;
    for(int i = 0; i &lt; oldeSize; i ++) &#123;
        if(s[i] == &#39; &#39;) &#123;
            count ++;
        &#125;
    &#125;
    int newSize = oldSize + 2 * count;
    char* news = (char *) malloc(sizeof(char) * (oldSize + 2 * count) + 1);
    for(int i = oldSize - 1, int j = newSize - 1; i &lt; j; i --, j --) &#123;
        if(s[i] == &#39; &#39;) &#123;
            news[j] = &#39;%&#39;;
            news[j - 1] = &#39;2&#39;;
            news[j - 2] = &#39;0&#39;;
            j -= 2;
        &#125;else &#123;
            news[j] = s[i];
        &#125;
    &#125;
    news[newSize] = &#39;\0&#39;;
    return news;
&#125;
</code></pre>
<h3 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>思路: 去除多余空格 -&gt; 翻转字符串 -&gt; 翻转单词</p>
<pre><code class="c++">//反转字符
void reverse(string&amp; s, int start, int end) &#123;
    for(int i = start, j = end; i &lt; j; i ++, j --) &#123;
        s[i] ^= s[j];
        s[j] ^= s[i];
        s[i] ^= s[j];
    &#125;
&#125;
//移除多余空格
void removeExtraSpaces(string&amp; s) &#123;
       int slow &#123;0&#125;;
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] != &#39; &#39;) &#123;
            if(slow != 0) s[slow ++] = &#39; &#39;;
               while(i &lt; s.size() &amp;&amp; s[i] != &#39; &#39;) &#123;
                s[slow] = s[i];
                   slow ++;
                i ++;
            &#125;
        &#125;
    &#125;
    s.resize(slow);
&#125;
string reverseWords(string&amp; s) &#123;
    removeExtraSpaces(s);
    reverse(s, 0, s.size() - 1);
    int start &#123;0&#125;;
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] != &#39; &#39;) &#123;
            while(i &lt; s.size() &amp;&amp; s[i] != &#39; &#39;) &#123;
                i ++;
            &#125;
            reverse(s, start, i - 1);
            start = i + 1;
        &#125;
    &#125;
    return s;
&#125;
</code></pre>
<h3 id="左旋字符串"><a href="#左旋字符串" class="headerlink" title="左旋字符串"></a>左旋字符串</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p>
<pre><code class="c++">string leftReverse(string s, int n) &#123;
       reverse(s, 0, n);
    reverse(s, n + 1, s.size());
    reverse(s, 0, s.size());
    return s;
&#125;
</code></pre>
<h3 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr"></a>实现strStr</h3><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p>
<h4 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP  算法"></a>KMP  算法</h4><p>KMP主要应用在字符串匹配上。</p>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p>
<h4 id="最长公共-相同-前后缀？"><a href="#最长公共-相同-前后缀？" class="headerlink" title="最长公共(相同)前后缀？"></a>最长公共(相同)前后缀？</h4><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p>
<p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>
<h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><pre><code class="c++">void getNext(int* next, string s) &#123;
    //初始化, 使 j 为 -1, 判断 i 与 j + 1 
    //方便记录下标， 与回退下标位置
    int j = -1;
    next[0] = -1;
    //i 为 1 表示第二个数开始才有最长相同前后缀
    for (int i = 1; i &lt; s.size(); i ++) &#123;
        //如果前后缀不匹配
        while(j &gt;= 0; s[i] != s[j + 1]) &#123;
            //回退
            j = next[j];
        &#125;
           if(s[i] == s[j + 1])  &#123;
            j ++;
        &#125;
        //记录下标，同样表示相同前后缀
        next[i] = j;
    &#125;
&#125;
</code></pre>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><pre><code class="c++">void getNext(int* next, string needle) &#123;
    int j = -1;
    next[0] = j;
    for(int i = 1; i &lt; needle.size(); i ++) &#123;
        while(j &gt;= 0 &amp;&amp; s[i] != s[j]) &#123;
            j = next[j];
        &#125;
        if(s[i] == s[j]) &#123;
            j ++;
        &#125;
        next[i] = j;
    &#125;
&#125;
int strStr(string haystack, string needle) &#123;
    int j = 0;
    if(needle.size() == 0) retrun 0;
    int next[needle.size()] &#123;0&#125;;
    getNext(next);
    for(int i = 0; i &lt; haystack.size(), i ++) &#123;
        while(j &gt; 0 &amp;&amp; haystack[i] != needle[j]) &#123;
            j = next[j];
        &#125;
        if(haystack[i] == needle[j]) &#123;
            j ++;
        &#125;
        if(j == needle.size() - 1) &#123;
            return (i - needle.size() + 1);
        &#125;
    &#125;
       return -1;
&#125;
</code></pre>
<h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p>
<pre><code class="c++">void getNext(int* next, string s) &#123;
    //自减一
    int j = -1;
    next[0] = j;
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        while(j != -1 &amp;&amp; s[i] != s[j]) &#123;
            j = next[j];
        &#125;
        if(s[i] == s[j]) &#123;
            j ++;
        &#125;
        next[j] = i;
    &#125;
&#125;
bool isReapeat(string s) &#123;
       if(s.size() == 0) &#123;
        return false;
    &#125;
    int len = s.size();
    int next[len];
    getNext(next, s);
    //---(next[s.size() - 1] + 1) 表示最长相等前后缀
    //---len - (next[s.size() - 1] + 1) 表示子串长度
    //---len % 字串长度 == 0 时表示为字串重复
    if(next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1))) &#123;
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>使用栈实现队列的下列操作：</p>
<p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p>
<pre><code class="c++">class MyQueue &#123;
    private : 
        stack&lt;int&gt; stackIn;
        stack&lt;int&gt; stackOut;
    public :
        MyQueue() &#123;&#125;
        int push(x) &#123;
            stackIn.push(x);
        &#125;
        int pop() &#123;
            if(stackOut.empty()) &#123;
                while (!stackIn.empty) &#123;
                    stackOut.push(stackIn.top());
                    stackIn.pop();
                &#125;
                int result = stackOut.top();
                stackOut.pop();
                return result;
            &#125;
        &#125;
        int peek() &#123;
               int result = this-&gt;pop();
            stackOut.push(result);
            return result;
        &#125;
        int empty() &#123;
            return stackIn.empty() &amp;&amp; stackOut.empty();
        &#125;
&#125;
</code></pre>
<h4 id="C语言-2"><a href="#C语言-2" class="headerlink" title="C语言"></a>C语言</h4><pre><code class="c">typedef struct &#123;
    int stackInTop, stackOutTop;
    int stackIn[100], stackOut[100];
&#125;MyQueue;

//初始化
MyQueue* queue() &#123;
    MyQueue* queue = (MyQueue *) malloc(sizeof(MyQueue));
    queue-&gt;stackInTop = 0
    queue-&gt;stackOutTop = 0;
    return queue;
&#125;
int push(MyQueue* que, int x) &#123;
    que-&gt;stackIn[stackInTop] = x;
    stackInTop ++;
    return x;
&#125;
int pop(MyQueue* que) &#123;
    //避免多次操作内存
    int inTop = que-&gt;stackInTop;
    int outTop = que-&gt;stackOutTop;
    if(outTop == 0) &#123;
        while(inTop != 0) &#123;
            que-&gt;stackOut[outTop ++] = que-&gt;stackIn[-- inTop];
        &#125;
        int result = stackOut[--outTop];
        //将输入栈返回到输出栈
        while(outTop != 0) &#123;
            que-&gt;stackIn[inTop ++] = que-&gt;stackOut[-- outTop];
        &#125;
           que-&gt;stackInTop = inTop;
        que-&gt;stackOutTop = outTop;
        return result;
    &#125;
&#125;
int peek(MyQueue* que) &#123;
    return que-&gt;stackIn[0];
&#125;
int empty(MyQueue* que) &#123;
    return que-&gt;stackInTop == 0 &amp;&amp; que-&gt;stackTop == 0;
&#125;
void freeMyQueue(MyQueue* que) &#123;
    que-&gt;stackInTop = 0;
    que-&gt;stackOutTop = 0;
&#125;
</code></pre>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>