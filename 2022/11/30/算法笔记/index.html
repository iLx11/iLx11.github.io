<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:700px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:700px)" href="/css/stylePC.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>
    <style>
        /*页面加载开始*/
        .load {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 35em;
            z-index: 999;
        }

        .loader {
            --path: #323641;
            --dot: #6a95bd;
            --duration: 1.5s;
            width: 55px;
            height: 55px;
            align-items: center;
            justify-items: center;
            position: relative;
        }
        .h-mes {
            width: 100%;
            height: 20%;
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-flow: column nowrap;
            justify-content: space-evenly;
            align-items: center;
        }
        .h-mes span {
            width: 100%;
            height: 10%;
            text-align: center;
        }
        .loader:before {
            content: "";
            width: 6px;
            height: 6px;
            border-radius: 50%;
            position: absolute;
            display: block;
            background: var(--dot);
            top: 37px;
            left: 19px;
            transform: translate(-18px, -18px);
        }

        .loader svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .loader svg polygon {
            fill: none;
            stroke: var(--path);
            stroke-width: 10px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .loader svg polygon {
            stroke-dasharray: 145 76 145 76;
            stroke-dashoffset: 0;
            animation: pathTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }

        .loader.triangle {
            width: 48px;
        }

        .loader.triangle:before {
            left: 21px;
            transform: translate(-10px, -18px);
            animation: dotTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }
        #noWait {
            color: rgba(51,51,51, 0.4);
            margin-top: 3em;
            cursor: pointer;
            display: none;
        }
        @keyframes pathTriangle {
            33% {
                stroke-dashoffset: 74;
            }

            66% {
                stroke-dashoffset: 147;
            }

            100% {
                stroke-dashoffset: 221;
            }
        }

        @keyframes dotTriangle {
            33% {
                transform: translate(0, 0);
            }

            66% {
                transform: translate(10px, -18px);
            }

            100% {
                transform: translate(-10px, -18px);
            }

        }
    </style>

    <body>
        <!-- 页面加载效果 -->
        <div class="load">
            <div class="loader triangle">
                <svg viewBox="0 0 86 80">
                    <polygon points="43 8 79 72 7 72"></polygon>
                </svg>
            </div>
            <div class="h-mes">
                <span id="chs">" 请稍等一会... "</span>
                <span>Please wait for a long time</span>
                <span id="noWait"><我不等啦！></span>
            </div>
        </div>
        
        <!-- 页面加载结束 -->
        <div class="backg"></div>
        <div class="paper">
            <div class="paper-main">
                <!-- <div class="bgimg"></div> -->
                <div class="cover"></div>
                <!-- <div class="bgimgB"></div> -->
                
                    <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                        
                                    <div class="post-main">
    
        <div class="post-main-title">
            算法笔记
        </div>
        <div class="post-meta">
            2022-11-30
        </div>
    
<hr>
    <div class="post-md">
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>左右闭区间</p>
<h5 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int search(vector&lt;int&gt;&amp; a, int target) &#123;
    int mid, left = 0, right = a.size() - 1;
    //1.[left, right] -- 2.[left, right) -&gt; left&lt;right
    while(left &lt;= right) &#123;
        mid = left + ((right - left) &gt;&gt; 1);
        if(a[mid] &gt; target) &#123;
            //闭区间
            //2.right = mid;
            right = mid - 1;
        &#125;else if(a[mid] &lt; target) &#123;
            //闭区间
            left = mid + 1;
        &#125;else if(a[mid] == target) &#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h5 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">//左闭右闭
int search(int* nums, int length, int target) &#123;
    int mid = 0, left = 0, right = length - 1;
    while(left &lt;= right) &#123;
        mid = left + ((right - left) &gt;&gt; 1);
        if(nums[mid] &lt; target) &#123;
            left = mid + 1;
        &#125;else if(nums[mid] &gt; traget) &#123;
            right = mid - 1;
        &#125;else &#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><pre><code class="js">function search(nums, target) &#123;
    let mid = 0, left = 0, right = nums.length;
    while(left &lt;= right) &#123;
        mid = left + ((right - left) &gt;&gt; 1);
        if(nums[mid] &gt; target) &#123;
            right = mid - 1;
        &#125;else if(nums[mid] &lt; target) &#123;
            left = mid + 1;
        &#125;else &#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><pre><code class="java">public int search(int[] nums, int target) &#123;
    int mid = 0, left = 0, right = nums.length;
    while(left &lt;= right) &#123;
        mid = left + ((right - left) &gt;&gt; 1);
        if(nums[mid] &gt; target) &#123;
            right = mid - 1;
        &#125;else if(left &lt; target) &#123;
            left = mid + 1;
        &#125;else &#123;
            return mid;
        &#125;
    &#125;
    return -1;
&#125;
</code></pre>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><pre><code class="c++">int remove(vector&lt;int&gt;&amp; a, int target) &#123;
    int length = a.size();
    for(int i = 0; i &lt; length; i++) &#123;
        if(a[i] == target) &#123;
            for(int j = i + 1; j &lt; length; j++) &#123;
                a[j - 1] = a[j];
            &#125; 
            i--;
            length--;
        &#125;
    &#125;
    return length;
&#125;
</code></pre>
<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><h5 id="c-1"><a href="#c-1" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int remove(vector&lt;int&gt;&amp; a, int target) &#123;
    int length = a.size();
    int slow = 0;
    for(int fast = 0; fast &lt; length; fast ++) &#123;
        if(a[fast] != target) &#123;
            a[slow] = a[fast];
            slow ++;
        &#125;
    &#125;
    return slow;
&#125;
</code></pre>
<h5 id="c语言"><a href="#c语言" class="headerlink" title="c语言"></a>c语言</h5><pre><code class="c">int remove(int* nums, int length, int target) &#123;
    int slow = 0;
    for(int fast = 0; fast &lt; length; fast ++) &#123;
        if(nums[fast] != target) &#123;
            nums[slow ++] = nums[fast];
        &#125;
    &#125;
    //新数组的长度
    return slow;
&#125;
</code></pre>
<h4 id="双向指针法"><a href="#双向指针法" class="headerlink" title="双向指针法"></a>双向指针法</h4><p>尽可能移动最少的元素</p>
<h5 id="c-2"><a href="#c-2" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int remove(vector&lt;int&gt;&amp; a, int target) &#123;
    int length = a.size();
    int left = 0;
    int right = length - 1;
    //将右值移动到不与 target 相等的值
    while(right &gt;= 0 &amp;&amp; nums[right] == target) right --;
    while(left &lt;= right) &#123;
        if(a[left] == target) &#123;
            a[left] == a[right];
            //对应的值已移动到前面
            right --;
        &#125;
        left ++;
        while(right &gt;= 0 &amp;&amp; a[rigth] == target) &#123;
            right --;
        &#125;
    &#125;
    return left;
&#125;
</code></pre>
<h5 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h5><pre><code class="java">public int remove(int[] nums, int target) &#123;
    int left = 0;
    int right = nums.length;
    while(left &lt;= right) &#123;
        //右指针移动到 ！target
        while(right &gt;= 0 &amp;&amp; nums[right] == target) right --;
        //左指针移动到 target
        while(left &gt;= 0 &amp;&amp; nums[left] != target) left ++;
        if(left &lt;= right) &#123;
            nums[left ++] = nums[right --];
        &#125;
    &#125;
    return left;
&#125;
</code></pre>
<h2 id="有序数组平方"><a href="#有序数组平方" class="headerlink" title="有序数组平方"></a>有序数组平方</h2><p>将有序数组内元素平方之后进行排序</p>
<h5 id="c-3"><a href="#c-3" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int* sortedSquares(vector&lt;int&gt;&amp; a) &#123;
    int length = a.size();
    int left = 0, right = length - 1, k = length - 1;
    int newArr[length]&#123;&#125;;
    for(int i = 0; i &lt; length; i ++) &#123;
        if(a[left] * a[left] &lt; a[right] * a[right]) &#123;
            newArr[k --] =  a[right] * a[right];
            right --;
        &#125;else &#123;
            newArr[k --] =  a[left] * a[left];
            left ++;
        &#125;
    &#125;
    a = newArr;
    return a;
&#125;
</code></pre>
<h5 id="C语言-1"><a href="#C语言-1" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">int* sortedSquares(int* nums, int length) &#123;
    int left = 0;
    int right = length - 1;
    int k = length - 1;
    //结果数组分配空间
    int* result = (int *) malloc(sizeof(int) * length);
    while(left &lt;= right) &#123;
        if(nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;
            result[k --] = nums[left] * nums[left ++];
        &#125;else if(nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;
            result[k --] = nums[right] * nums[right --];
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h5 id="js-1"><a href="#js-1" class="headerlink" title="js"></a>js</h5><pre><code class="js">function sortedSquares(nums) &#123;
    let left = 0, right = nums.length - 1;
    let k = nums.length - 1;
    let result = new Array(nums.length).fill(0);
    while(left &lt;= right) &#123;
        if(nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;
            result[k --] = nums[left] * nums[left ++];
        &#125;else if(nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;
            result[k --] = nums[right] * nums[right --];
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h5 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h5><pre><code class="java">public sortedSquares(int[] nums) &#123;
    int left = 0, right = nums.length - 1;
    int k = nums.length - 1;
    int[] result = new int[nums.length];
    while(left &lt;= right) &#123;
        if(nums[left] * nums[left] &gt; nums[right] * nums[right]) &#123;
            result[k --] = nums[left] * nums[left ++];
        &#125;else if(nums[left] * nums[left] &lt; nums[right] * nums[right]) &#123;
            result[k --] = nums[right] * nums[right --];
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p>
<p>示例：</p>
<p>输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</p>
<h4 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h4><h5 id="c-4"><a href="#c-4" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int minSubArrayLen(int s, vector&lt;int&gt;&amp; a) &#123;
    int len = a.size();
    int result = INT32_MAX;
    int sum&#123;0&#125;, subLength&#123;0&#125;;
    for(int i = 0; i &lt; len; i ++) &#123;
        sum = 0; 
        for(int j = i; j &lt; len; j ++) &#123;
            sum += a[j];
            if(sum &gt;= s) &#123;
                subLength = j - i + 1;
                result = result &lt; subLength ? result : subLength;
                break; //执行完退出
            &#125;
        &#125;
    &#125;
    return result == IN32_MAX ? 0 : result; 
&#125;
</code></pre>
<h4 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h4><p>构建一个窗口不断增长缩减</p>
<h5 id="c-5"><a href="#c-5" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int minSubArrayLen(int s, vector&lt;int&gt;&amp; a) &#123;
    int result = IN32_MAX;
    int len = a.size();
    int i&#123;0&#125;, subLength&#123;0&#125;, sum&#123;0&#125;;
    for(int j = 0; j &lt; len; j ++) &#123;
        sum += a[j];
        while(sum &gt;= s) &#123;
            subLength = j - i + 1;
            result = result &lt; subLength ? result : subLength;
            sum -= a[i];
            i ++;
        &#125;
    &#125;
    return result == IN32_MAX ? 0 : result;
&#125;
</code></pre>
<h5 id="c语言-1"><a href="#c语言-1" class="headerlink" title="c语言"></a>c语言</h5><pre><code class="c">int minSubArrayLen(int* nums, int length, int target) &#123;
    //初始化最大值
    int result = INT_MAX;
    int left = 0, right = 0, sum = 0;
    for(; right &lt; length; right ++) &#123;
        sum += nums[right];
        while(sum &gt;= target) &#123;
            int subLen = right - left + 1;
            result = subLen &lt; result ? subLen : result;
            sum -= nums[left];
            left ++;
        &#125;
    &#125;
    return result == INT_MAX ? 0 : result;
&#125;
</code></pre>
<h5 id="js-2"><a href="#js-2" class="headerlink" title="js"></a>js</h5><pre><code class="js">function minSubArrayLen(nums, target) &#123;
    let result = Infinity;
    let left = 0, right = 0, sum = 0;
    for(right &lt; nums.length; right ++) &#123;
        sum += nums[right];
        while(sum &gt;= target) &#123;
               let subLen = right - left + 1;
            result = subLen &lt; result ? subLen : result;
            sum -= nums[left ++];
        &#125;
    &#125;
    return result == Infinity ? 0 : result;
&#125;
</code></pre>
<h5 id="java-3"><a href="#java-3" class="headerlink" title="java"></a>java</h5><pre><code class="java">public int minSubArrayLen(int[] nums, int target) &#123;
    int result = Integer.MAX_VALUE;
    int left = 0, right = 0, sum = 0;
    for(right &lt; nums.length; right ++) &#123;
        sum += nums.[right];
        while(sum &gt;= target) &#123;
            result = Math.min(result, right - left + 1);
            sum -= nums[left ++];
        &#125;
    &#125;
    return result == Integer.MAX_VALUE ? 0 : result;
&#125;
</code></pre>
<h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><h5 id="c-6"><a href="#c-6" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">void generateMatrix(int n) &#123;
    //定义二维数组并填充 0
    vector&lt;vector&lt;int&gt;&gt; array(n, vector&lt;int&gt; (n, 0));
    int loop &#123;0&#125;;
    int startx &#123;0&#125;;
    int starty &#123;0&#125;;
    int mid &#123;n / 2&#125;;
    int offset &#123;1&#125;;
    int count &#123;1&#125;;
    int i, j;
    while(loop ++ &lt; n / 2) &#123;
        i = startx;
        j = starty;
        
        //从左往右
        for(i = startx; i &lt; n - offset; i ++) &#123;
            array[startx][i] = count ++;
        &#125;
        //从上往下
        for(j = starty; j &lt; n - offset; j ++) &#123;
            array[j][i] = count ++;
        &#125;
        //从右往左
        for(; i &gt; startx; i --) &#123;
            array[j][i] = count ++;
        &#125;
           //从下往上
        for(; j &gt; starty; j --) &#123;
            array[j][i] = count ++;
        &#125;
        startx ++;
        starty ++;
        //收缩1
        offset ++;
    &#125;
    if(n % 2) &#123;
        array[mid][mid] = count;
    &#125;
&#125;
</code></pre>
<h5 id="C语言-2"><a href="#C语言-2" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">int** generateMatrix(int n) &#123;
    //定义结果数组
    int** result = (int *) malloc(sizeof(int) * n);
    //二维定义空间
    for(int i = 0; i &lt; n; i ++) &#123;
        result[i] = (int *) malloc(sizeof(int) * n);
    &#125;
       int loop = n / 2;
    int mid = n / 2;
    int startx = 0, starty = 0;
    int offset = 0;
    int count = 1;
    int row, column;
    while(loop --) &#123;
        row = startx;
        column = starty;
        //从左到右
        for(row = startx; row &lt; n - offset; row ++) &#123;
            result[startx][row] = count ++;
        &#125;
        //从上到下
        for(column = starty; column &lt; n - offset; column ++) &#123;
            result[column][row] = count ++;
        &#125;
        //从右到左
        for(; row &lt; startx; row --) &#123;
            result[column][row] = count ++;
        &#125;
        //从下到上
        for(; column &lt; starty; column --) &#123;
            result[column][row] = count ++;
        &#125;
        //设定前后边界加1
           startx ++;
        starty ++;
        offset ++;
        //如果n是奇数，说明需要画中心点
        if(n % 2) result[mid][mid] = count;
    &#125;
&#125;
</code></pre>
<h5 id="js-3"><a href="#js-3" class="headerlink" title="js"></a>js</h5><pre><code class="js">function generateMatrix(n) &#123;
    //创建结果二维数组
    let result = new Array(n).fill(0).map(() =&gt; new Array(n).fill(0));
&#125;
</code></pre>
<h5 id="java-4"><a href="#java-4" class="headerlink" title="java"></a>java</h5><pre><code class="java">public int[][] generateMatrix(int n) &#123;
    int[][] result = new int[n][n];
&#125;
</code></pre>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><h5 id="c-7"><a href="#c-7" class="headerlink" title="c++"></a>c++</h5><pre><code class="C++">struct ListNode &#123;
    int val;
    ListNode* next;
    //构造函数初始化
    ListNode(int x) : val(x), next(NULL) &#123;&#125;;
&#125;;
</code></pre>
<h5 id="c语言-2"><a href="#c语言-2" class="headerlink" title="c语言"></a>c语言</h5><pre><code class="c">typedef struct ListNode &#123;
    int val;
    struct ListNode* next;
&#125;LNode, * PNode;

PNode InitList(int value) &#123;
    PNode node = (PNode) malloc(sizeof(LNode));
    node-&gt;val = value;
    node-&gt;next = NULL;
    return node;
&#125;
</code></pre>
<h5 id="js-4"><a href="#js-4" class="headerlink" title="js"></a>js</h5><pre><code class="js">class ListNode &#123;
    val;
    next;
    constructor(value) &#123;
        this.val = value;
        this.next = null;
    &#125;
&#125;
</code></pre>
<h5 id="java-5"><a href="#java-5" class="headerlink" title="java"></a>java</h5><pre><code class="java">public class ListNode &#123;
    private int val;
    private ListNode next;
    public ListNode() &#123;&#125;
    public ListNode(int value) &#123;
        this.val = value;
    &#125;
    public ListNode(int value, ListNode next) &#123;
        this.val = value;
        this.next = next;
    &#125;
&#125;
</code></pre>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><h4 id="处理头节点"><a href="#处理头节点" class="headerlink" title="处理头节点"></a>处理头节点</h4><pre><code class="c++">ListNode* delNode(ListNode* head, int val) &#123;
    //删除头节点
    while(head != NULL &amp;&amp; head-&gt;val == val) &#123;
        ListNode* temp = head;
        head = head-&gt;next;
        delete temp;
    &#125;
    //删除相同元素
    ListNode* cur = head;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delete temp;
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    return head;
&#125;
</code></pre>
<h4 id="设置虚拟头节点"><a href="#设置虚拟头节点" class="headerlink" title="设置虚拟头节点"></a>设置虚拟头节点</h4><h5 id="c-8"><a href="#c-8" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* delNode(ListNode* head, int val) &#123;
    //设置虚拟头节点
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* cur = vhead;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            delet tempo;
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
     head = vhead-&gt;next;
     delete vhead;
     return head;
&#125;
</code></pre>
<h5 id="C语言-3"><a href="#C语言-3" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="C++">struct ListNode* delNode(struct ListNode* head, int val) &#123;
    while(head != NULL &amp;&amp; head-&gt;val == val) &#123;
        struct ListNode* temp = head;
        head = head-&gt;next;
        free(temp);
    &#125;
    struct ListNode* cur = head;
       while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            struct ListNode* temp = cur-&gt;next;
            cur-next = cur-&gt;next-&gt;next;
            free(temp);
        &#125;
    &#125;
    return head;
&#125; 

//虚拟头节点方法
struct ListNode* delNode(struct ListNode* head, int val() &#123;
    typedef struct ListNode ListNode;
    ListNode *vhead = (ListNode *) malloc(sizeof(ListNode));
    vhead-&gt;next = head;
    ListNode *cur = vhead;
    while(cur != NULL &amp;&amp; cur-&gt;next != NULL) &#123;
        if(cur-&gt;next-&gt;val == val) &#123;
            ListNode *temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
            free(temp);
        &#125;else &#123;
            cur = cur-&gt;next;
        &#125;
    &#125;
    head = vhead-&gt;next;
    free(vhead);
    return head;
&#125;
</code></pre>
<h5 id="js-5"><a href="#js-5" class="headerlink" title="js"></a>js</h5><pre><code class="js">function delNode(head, val) &#123;
    let vhead = new ListNode(0, head);
    let cur = vhead;
    while(cur &amp;&amp; cur.next) &#123;
           if(cur.next.val === val) &#123;
            cur.next = cur.next.next;
        &#125;else &#123;
             cur = cur.next;   
        &#125;
    &#125;
    return vhead.next;
&#125;
</code></pre>
<h5 id="java-6"><a href="#java-6" class="headerlink" title="java"></a>java</h5><pre><code class="java">public ListNode delNode(ListNode head, int val) &#123;
       ListNode vhead = new ListNode(0, head);
    ListNode pre = vhead;
    ListNode cur = vhead.next;
    while(cur) &#123;
        if(cur.val == val) &#123;
            pre.next = cur.next;
        &#125;else &#123;
            pre = cur;
        &#125;
        cur = cur.next;
    &#125;
&#125;
</code></pre>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><blockquote>
<ul>
<li>获取链表第index个节点的数值</li>
<li>在链表的最前面插入一个节点</li>
<li>在链表的最后面插入一个节点</li>
<li>在链表第index个节点前面插入一个节点</li>
<li>删除链表的第index个节点</li>
</ul>
</blockquote>
<h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><pre><code class="c++">class LinkedList &#123;
    private:
        int _size;
        ListNode* _vhead;
    public:
        struct ListNode &#123;
            int val;
            ListNode* next;
            ListNode(int val): val(val), next(nullptr)&#123;&#125;
        &#125;;
        //构造函数
        LinkedList() &#123;
               _vhead = new ListNode(0);
            _size = 0;
        &#125;
        //获取index数值
        int getVal(int index) &#123;
            if(index &lt; 0 || index &gt; _size - 1) &#123;
                return -1;
            &#125;
            //后移节点确保最后cur为index
            ListNode* cur = _vhead-&gt;next;
            while(index--) &#123;
                   cur = cur-&gt;next;
            &#125;
            return cur-&gt;val;
        &#125;
        //头部添加节点
        void preNode(int val) &#123;
            ListNode* newNode = new ListNode(val);
            newNode-&gt;next = _vhead-&gt;next;
            -vhead-&gt;next = newNode;
            _size ++;
        &#125;
        //尾部添加节点
        void pushNode(int val) &#123;
            ListNode* newNode = new ListNode(val);
            ListNode* cur = _vhead;
            while(cur-&gt;next != NULL) &#123;
                cur = cur-&gt;next;
            &#125;
            cur-&gt;next = newNode;
            _size ++;
        &#125;
        //删除 index 节点
        void delIndexNode(int index) &#123;
               ListNode* cur = _vhead;
            while(index --) &#123;
                cur = cur-&gt;next;
            &#125;
            ListNode* temp = cur-&gt;next;
            cur-&gt;next = cur-&gt;next-&gt;next;
               delete temp;
            _size --;
        &#125;
        //添加 index 节点
        void addIndexNode(int index) &#123;
            ListNode* newNode = new ListNode(val);
            ListNode* cur = _vhead;
            while(index --) &#123;
                cur = cur-&gt;next;
            &#125;
            newNode-&gt;next = cur-&gt;next;
            cur-next = newNode;
            _size ++;
        &#125;
        //遍历链表
        void showLinked() &#123;
            ListNode* cur = _vhead;
               while(cur-&gt;next != NULL) &#123;
                cout &lt;&lt;&quot;val == &quot; &lt;&lt; cur-&gt;next-&gt;val;
                cur = cur-&gt;next;
            &#125;
            cout &lt;&lt; endl;
        &#125;
&#125;
</code></pre>
<h5 id="C语言-4"><a href="#C语言-4" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">typedef struct ListNode &#123;
    int val;
    struct ListNode* next;
&#125;LNode, * PNode;
//定义指针类型
PNode LinkedInit() &#123;
    PNode vhead = (PNode) malloc(sizeof(LNode));
    vhead-&gt;val = -1;
    vhead-&gt;next = NULL;
    return vhead;
&#125;
//后面添加
PNode pushLinked(PNode vhead, int val) &#123;
    PNode cur = vhead;
    while(cur-&gt;next != NULL) &#123;
        cur = cur-&gt;next;
    &#125;
    PNode newNode = (PNode) malloc(sizeof(LNode)):
    newNode-&gt;val = val;
    cur-&gt;next = newNode;
    return newNode;
&#125;
//前面添加
PNode preLinked(PNode vhead, int val) &#123;
    PNode newNode = (PNode) malloc(sizeof(LNode));
    newNode-&gt;val = val;
    newNode-&gt;next = vhead-&gt;next;
    vhead-&gt;next = newNode;
    return newNode;
&#125;
//删除index
PNode delIndex(PNode vhead, int index) &#123;
    PNode cur = vhead;
    while(index --) &#123;
        cur = cur-&gt;next;
    &#125;
       PNode temp = cur-&gt;next;
    cur-&gt;next = cur-&gt;next-&gt;next
    free(temp);
    return temp;
&#125;
//获取index
int getIndex(PNode vhead, int index) &#123;
    PNode cur = vhead-&gt;next;
    while(index --) &#123;
        cur = cur-&gt;next;
    &#125;
    return cur-&gt;val;
&#125;
//添加index
PNode AddIndex(PNode vhead, int index) &#123;
    PNode cur = vhead;
    while(index --) &#123;
        cur = cur-&gt;next;
    &#125;
       PNode newNode = (PNode) malloc(sizeof(LNode));
    newNode-&gt;next = cur-&gt;next-&gt;next;
    cur-&gt;next = newNode;
    return newNode;
&#125;
</code></pre>
<h2 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h2><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><h5 id="c-9"><a href="#c-9" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* reverseList(ListNode* head) &#123;
    ListNode* pre = NULL;
    ListNode* cur = head;
    ListNode* temp = NULL;
    while(cur != NULL) &#123;
        temp = cur-&gt;next;
        cur-&gt;next = pre;
        pre = cur;
        cur = temp;
    &#125;
    return pre;
&#125;
</code></pre>
<h5 id="C语言-5"><a href="#C语言-5" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">PNode reverseList(PNode head) &#123;
    PNode cur = head;
    PNode pre = NULL;
    PNode temp = NULL;
    while(cur != NULL) &#123;
           temp = cur-&gt;next;
           cur-&gt;next = pre;
           pre = cur;
        cur = temp;
    &#125;
    return head;
&#125;
</code></pre>
<h5 id="js-6"><a href="#js-6" class="headerlink" title="js"></a>js</h5><pre><code class="js">function reverseList(head) &#123;
    let pre = null;
    let cur = head;
    let temp = null;
    while(cur) &#123;
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    &#125;
    return head;
&#125;
</code></pre>
<h5 id="java-7"><a href="#java-7" class="headerlink" title="java"></a>java</h5><pre><code class="java">public ListNode reverseList(ListNode head) &#123;
    ListNode cur = head;
    ListNode pre = null;
    ListNode temp = null;
    while(cur) &#123;
        temp = head.next;
           cur.next = pre;
        pre = cur;
        cur = temp;
    &#125;
&#125;
</code></pre>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><h5 id="c-10"><a href="#c-10" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* reverseList(ListNode* pre, ListNode* head) &#123;
    //head 为null 说明上一个节点为最后节点
    if(head == NULL) return pre;
    ListNode* temp = head-&gt;next;
    head-&gt;next = pre;
    //pre = cur; cur = temp;
    return reverseList(head, temp);
&#125;
reverseList(NULL, head);
</code></pre>
<h5 id="c-11"><a href="#c-11" class="headerlink" title="c"></a>c</h5><pre><code class="c">PNode reverseList(PNode pre, PNode head) &#123;
    if(head == NULL) return pre
    PNode temp = head-&gt;next;
    head-&gt;next = pre;
    return reverseList(head, temp);
&#125;
</code></pre>
<h5 id="js-7"><a href="#js-7" class="headerlink" title="js"></a>js</h5><pre><code class="js">function reverseList(pre, cur) &#123;
    if(cur == null) return pre;
    let temp = cur.next;
    cur.next = pre;
    return reverseList(cur, temp);
&#125;
</code></pre>
<h5 id="java-8"><a href="#java-8" class="headerlink" title="java"></a>java</h5><pre><code class="java">public ListNode reveseList(ListNode pre, ListNode cur) &#123;
    if(cur == null) return pre;
    ListNode = cur.next;
    cur.next = pre;
    return reverseList(cur, temp);
&#125;
</code></pre>
<h2 id="两两交换链表的节点"><a href="#两两交换链表的节点" class="headerlink" title="两两交换链表的节点"></a>两两交换链表的节点</h2><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><h5 id="c-12"><a href="#c-12" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* switchPairs(ListNode* head) &#123;
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* cur = vhead;
    while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;
           ListNode* temp1 = cur-&gt;next;
        ListNode* temp2 = cur-&gt;next-&gt;next;
        //开始交换
        cur-&gt;next = temp2;
        cur-&gt;next-&gt;next = temp1;
        cur-&gt;next-&gt;next-&gt;next = temp2-&gt;next;
        //向后移动两位
        cur = cur-&gt;next-&gt;next;
    &#125;
       return vhead-&gt;next;
&#125;
</code></pre>
<h5 id="c-13"><a href="#c-13" class="headerlink" title="c"></a>c</h5><pre><code class="c">PNode switchPairs(PNode head) &#123;
    PNode vhead = (PNode) malloc(sizeof(LNode));
    vhead-&gt;next = head;
    PNode cur = vhead;
       while(cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL) &#123;
        PNode temp1 = cur-&gt;next;
        PNode temp2 = cur-&gt;next-&gt;next;
        cur-&gt;next = temp2;
        cur-&gt;next-&gt;next = temp1;
        cur-&gt;next-&gt;next-&gt;next = temp2-&gt;next;
        
        cur = cur-&gt;next-&gt;next;
    &#125;
    return head-&gt;next;
&#125;
</code></pre>
<h5 id="js-8"><a href="#js-8" class="headerlink" title="js"></a>js</h5><pre><code class="js">function switchPairs(head) &#123;
    ListNode vhead = new ListNode(0);
    vhead.next = head;
    ListNode cur = vhead;
    while(cur.next &amp;&amp; cur.next.next) &#123;
        ListNode temp1 = cur.next;
        ListNode temp2 = cur.next.next;
        cur.next = temp2;
        cur.next.next = temp1;
        cur.next.next.next = temp2.next;
        cur = cur.next.next;
    &#125;
    return vhead.next;
&#125;
</code></pre>
<h5 id="java-9"><a href="#java-9" class="headerlink" title="java"></a>java</h5><pre><code class="java">public ListNode switchPairs(ListNode head) &#123;
    ListNode vhead = new ListNode(0, head);
    ListNode cur = vhead;
    while(cur.next &amp;&amp; cur.next.next) &#123;
        ListNode temp1 = cur.next;
        ListNode temp2 = cur.next.next.next;
        cur.next = temp1.next;
        cur.next.next = temp1;
        cur.next.next.next = temp2;
        cur = cur.next.next;
    &#125;
    return vhead.next;
&#125;
</code></pre>
<h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><h5 id="c-14"><a href="#c-14" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* switchPairs(ListNode* head) &#123;
    if(!head || !head-&gt;next) return head;
    //记录下一个节点
    ListNode* newNode = head-next;
    //指向第下一个交换节点
    head-&gt;next = switchPairs(newNode-&gt;next);
    //交换当前节点
    newNode-&gt;next = head;
    return newNode;
&#125;
</code></pre>
<h5 id="c-15"><a href="#c-15" class="headerlink" title="c"></a>c</h5><pre><code class="c">PNode switchPairs(PNode head) &#123;
    if(!head || !head-&gt;next) return head;
    PNode newNode = head-&gt;next;
    head-&gt;next = switchPairs(newNode-&gt;next);
    newNode-&gt;next = head;
    return newNode;
&#125;
</code></pre>
<h5 id="js-9"><a href="#js-9" class="headerlink" title="js"></a>js</h5><pre><code class="js">function switchPairs(head) &#123;
    if(!head || !head.next) return head;
    let newNode = head.next;
    head.next = switchPairs(newNode.next);
    newNode.next = head;
    return newNode;
&#125;
</code></pre>
<h5 id="java-10"><a href="#java-10" class="headerlink" title="java"></a>java</h5><pre><code class="java">public ListNode switchPairs(ListNode head) &#123;
    if(!head || !head.next) return head;
    ListNode newNode = head.next;
    head.next = switchPairs(newNode.next);
       newNode.next = head;
    return newNode;
&#125;
</code></pre>
<h2 id="删除倒数第N个节点"><a href="#删除倒数第N个节点" class="headerlink" title="删除倒数第N个节点"></a>删除倒数第N个节点</h2><h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><h5 id="c-16"><a href="#c-16" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* delReverseN(ListNode* head, int N) &#123;
    ListNode* vhead = new ListNode(0);
    vhead-&gt;next = head;
    ListNode* slowp = vhead;
    ListNode* fastp = vhead;
    while(N-- &amp;&amp; fastp-&gt;next) &#123;
        fastp = fastp-&gt;next;
    &#125;
    //结果范围大一
    fastp = fastp-&gt;next;
    while(fastp) &#123;
        fastp = fastp-&gt;next;
        slowp = slowp-&gt;next;
    &#125;
    //删除节点，释放内存
    ListNode* temp = slowp-&gt;next;
    slowp-&gt;next = slow-&gt;next-&gt;next;
    delete temp;
    retrun vhead-&gt;next;
&#125; 
</code></pre>
<h5 id="c-17"><a href="#c-17" class="headerlink" title="c"></a>c</h5><pre><code class="c">PNode delReverseN(PNode head, int N) &#123;
    PNode vhead = (PNode) malloc(sizeof(LNode));
    vhead-&gt;next = head;
    PNode slowp = vhead;
    PNode fastp = vhead;
    while(N -- &amp;&amp; !vhead-&gt;next) &#123;
        fastp = fastp-&gt;next;
    &#125;
    while(fastp-&gt;next) &#123;
        fastp = fastp-&gt;next;
        slowp = slowp-&gt;next;
    &#125;
    //slowp 的下一个节点即为目标节点
    PNode temp = slowp-&gt;next;
    slowp-&gt;next = slowp-&gt;next-&gt;next;
       free(temp);
    return vhead-&gt;next;
&#125;
</code></pre>
<h5 id="js-10"><a href="#js-10" class="headerlink" title="js"></a>js</h5><pre><code class="js">function delReverseN(head, N) &#123;
    let vhead = new ListNode(0, head);
    let slowp = vhead;
    let fastp = vhead;
    while(N -- &amp;&amp; fastp.next) &#123;
        fastp = fastp.next;
    &#125;
    while(fast.next) &#123;
        slowp = slowp.next;
        fastp = fastp.next;
    &#125;
    slowp.next = slow.next.next;
    return vhead.next;
&#125;
</code></pre>
<h5 id="java-11"><a href="#java-11" class="headerlink" title="java"></a>java</h5><p>计算节点数</p>
<pre><code class="java">public ListNode delReverseN(ListNode head, int N) &#123;
       ListNode cur = head;
       int count = 0;
       while(cur) &#123;
        cur = cur.next;
        count ++;
    &#125;
    if(count == N) &#123;
        head = head.next;
    &#125;else &#123;
        //将指针归位
        cur = head;
        for(int i = 0; i &lt; count - N -1; i ++) &#123;
            cur = cur.next;
        &#125;
        cur.next = cur.next.next;
    &#125;
    return head;
&#125;
</code></pre>
<h4 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h4><h5 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h5><pre><code class="c++">//从后往前计算count
class Solution &#123;
    private: 
    int count;
    public:
    void reverse(ListNode* head, int N) &#123;
        if(!head) return ;
        reverse(head-&gt;next);
        count ++;
        if(count == N + 1) &#123;
            head-&gt;next = head-&gt;next-&gt;next;
        &#125;
    &#125;
    ListNode* delReverseN(ListNode head, int N) &#123;
        ListNode* vhead = new ListNode(0, head);
        count = 0;
        reverse(vhead, N);
        return vhead-&gt;next;
    &#125;
&#125;
</code></pre>
<h5 id="c-18"><a href="#c-18" class="headerlink" title="c"></a>c</h5><pre><code class="c">int count;
void reverse(PNode head, int N) &#123;
    if(! head) return ;
    reverse(head-&gt;next, N);
    count ++;
    if(count == N + 1) &#123;
        head-&gt;next = head-&gt;next-&gt;next;
    &#125;
&#125;
PNode delReverseN(PNode head, int N) &#123;
    PNode vhead = (PNode) malloc(sizeof(LNode));
    count = 0;
    reverse(vhead, N);
    return vhead-&gt;next;
&#125;
</code></pre>
<h5 id="js-11"><a href="#js-11" class="headerlink" title="js"></a>js</h5><pre><code class="js">function delReverseN(head, N) &#123;
       let vhead = new ListNode(0, head);
    let count = 0;
    function reverse(head) &#123;
        if(!head) return ;
        reverse(head.next);
        count ++;
          if(count == N + 1) &#123;
            head.next = head.next.next;
        &#125;
    &#125;
    reverse(vhead);
    return vhead.next;
&#125;
</code></pre>
<h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><h5 id="c-19"><a href="#c-19" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* getIntersectionNode(ListNode* linA, ListNode* linB) &#123;
    ListNode* lA = linA;
    ListNode* lB = linB;
    int alen&#123;0&#125;, blen&#123;0&#125;;
    //计算链表长度
    while(lA != NULL) &#123;
        lA = lA-&gt;next;
        alen ++;
    &#125;
    while(lB != NULL) &#123;
        lB = lB-&gt;next;
        blen ++;
    &#125;
    //使 A， B指向头部
    lA = linA;
    lB = linB;
    //保持A指向较长的链表
    if(blen &gt; alen) &#123;
        //交换值
        swap(blen, alen);
        swap(lB, lA);
    &#125;
    int comp = alen - blen;
    while(comp --) &#123;
        lA = lA-&gt;next;
    &#125;
    //寻找相交
    while(lA != NULL) &#123;
        if(lA == lB) &#123;
            return lA;
        &#125;
        lA = lA-&gt;next;
        lB = lB-&gt;next;
    &#125;
    retrun NULL;
&#125;
</code></pre>
<h5 id="c-20"><a href="#c-20" class="headerlink" title="c"></a>c</h5><pre><code class="c">PNode getIntersectionNode(PNode LA, PNode LB) &#123;
       PNode la = LA;
    PNode lb = LB;
    int asize = 0, bsize = 0, comp = 0;
    //计算长度
    while(la) &#123;
        la = la-&gt;next;
        asize ++;
    &#125;
    while(lb) &#123;
        lb = lb-&gt;next;
        bsize ++;
    &#125;
    if(bsize &gt; asize) &#123;
        la = LB;
        lb = LA;
        comp = bsize - asize;
    &#125;else &#123;
        la = LA;
        lb = LB;
        comp = asize - bsize;
    &#125;
    //使长度一致
    while(comp --) &#123;
        la = la-&gt;next;
    &#125;
    while(la) &#123;
        if(la = lb) &#123;
            return la;
        &#125;
        la = la-&gt;next;
        lb = lb-&gt;next;
    &#125;
    return NULL;
&#125;
</code></pre>
<h5 id="js-12"><a href="#js-12" class="headerlink" title="js"></a>js</h5><pre><code class="js">function getIntersectionNode(LA, LB) &#123;
    let la = LA, lb = LB;
    let asize = 0, bsize = 0, comp = 0;
    while(la) &#123;
        la = la.next;
        asize ++;
    &#125;
    while(lb) &#123;
        lb = lb.next;
        bsize ++;
    &#125;
    la = LA;
    lb = LB;
    if(bsize &gt; asize) &#123;
        [asize, bsize] = [bsize, asize];
        [la, lb] = [lb, la];
    &#125;
    comp = asize - bsize;
    while(comp --) &#123;
        la = la.next;
    &#125;
    while(la) &#123;
        if(la == lb) &#123;
            return la;
        &#125;
        la = la.next;
        lb = lb.next;
    &#125;
    return NULL;
&#125;
</code></pre>
<h5 id="java-12"><a href="#java-12" class="headerlink" title="java"></a>java</h5><pre><code class="java">public ListNode getIntersectionNode(ListNode LA, ListNode LB) &#123;
    ListNode la = LA;
    ListNode lb = LB;
    int asize = 0, bsize = 0, comp = 0;
    while(la) &#123;
        la = la.next;
        asize ++;
    &#125;
    while(lb) &#123;
        lb = lb.next;
        bsize ++;
    &#125;
    la = LA;
    lb = LB;
    if(bsize &gt; asize) &#123;
        ListNode temp = la;
        la = lb;
        lb = temp;
        int temp2 = asize;
        asize = bsize;
        bsize = temp2;
    &#125;
    comp = asize -bsize;
    while(comp --) &#123;
        la = la.next;
    &#125;
    while(la) &#123;
        if(la == lb) &#123;
            return la;
        &#125;
        la = la.next;
        lb = lb.next;
    &#125;
    return NULL;
&#125;
</code></pre>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>(x + y) * 2 = x + y + n (y + z)</p>
<p>x = (n - 1) (y + z) + z</p>
<p>当 n = 0 时</p>
<p>x = z</p>
<h5 id="c-21"><a href="#c-21" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">ListNode* findSycle (ListNode* head) &#123;
    ListNode* slow = head;
    ListNode* fast = head;
    while(fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        //判断是否相遇
        while(slow == fast) &#123;
            ListNode* index1 = fast;
            ListNode* index2 = head;
            //寻找环的入口节点， 相遇点开始各移一个，之后相交则为入口节点
            while(index1 != index2) &#123;
                   index1 = index1-&gt;next;
                index2 = index2-&gt;next;
            &#125;
            return index2;
        &#125;
        retrun NULL;
    &#125;
&#125;
</code></pre>
<h5 id="c-22"><a href="#c-22" class="headerlink" title="c"></a>c</h5><pre><code class="c">PNode findSycle(PNode head) &#123;
    PNode fast = head;
    PNode slow = head;
    while(fast &amp;&amp; fast-&gt;next) &#123;
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        while(slow == fast) &#123;
            PNode index1 = head;
            PNode index2 = fast;
            while(index1 != index2) &#123;
                index1 = index1-&gt;next;
                index2 = index2-&gt;next;
            &#125;
            return index1;
        &#125;
    &#125;
    return NULL;
&#125;
</code></pre>
<h5 id="js-13"><a href="#js-13" class="headerlink" title="js"></a>js</h5><pre><code class="js">function findSycle(head) &#123;
    let fast = head;
    let slow = head;
    while(fast &amp;&amp; fast.next) &#123;
        slow = slow.next;
        fast = fast.next.next;
        while(slow == fast) &#123;
            let index1 = head;
            let index2 = fast;
            while(index1 != index2) &#123;
                index1 = index1.next;
                index2 = index2.next;
            &#125;
            return index1;
        &#125;
    &#125;
    return NULL;
&#125;
</code></pre>
<h5 id="java-13"><a href="#java-13" class="headerlink" title="java"></a>java</h5><pre><code class="java">public ListNode findSycle(ListNode head) &#123;
    ListNode slow = head;
    ListNode fast = head;
    while(fast &amp;&amp; fast.next) &#123;
        slow = slow.next;
        fast = fast.next.next;
        while(slow == fast) &#123;
            ListNode index1 = head;
            ListNode index2 = fast;
            while(index1 != index2) &#123;
                index1 = index1.next;
                index2 = index2.next;
            &#125;
            return index1;
        &#125;
    &#125;
    return NULL;
&#125;
</code></pre>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>C++ 给提供了如下三种可用的数据结构：</p>
<ul>
<li>std::set</li>
<li>std::multiset</li>
<li>std::unordered_set</li>
</ul>
<h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><p>“eat -&gt; “ate”</p>
<h5 id="c-23"><a href="#c-23" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">bool wordDiff(String s, String t) &#123;
    int word[26] = &#123;0&#125;;
    for(int i = 0; i &lt; s.sise(); i ++) &#123;
        word[s[i] - &#39;a&#39;] ++;
    &#125;
    for(int i = 0; i &lt; t.sizs(); i ++) &#123;
        word[t[i] - &#39;a&#39;] --;
    &#125;
       for(int i = 0; i &lt; 26; i ++) &#123;
        if(word[i] != 0) &#123;
            return false;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h5 id="c-24"><a href="#c-24" class="headerlink" title="c"></a>c</h5><pre><code class="c">int wordDiff(char* s, char* t) &#123;
    int word[26] = &#123;0&#125;;
    int slen = strlen(s);
    int tlen = strlen(t);
    for(int i = 0; i &lt; slen; i ++) &#123;
        word[s[i] - &#39;a&#39;] ++;
    &#125;
    for(int i = 0; i &lt; tlen; t ++) &#123;
        word[s[i] - &#39;a&#39;] --;
    &#125;
    for(int i = 0; i &lt; 26; i ++) &#123;
        if(word[i] != 0) &#123;
           return -1;
        &#125;
    &#125;
    return 1;
&#125;
</code></pre>
<h5 id="js-14"><a href="#js-14" class="headerlink" title="js"></a>js</h5><pre><code class="js">function wordDiff(s, t) &#123;
    let word = new Array(26).fill(0);
    let basea = &#39;a&#39;.charCodeAt();
    for(int o of s) &#123;
           word[o.charCodeAt() - basea] ++;
    &#125;
    for(int o of t) &#123;
        if(word[o.charCodeAt - basea] == 0) return false;
         word[o.charCodeAt - basea] --;   
    &#125;
    return true;
&#125;
</code></pre>
<h5 id="java-14"><a href="#java-14" class="headerlink" title="java"></a>java</h5><pre><code class="java">public bool wordDiff(String s, String t) &#123;
    int[] word = new int[26];
    for(int i = 0; i &lt; s.length; i ++) &#123;
        word[s.charAt(i) -- &#39;a&#39;] ++;
    &#125;
    for(int i = 0; i &lt; t.length; i ++) &#123;
           if(! word[t.charAt(i) -- &#39;a&#39;]) return false;
        word[t.chAt(i) -- &#39;a&#39;] --;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="两个数组交集"><a href="#两个数组交集" class="headerlink" title="两个数组交集"></a>两个数组交集</h2><h4 id="没有范围限制的时候"><a href="#没有范围限制的时候" class="headerlink" title="没有范围限制的时候"></a>没有范围限制的时候</h4><h5 id="c-25"><a href="#c-25" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
    unordered_set&lt;int&gt; result_set;
    //在set中放入整个第一数组
    unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end());
    for(int nums : nums2) &#123;
        //数组2的元素在set中找到，则放入结果set
        if(nums_set.find(nums) != nums_set.end()) &#123;
            result_set.insert(nums);
        &#125;
    &#125;
    return vector&lt;int&gt; (result_set.begin(), result_set.end());
&#125;
</code></pre>
<h5 id="js-15"><a href="#js-15" class="headerlink" title="js"></a>js</h5><pre><code class="js">function intersection(nums1, nums2) &#123;
    let nums_set = new Set(nums1);
    let result_set = new Set():
    for(let i = 0; i &lt; nums2.length; i ++) &#123;
        nums_set.has(nums2[i]) &amp;&amp; result_set.add(nums2[i]);
    &#125;
    return Array.from(result_set);
&#125;
</code></pre>
<h5 id="java-15"><a href="#java-15" class="headerlink" title="java"></a>java</h5><pre><code class="java">public int[] intersection(int[] nums1, int[] nums2) &#123;
    Set&lt;Integer&gt; result_set = new Set&lt;&gt;();
    Set&lt;Integer&gt; nums_set = new Set&lt;&gt;();
    for(int i = 0; i &lt; nums1.length; i ++) &#123;
        nums_set.add(nums1[i]);
    &#125;
    for(int i = 0; i &lt; nums2.length; i ++) &#123;
        if(nums_set.contains(nums2[i])) &#123;
            result_set.add(nums2[i]);
        &#125;
    &#125;
    //将结果几何转为数组
    return result_set.stream().mapToInt(x -&gt; x).toArray();
&#125;
</code></pre>
<h4 id="有范围限制时"><a href="#有范围限制时" class="headerlink" title="有范围限制时"></a>有范围限制时</h4><h5 id="c-26"><a href="#c-26" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; shu1, vector&lt;int&gt;&amp; shu2) &#123;
    unorded_set&lt;int&gt; reult_set;
    int hash[1005] = &#123;0&#125;;
    for(int num : shu1) &#123;
        hash[num] = 1;
    &#125;
    for(int num : shu2) &#123;
        if(hash[num] == 1) &#123;
            result_set.insert(num);
        &#125; 
    &#125;
    return vector&lt;int&gt; (result_set.begin(), result_set.end());
&#125;
int main() &#123;
       vector&lt;int&gt; shu1 = &#123;&#125;;
    intersection(shu1);
&#125;
</code></pre>
<h5 id="c-27"><a href="#c-27" class="headerlink" title="c"></a>c</h5><pre><code class="c">int* intersection(int* nums1, int size1, int* nums2, int size2, int* returnSize) &#123;
    int hash[1005] = &#123;0&#125;;
    int lessSize = size1 &gt; size2 ? size2 : size1;
    int* result = (int *) malloc(sizeof(int) * lessSize);
    int resIndex = 0;
    int i;
    for(i = 0; i &lt; size1; i ++) &#123;
        hash[nums1[i]] ++;
    &#125;
    for(i = 0; i &lt; size2; i ++) &#123;
        if(hash[nums2[i]] != 0) &#123;
            result[resIndex] = nums2[i];
            resIndex ++;
            //防止结果数组内数据重复
            hash[nums2[i]] = 0;
        &#125;
    &#125;
    //返回结果数组长度
    *returnSize = resIndex;
    return result;
&#125;
</code></pre>
<h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<h5 id="c-28"><a href="#c-28" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int getSum(int n) &#123;
    int sum &#123;0&#125;;
    while(n) &#123;
        sum += (n % 10) * (n % 10);
        n = n / 10;
    &#125;
    return sum;
&#125;
bool isHappy(int n) &#123;
   int sum = 0;
   unordered_set&lt;int&gt; = set; 
    while(1) &#123;
        sum = getSum(n);
        if (sum == 1) &#123;
            return true;
        &#125;
        // 查找存储在 set 内的值，若找到怎说明陷入了循环
           if (set.find(sum) != set.end()) &#123;
            retrun false;
        &#125;else &#123;
            set.insert(sum);
        &#125;
        n = sum;
    &#125;
&#125;
</code></pre>
<h5 id="c-29"><a href="#c-29" class="headerlink" title="c"></a>c</h5><p>使用环形链表方式，如果遇到闭环则表示不为快乐数</p>
<pre><code class="c">int getSum(int n) &#123;
    int sum = 0;
    while(n) &#123;
        sum += (n % 10) * (n % 10);
           n = n / 10;
    &#125;
    return sum;
&#125;
int isHappy(int n) &#123;
    if(getSum(n) == 1) return 1;
    int a = getSum(n);
    int b = getSum(getSum(n));
    while(a != 1 &amp;&amp; a != b &amp;&amp; getSum(b)) &#123;
        a = getSum(a);
        b = getSum(getSum(b));
    &#125;
    b == 1 ? return 1 : return -1;
&#125;
</code></pre>
<h5 id="js-16"><a href="#js-16" class="headerlink" title="js"></a>js</h5><pre><code class="js">function isHappy(n) &#123;
    let newSet = new Set();
    while(n != 1 &amp;&amp; !newSet.has(n)) &#123;
        newSet.add(n);
        n = getSum(n);
    &#125;
    return n == 1;
&#125;
</code></pre>
<h5 id="java-16"><a href="#java-16" class="headerlink" title="java"></a>java</h5><pre><code class="java">public isHappy(int n) &#123;
    Set&lt;Integer&gt; newSet = new HashSet&lt;&gt;();
    while(n != 1 &amp;&amp; !newSet.contains(n)) &#123;
        newSet.add(n);
        n = getSum(n);
    &#125;
&#125;
</code></pre>
<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p><strong>示例:</strong></p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9</p>
<p>所以返回 [0, 1]</p>
<h5 id="c-30"><a href="#c-30" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">vector&lt;int&gt; doubleSum(vector&lt;int&gt;&amp; num, int target) &#123;
    unordered_map&lt;int, int&gt; map;
    for(int i = 0; i &lt; num.size(), i ++) &#123;
        auto shu = map.find(target - num[i]);
        if(shu != map.end()) &#123;
            //在map内找到直接返回两个数
            //shu-&gt;second 返回值; -&gt;first 返回键
            return &#123;shu-&gt;second, i&#125;;
        &#125;
        //未找到则添加
        map.insert(pair&lt;int, int&gt; (num[i], i));
    &#125;
&#125;
</code></pre>
<h5 id="c-31"><a href="#c-31" class="headerlink" title="c"></a>c</h5><p>利用库函数定义 map </p>
<pre><code class="c">typedef struct &#123;
    int key;
    int value;
    UT_hash_handle hh; // make this structure hashable
&#125; map;

map* hashMap = NULL;

 void hashMapAdd(int key, int value)&#123;
     map* s;
     // key already in the hash?
     HASH_FIND_INT(hashMap, &amp;key, s);
     if(s == NULL)&#123;
         s = (map*)malloc(sizeof(map));
         s -&gt; key = key;
         HASH_ADD_INT(hashMap, key, s);
     &#125;
     s -&gt; value = value;
 &#125;

map* hashMapFind(int key)&#123;
     map* s;
     // *s: output pointer
     HASH_FIND_INT(hashMap, &amp;key, s);   
     return s;
 &#125;

 void hashMapCleanup()&#123;
     map* cur, *tmp;
     HASH_ITER(hh, hashMap, cur, tmp)&#123;
         HASH_DEL(hashMap, cur);
         free(cur);
     &#125;
 &#125;

 void hashPrint()&#123;
     map* s;
     for(s = hashMap; s != NULL; s=(map*)(s -&gt; hh.next))&#123;
         printf(&quot;key %d, value %d\n&quot;, s -&gt; key, s -&gt; value);
     &#125;
 &#125;
int* doubleSum(int* nums, int numSize, int target, int* reSize) &#123;
    int* result;
    map* hashMapRes;
       result = (int *) malloc(sizeof(int) * 2);
       hashMap = NULL;
    for(int i = 0; i &lt; numSize; i ++) &#123;
        hashMapRes = hashMapFind(target - nums[i]);
        if(hashMapRes &amp;&amp; hashMapRes-&gt;value != i) &#123;
            result[0] = i;
            result[1] =    hashMapRes-&gt;value;
            *reSize = 2;
            return result;
        &#125;else &#123;
            hashMapAdd(num[i], i);
        &#125;
    &#125;
    hashMapClearup();
    return NULL;
&#125;
</code></pre>
<h5 id="js-17"><a href="#js-17" class="headerlink" title="js"></a>js</h5><pre><code class="js">function doubleSum(nums, target) &#123;
    let hash = &#123;&#125;;
    for(let i = 0; i &lt; nums.length; i ++) &#123;
        if(hash[target - nums[i]] !== undefined) &#123;
            return [nums[target - nums[i]], i];
        &#125;
           hash[nums[i]] = i;
    &#125;
    return &#123;&#125;;
&#125;
</code></pre>
<h5 id="java-17"><a href="#java-17" class="headerlink" title="java"></a>java</h5><pre><code class="java">public int[] doubleSum(int[] nums, int target) &#123;
    int[] result = new int[2];
    Map&lt;Integer, Integer&gt; resMap = new HashMap&lt;&gt; ();
    for(int i = 0; i &lt; nums.length; i ++) &#123;
        int findNum = target - nums[i];
        if(resMap.contains(findNum)) &#123;
               result[0] = i;
            result[1] = get(findNum);
            break;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h2 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h2><p>输入:</p>
<ul>
<li>A = [ 1, 2]</li>
<li>B = [-2,-1]</li>
<li>C = [-1, 2]</li>
<li>D = [ 0, 2]</li>
</ul>
<p>输出:</p>
<p>2</p>
<p><strong>解释:</strong></p>
<p>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li>
</ol>
<h5 id="c-32"><a href="#c-32" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">int fourSum(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;
    unordered_map&lt;int, int&gt; umap;
    int count;
    for(int a : A) &#123;
           for(int b : B) &#123;
            //键为 a + b 值为 1
            //umap.insert(pair&lt;int , int&gt; ((a + b), 1);
            umap[a + b] ++;
        &#125;
    &#125;
    for(int c : C) &#123;
        for(int d : D) &#123;
            int temp = c + d;
            if(map.find(0 - temp) != umap.end()) &#123;
                count += umap[0 - temp];
            &#125;
        &#125;
    &#125;
    return count;
&#125;
</code></pre>
<h5 id="js-18"><a href="#js-18" class="headerlink" title="js"></a>js</h5><pre><code class="js">function fourSum(A, B, C, D) &#123;
    let nmap = new Map();
    let count = 0;
    for(let a of A) &#123;
        for(let b of B) &#123;
            let sum = a + b;
            //设置默认值，获取值并且增加1，
            nmap.set(sum, (nmap.get(sum) || 0) + 1);
        &#125;
    &#125;
    for(let c of C) &#123;
        for(let d of D) &#123;
            let sum = c + d;
            if(nmap.get(0 - sum)) &#123;
                count += nmap.get(sum);
            &#125;
        &#125;
    &#125;
    return count;
&#125;
</code></pre>
<h5 id="java-18"><a href="#java-18" class="headerlink" title="java"></a>java</h5><pre><code class="java">public int fourSum(int[] A, int[] B, int[] C, int[] D) &#123;
    Map&lt;Integer, Integer&gt; nmap = new HashMap&lt;&gt;();
    int count = 0;
    for(int a : A) &#123;
        for(int b : B) &#123;
            int sum = a + b;
            if(nmap.containsKey(sum)) &#123;
                nmap.put(sum, nmap.get(sum) + 1);
            &#125;else &#123;
                nmap.put(sum, 1);
            &#125;
        &#125;
    &#125;
    for(int c : C) &#123;
        for(int d : D) &#123;
            int sum = c + d;
            if(nmap.containsKey(0 - sum)) &#123;
                count += nmap.get(0 - sum);
            &#125;
        &#125;
    &#125;
    return count;
&#125;
</code></pre>
<h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<h5 id="c-33"><a href="#c-33" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">bool mes(string ransomNote, string magazine) &#123;
    int word[26] &#123;0&#125;;
    if(ransomNote.size() &gt; magazine.size()) &#123;
        return false;
    &#125;
    for(int i = 0; i &lt; ransomNote.length(); i ++) &#123;
        word[ransomNote[i] - &#39;a&#39;] ++;
    &#125;
    for(int i = 0; i &lt; magazine.length(); i ++) &#123;
        word[magazine[i] - &#39;a&#39;]--;
        //判断方式一
        if(word[magazine[i] - &#39;a&#39;] &lt; 0) &#123;
            return false;
        &#125;
    &#125;
    //判断方式二
    for(int i = 0; i &lt; 26; i ++) &#123;
        if(word[i] == 1) &#123;
            return false;
        &#125;
    &#125;
    
    return true;
&#125;
</code></pre>
<h5 id="js-19"><a href="#js-19" class="headerlink" title="js"></a>js</h5><pre><code class="js">function mes(ransomNote, magazine) &#123;
    let word[26] = new Array(26).fill(0);
    let base = &#39;a&#39;.charCodeAt();
       for(let o of ransomNote) &#123;
        word[o.charCodeAt() - base] ++;
    &#125;
    for(let o of magazine) &#123;
        word[o.charCodeAt - base] --;
        if(! word[o.charCodeAt - base]) return false;
    &#125;
    return true;
&#125;
</code></pre>
<h5 id="java-19"><a href="#java-19" class="headerlink" title="java"></a>java</h5><pre><code class="java">public bool mes(String ransomNote, String magazine) &#123;
    int[] word = new int[26];
    for(char o : ransomNote.toCharArray()) &#123;
        word[o - &#39;a&#39;] ++;
    &#125;
    for(char o : magazine.toCharArray()) &#123;
        word[o - &#39;a&#39;] --;
        if(!word[o - &#39;a&#39;]) return false;
    &#125;
    return true;
&#125;
</code></pre>
<h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p>示例：</p>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p>
<h4 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h4><pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; num) &#123;
   vector&lt;vector&lt;int&gt;&gt; result;    
    //排序    
    sort(num.begin(), num.end());                                                                            
    for(int i = 0; i &lt; num.size(); i ++) &#123;
        if(num[i] &gt; 0) &#123;
            break;
        &#125;
        //去重,保证3个数不与之前的重复， 防止在下一循环重新计算在内
        if(i &gt; 0 &amp;&amp; num[i] == num[i - 1]) &#123;
            continue;
        &#125;
        unordered_set&lt;int&gt; set;
        for(int j = 0; j &lt; num.size(); j ++) &#123;
            if(j &gt; i + 2 &amp;&amp; num[i] == num[j - 1] &amp;&amp;
                  num[j - 1] == num[j - 2]) &#123;
                continue;
            &#125;
            int c = 0 - (num[i] + num[j]);
               if(set.find(c) != set.end()) &#123;
                result.push_back(&#123;num[i], num[j], c&#125;);
                set.erase(c);
            &#125;else &#123;
                set.insert(num[j]);
            &#125;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h4 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h4><h5 id="c-34"><a href="#c-34" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; num) &#123;
    //排序
    sort(num.begin(), num.end());
    vector&lt;vector&lt;int&gt;&gt; result;
    for(int i = 0; i &lt; num.sizes(); i ++) &#123;
        if(num[i] &gt; 0) &#123;
            break;
        &#125;
        //去重
        if(i &gt; 0 &amp;&amp; num[i] &lt; num[i - 1]) &#123;
            continue;
        &#125;
        int left = i + 1;
        int right = num.size() - 1;
           while(left &lt; right) &#123;
            if((num[left] + num[i] + num[right]) &gt; 0) &#123;
                right --;
            &#125;else if((num[left] + num[i] + num[right]) &lt; 0) &#123;
                left ++;
            &#125;else &#123;
                result.push_back(&#123;num[left], num[i], num[right]&#125;);
                //去重
                while(left &lt; right &amp;&amp; num[left] == num[left + 1])
                    left ++;
                while(left &lt; right &amp;&amp; num[right] == num[right - 1])
                    right --;
                //同时向内缩进
                left ++;
                right --;
            &#125;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h5 id="c-35"><a href="#c-35" class="headerlink" title="c"></a>c</h5><pre><code class="c">//qsort辅助cmp函数
int cmp(const void* ptr1, const void* ptr2) &#123;
    return *((int*)ptr1) &gt; *((int*)ptr2);
&#125;
int** threeSum(int* nums, int numsSize, int returnSize) &#123;
    int** result = (int **) malloc(sizeof(int *) * 1800);
    int count = 0;
    //对nums数组进行排序
    qsort(nums, numsSize, sizeof(int), cmp);
    for(int i = 0; i &lt; numsSize; i ++) &#123;
        if(nums[i] &gt; 0) &#123;
            break;
        &#125;
        //去重
        if(i &gt; 0 &amp;&amp; nums[i] - nums[i - 1]) &#123;
            continue;
        &#125;
        int left = i + 1;
        int right = numsSize - 1;
        while(left &lt; right) &#123;
            int sum = nums[left] + nums[i] + nums[right];
            if(sum &gt; 0) &#123;
                right --;
            &#125;else if(sum &lt; 0) &#123;
                left ++;
            &#125;else &#123;
                int* res = (int *) malloc(sizeof(int) * 3);
                res[0] = nums[i];
                res[1] = nums[left];
                res[2] = nums[right];
                result[count ++] = res;
                free(res);
                //数组去重
                while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right --;
                while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++;
                right --;
                left ++;
            &#125;
        &#125;
    &#125;
    *returnSize = count;
    return result;
&#125;
</code></pre>
<h5 id="js-20"><a href="#js-20" class="headerlink" title="js"></a>js</h5><pre><code class="js">function threeSum(nums) &#123;
    let result = new Array(new Array()).fill(0);
    //升序排序
    nums.sort((a, b) =&gt; a - b);
    for(let i = 0; i &lt; nums.length; i ++) &#123;
        if(nums[i] &gt; 0) &#123;
            break;
        &#125;
        if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
        let left = i + 1;
        let right = nums.length - 1;
        while(left &lt; right) &#123;
            if(nums[left] + nums[right] + nums[i] &lt; 0) &#123;
                left ++;
            &#125;else if(nums[left] + nums[right] + nums[i] &gt; 0) &#123;
                right --;
            &#125;else &#123;
                result.push([nums[left], nums[right], nums[i]]);
                while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++;
                while(left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right --;
                left ++;
                right --;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="java-20"><a href="#java-20" class="headerlink" title="java"></a>java</h5><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt; ();
    Arrays.sort(nums);
    for(int i = 0; i &lt; nums.length; i ++) &#123;
        if(nums[i] &gt; 0) &#123;
            break;
        &#125;
        if(i &gt; 0 &amp;&amp; nums[i] - nums[i - 1]) continue;
        int left = i + 1;
        int right = nums.length - 1;
        while(left &lt; right) &#123;
            if(nums[i] + nums[left] + nums[right] &gt; 0) &#123;
                right --;
            &#125;else if(nums[i] + nums[left] + nums[right] &lt; 0) &#123;
                left ++;
            &#125;else &#123;
                result.add(Arrys.asList(nums[i], nums[left], nums[right]));
                while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++;
                while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right --;
                left ++;
                right --;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="四数之和-1"><a href="#四数之和-1" class="headerlink" title="四数之和"></a>四数之和</h2><h4 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h4><h5 id="c-36"><a href="#c-36" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; num, int target) &#123;
    //排序 
    sort(num.begin(), num.end());
       vector&lt;vector&lt;int&gt;&gt; result;
    for(int i = 0; i &lt; num.size(); i ++) &#123;
        //剪枝
        if(num[i] &gt; target &amp;&amp; num[i] &gt;= 0) &#123;
               break;
        &#125;
        //去重
        if(i &gt; 0 &amp;&amp; num[i] == num[i - 1]) &#123;
            continue;
        &#125;
        for(int j = 0; j &lt; num.size(); j ++) &#123;
            //2次剪枝
            if(num[i] + num[j] &gt; target &amp;&amp; num[i] + num[j] &gt;= 0) &#123;
                break;
            &#125;
            //去重
            if(j &gt; i + 1 &amp;&amp; num[j] == num[j - 1]) &#123;
                continue;
            &#125; 
               int left = j + 1;
            int right = num.size() - 1;
            while(left &lt; right) &#123;
                //相加会超限，使用转换
                if((long) num[i] + num[j] + num[left] + num[right] &gt; target) &#123;
                    right --;
                &#125; else if((long) num[i]  + num[j] + num[left] + num[right] &lt; target) &#123;
                    left ++;
                &#125; else &#123;
                    result.push_back(vector&lt;int&gt; &#123;num[i], num[j], num[left], num[right]&#125;);
                    //去重
                    while(left &lt; right &amp;&amp; num[left] == num[left + 1])
                           left ++;
                    while(left &lt; right &amp;&amp; num[right] == num[right - 1])
                        right --;
                    
                    right --;
                       left ++;
                &#125;
            &#125;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h5 id="c-37"><a href="#c-37" class="headerlink" title="c"></a>c</h5><pre><code class="c">//qsort辅助cmp函数
int cmp(const void* ptr1, const void* ptr2) &#123;
    return *((int*)ptr1) &gt; *((int*)ptr2);
&#125;
int** fourSum(int* nums, int numsSize, int* returnSize, int target) &#123;
    int** result = (int **) malloc(sizeof(int *) * 1800);
    int count = 0;
    //对nums数组进行排序
    qsort(nums, numsSize, sizeof(int), cmp);
    for(int i = 0; i &lt; numsSize; i ++) &#123;
        //剪枝
        if(nums[i] &gt; target &amp;&amp; nums[i] &gt;= 0) break;
        //去重
        if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;
            continue;
        &#125;
        for(int j = i + 1; j &lt; numsSize; j ++) &#123;
            //剪枝
            if(nums[i] + nums[j] &gt; target &amp;&amp; nums[j] &gt;= 0) &#123;
                break;
            &#125;
            //去重
            if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;
            int left = j + 1;
            int right = numsSize - 1;
            while(left &lt; right) &#123;
                if(nums[i] + nums[j] + nums[left] +nums[right] &gt; target) &#123;
                    right --;
                &#125;else if(nums[i] + nums[j] + nums[left] +nums[right] &lt; target) &#123;
                    left ++;
                &#125;else &#123;
                    int* res = (int *) malloc(sizeof(int) * 4);
                    res[0] = nums[i];
                    res[1] = nums[j];
                    res[2] = nums[left];
                    res[3] = nums[right];
                    result[count ++] = res;
                    //去重
                    while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++;
                    while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right --;
                    left ++;
                    right --;
                &#125;
            &#125;
        &#125;
    &#125;
    *returnSize = count;
    return result;
&#125;
</code></pre>
<h5 id="js-21"><a href="#js-21" class="headerlink" title="js"></a>js</h5><pre><code class="js">function fourSum(nums, target) &#123;
    let result = new Array(new Array(4)).fill(0);
    for(let i = 0; i &lt; nums.lenght; i ++) &#123;
        //剪枝
        if(nums[i] &gt; target &amp;&amp; nums &gt;= 0) break;
        //去重
        if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
        for(let j = i + 1; j &lt; nums.length; j ++) &#123;
            //剪枝
            if(nums[i] + nums[j] &gt; target &amp;&amp; nums[j] &gt;= 0) break;
            //去重
            if(j &gt; i + 1; nums[j] == nums[j - 1]) continue;
            let left = j + 1;
            let right = nums.length - 1;
               while(left &lt; right) &#123;
                if(nums[i] + nums[j] + nums[left] + nums[right] &gt; 0) &#123;
                    right --;
                &#125;else if(nums[i] + nums[j] + nums[left] + nums[right] &lt; 0) &#123;
                    left ++;
                &#125;else &#123;
                       result.push([nums[i], nums[j], nums[left], nums[right]]);
                    //去重
                    while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++;
                    while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right --;
                    left ++:
                    right --;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h5 id="java-21"><a href="#java-21" class="headerlink" title="java"></a>java</h5><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;
    List&lt;List&lt;Integer&gt; result = new ArrayList&lt;&gt; ();
    for(int i = 0; i &lt; nums.length; i ++) &#123;
        //剪枝
        if(nums[i] &gt; target &amp;&amp; nums[i] &gt;= 0) break;
        //去重
        if(i &gt; 0 &amp;&amp; nums[i] == num[i - 1]) continue;
        for(int j = i + 1; j &lt; nums.length; j ++) &#123;
            //剪枝
            if(nums[i] + nums[j] &gt; target &amp;&amp; nums[j] &gt;= 0) break;
            //去重
            if(j &gt; i; nums[j] == nums[j - 1]) continue;
            int left = j + 1;
            int right = 0;
            while(left &lt; right) &#123;
                if(nums[i] + nums[j] + nums[left] + nums[right] &gt; 0) &#123;
                    right --;
                &#125;else if(nums[i] + nums[j] + nums[left] + nums[right] &lt; 0) &#123;
                    left ++;
                &#125;else &#123;
                    result.add(Array.asList(nums[i], nums[j], nums[left], nums[right]));
                       while(left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left ++;
                    while(left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right --;
                    left ++;
                    right --;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><pre><code class="c++">void reverse(vector&lt;char&gt;&amp; charN) &#123;
    for(int i = 0, int j = charN.size() - 1; i &lt; charN.size() / 2; i ++, j --) &#123;
        int temp = charN[i];
        charN[i] = charN[j];
        charN[j] = temp;
        /*
            位运算,异或
            charN[i] ^= charN[j];
            charN[j] ^= charN[i];
            charN[i] ^= charN[j];
        */
    &#125;
&#125;
</code></pre>
<h2 id="反转字符串-1"><a href="#反转字符串-1" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。</p>
<p>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例:</p>
<p>输入: s = “abcdefg”, k = 2<br>输出: “bacdfeg”</p>
<h5 id="c-38"><a href="#c-38" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">void reverse(string&amp; s, int start, int end) &#123;
    for(int i = start, j = end; i &lt; s.size() / 2; i ++, j --) &#123;
        int temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    &#125;
&#125; 
string reverseString(string s, int k) &#123;
    for(int i = 0; i &lt; s.size; i += (2 * k)) &#123;
        //判断尾部的字符串是否大于K, 大于则相加后小于size
        if(i + k &lt;= s.size()) &#123;
            reverse(s, i, i + k);
            continue;
        &#125;
        //尾部字符串小于K， 相加后大于size
        reverse(s, i, size() - 1);
    &#125;
&#125;
</code></pre>
<h4 id="双指针法-4"><a href="#双指针法-4" class="headerlink" title="双指针法"></a>双指针法</h4><h5 id="c-39"><a href="#c-39" class="headerlink" title="c"></a>c</h5><pre><code class="c">char* reverse(char* s, int k) &#123;
    int len = strlen(s);
    for(int i = 0; i &lt; len; i += (2 * K)) &#123;
        int left = i;
        int right = i + k - 1;
        while(left &lt; right) &#123;
            int temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left ++;
            right --;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="js-22"><a href="#js-22" class="headerlink" title="js"></a>js</h5><pre><code class="js">function reverse(s, k) &#123;
    for(let i = 0; i &lt; s.length; i += 2 * k) &#123;
        let left = i;
        let right = i + k - 1;
        while(left &lt; right) &#123;
            let temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left ++;
               right --;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="java-22"><a href="#java-22" class="headerlink" title="java"></a>java</h5><pre><code class="java">public void reverse(String s, int k) &#123;
    for(int i = 0; i &lt; s.length; i += 2 * k) &#123;
        int left = i;
        int right = i + k - 1;
        while(left &lt; right) &#123;
            int temp = s[left];
            s[left ++] = s[right];
            s[right ++] = temp;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1： 输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
<h5 id="c-40"><a href="#c-40" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">string replaceSpace(string s) &#123;
    int oldSize = s.size();
    int count&#123;0&#125;;
    //计算空格数量
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] == &#39; &#39;) &#123;
            count ++;
        &#125;
    &#125;
    //重新分配内存
    s.resize(malloc(oldSize + (count * 2)));
    int newSize = s.size();
    for(int i = oledSize - 1, j = newSize - 1; i &lt; j; i --, j --) &#123;
        if(s[i] == &#39; &#39;) &#123;
            s[j] = &#39;0&#39;;
            s[j - 1] = &#39;2&#39;;
            s[j - 2] = &#39;%&#39;;
            //跳过填充
            j -= 2;
        &#125;else &#123;
            s[j] = s[i];
        &#125;
    &#125;
    return s;
&#125;
</code></pre>
<h5 id="C语言-6"><a href="#C语言-6" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">char* replaceSpace(char* s) &#123;
    int oldSize = strlen(s);
    int count = 0;
    for(int i = 0; i &lt; oldeSize; i ++) &#123;
        if(s[i] == &#39; &#39;) &#123;
            count ++;
        &#125;
    &#125;
    int newSize = oldSize + 2 * count;
    char* news = (char *) malloc(sizeof(char) * newSize + 1);
    for(int i = oldSize - 1, int j = newSize - 1; i &lt; j; i --, j --) &#123;
        if(s[i] == &#39; &#39;) &#123;
            news[j] = &#39;0&#39;;
            news[j - 1] = &#39;2&#39;;
            news[j - 2] = &#39;%&#39;;
            j -= 2;
        &#125;else &#123;
            news[j] = s[i];
        &#125;
    &#125;
    news[newSize] = &#39;\0&#39;;
    return news;
&#125;
</code></pre>
<h5 id="js-23"><a href="#js-23" class="headerlink" title="js"></a>js</h5><pre><code class="js">function replaceSpace(s) &#123;
    let array = Array.from(s);
    //计算空格
    let count = 0;
    for(let i = 0; i &lt; s.length; i ++) &#123;
        if(s[i] == &#39; &#39;) count ++;
    &#125;
    for(let i = s.length - 1, j = (s.length + count * 2); i &gt;= 0; i --, j --) &#123;
        if(s[i] == &#39; &#39;) &#123;
            s[j] = &#39;0&#39;;
               s[j - 1] = &#39;2&#39;;
            s[j - 2] = &#39;%&#39;;
            j -= 2;
        &#125;else &#123;
            s[j] = s[i];
        &#125;
    &#125;
    return array.join(&#39;&#39;);
&#125;
</code></pre>
<h5 id="java-23"><a href="#java-23" class="headerlink" title="java"></a>java</h5><pre><code class="java">public String replaceSpace(String s) &#123;
       if(s == NULL || s.length() == 0) return s;
    StringBuilder str = new StringBuilder(s);
    //扩容两个空格的位置
    for(char o : s) &#123;
        if(o == &#39; &#39;) str.append(&quot;  &quot;);
    &#125;
    int oldSize = s.length();
    //扩容
    s += str.toString();
    char[] charArray = s.toCharArray();
    for(int i = oldSize - 1, j = s.length() - 1; i &gt; 0; i --, j --) &#123;
        if(charArray[i] == &#39; &#39;) &#123;
            charArray[j] = &#39;0&#39;;
            charArray[j - 1] = &#39;2&#39;;
            charArray[j - 2] = &#39;%&#39;;
            j -= 2;
        &#125;else &#123;
            charArray[j] = charArray[i];
        &#125;
    &#125;
    return String(charArray);
&#125;
</code></pre>
<h2 id="反转单词"><a href="#反转单词" class="headerlink" title="反转单词"></a>反转单词</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p>
<p>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p>
<p>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p>
<p>思路: 去除多余空格 -&gt; 翻转字符串 -&gt; 翻转单词</p>
<h5 id="c-41"><a href="#c-41" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">//反转字符
void reverse(string&amp; s, int start, int end) &#123;
    for(int i = start, j = end; i &lt; j; i ++, j --) &#123;
        s[i] ^= s[j];
        s[j] ^= s[i];
        s[i] ^= s[j];
    &#125;
&#125;
//移除多余空格
void removeExtraSpaces(string&amp; s) &#123;
       int slow &#123;0&#125;;
    //快指针移动
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] != &#39; &#39;) &#123;
               //手动添加一个空格
            if(slow != 0) s[slow ++] = &#39; &#39;;
            //将非空格赋值
               while(i &lt; s.size() &amp;&amp; s[i] != &#39; &#39;) &#123;
                s[slow] = s[i];
                   slow ++;
                i ++;
            &#125;
        &#125;
    &#125;
    s.resize(slow);
&#125;
string reverseWords(string&amp; s) &#123;
    removeExtraSpaces(s);
    reverse(s, 0, s.size() - 1);
    int start &#123;0&#125;;
       //筛选出不为空格的字符进行翻转
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] != &#39; &#39;) &#123;
            while(i &lt; s.size() &amp;&amp; s[i] != &#39; &#39;) &#123;
                i ++;
            &#125;
            reverse(s, start, i - 1);
            start = i + 1;
        &#125;
    &#125;
    return s;
&#125;
</code></pre>
<h5 id="c-42"><a href="#c-42" class="headerlink" title="c"></a>c</h5><pre><code class="c">//去除多余空格
void removeExtraSpaces(char* s) &#123;
    int len = strlen(s);
    int slow = 0, fast = 0;
    for(; fast &lt; len; fast ++) &#123;
        if(s[fast] != &#39; &#39;) &#123;
            //添加空格
            if(slow != 0) s[slow ++] = &#39; &#39;;
            //其他字符串复制
            while(fast &lt; len &amp;&amp; s[fast] != &#39; &#39;) &#123;
                s[slow ++] = s[fast ++];
            &#125;
        &#125;
    &#125;
    s[slow] = &#39;\0&#39;;
&#125;
//翻转字符单词
char* reverseWords(char* s) &#123;
    int len = strlen(s);
    //去除多余空格
    removeExtraSpaces(s);
    //全部翻转字符
    reverse(0, len - 1, s);
    //翻转单词
    int start = 0;
    for(int i = 0; i &lt; len; i ++) &#123;
        if(s[i] != &#39; &#39;) &#123;
            while(i &lt; len &amp;&amp; s[i] != &#39; &#39;) &#123;
                i ++;
            &#125;
            reverse(start, i - 1, s);
            //空格的后一个字符
            start = i + 1;
        &#125;
    &#125;
    return s;
&#125;
</code></pre>
<h5 id="js-24"><a href="#js-24" class="headerlink" title="js"></a>js</h5><pre><code class="js">function removeExtraSpaces(s) &#123;
    let fast = 0, slow = 0;
    for(; fast &lt; charA.length; fast ++) &#123;
        if(s[fast] != &#39; &#39;) &#123;
            if(slow != 0) s[slow ++] == &#39; &#39;;
            while(fast &lt; s.length &amp;&amp; s[fast] != &#39; &#39;) &#123;
                s[slow ++] = s[fast ++];
            &#125;
        &#125;
    &#125; 
&#125;
function reverseWord(s) &#123;
    let charA = Array.from(s);
    removeExtraSpaces(charA);
    //翻转所有字符
    reverse(charA, charA.length - 1);
    let start = 0;
    for(int i = 0; i &lt; charA.length; i ++) &#123;
        if(charA[i] != &#39; &#39;) &#123;
            while(i &lt; charA.length &amp;&amp; charA[i] != &#39; &#39;) &#123;
                   //移动到空格
                i ++;
            &#125;
            reverse(charA, start, i - 1);
            start = i + 1;
        &#125;
    &#125;
    //charA.join(&#39;&#39;);
    return charA.toString();
&#125;
</code></pre>
<h5 id="java-24"><a href="#java-24" class="headerlink" title="java"></a>java</h5><pre><code class="java">private void removeExtraSpaces(char[] s) &#123;
    int slow = 0, fast = 0;
    for(; fast &lt; s.length(); fast ++) &#123;
        if(s[slow] != &#39; &#39;) &#123;
            if(slow != 0) s[slow ++] = &#39; &#39;;
            while(fast &lt; s.length() &amp;&amp; s[slow] != &#39; &#39;) &#123;
                s[slow ++] = s[fast ++];
            &#125;
        &#125;
    &#125;
&#125;
public String reverseWords(String s) &#123; 
    char[] charA = s.toCharArray();
    removeExtraSpaces(charA);
    reverse(charA, 0, charA.length());
    int start = 0;
    for(int i = 0; i &lt; charA.length(); i ++) &#123;
        if(charA[i] != &#39; &#39;) &#123;
            while(i &lt; charA.length() &amp;&amp; charA[i] != &#39; &#39;) i ++;
            reverse(charA, start, i - 1);
            start = i + 1;
        &#125;
    &#125;
    return String(charA);
&#125;
</code></pre>
<h2 id="左旋字符串"><a href="#左旋字符串" class="headerlink" title="左旋字符串"></a>左旋字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：<br>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”</p>
<pre><code class="c++">string leftReverse(string s, int n) &#123;
       reverse(s, 0, n);
    reverse(s, n + 1, s.size());
    reverse(s, 0, s.size());
    return s;
&#125;
</code></pre>
<h2 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr"></a>实现strStr</h2><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。</p>
<p>示例 1: 输入: haystack = “hello”, needle = “ll” 输出: 2</p>
<h4 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP  算法"></a>KMP  算法</h4><p>KMP主要应用在字符串匹配上。</p>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p>
<h4 id="最长公共-相同-前后缀？"><a href="#最长公共-相同-前后缀？" class="headerlink" title="最长公共(相同)前后缀？"></a>最长公共(相同)前后缀？</h4><p>文章中字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</p>
<p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</p>
<h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><pre><code class="c++">void getNext(int* next, string s) &#123;
    //初始化, 使 j 为 -1, 判断 i 与 j + 1 
    //方便记录下标， 与回退下标位置
    int j = -1;
    next[0] = j;
    //i 为 1 表示第二个数开始才有最长相同前后缀
    for (int i = 1; i &lt; s.size(); i ++) &#123;
        //如果前后缀不匹配
        while(j &gt;= 0; s[i] != s[j + 1]) &#123;
            //回退
            j = next[j];
        &#125;
           if(s[i] == s[j + 1])  &#123;
            j ++;
        &#125;
        //记录下标，同样表示相同前后缀
        next[i] = j;
    &#125;
&#125;
</code></pre>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="c-43"><a href="#c-43" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">void getNext(int* next, string needle) &#123;
    int j = -1;
    next[0] = j;
    for(int i = 1; i &lt; needle.size(); i ++) &#123;
        while(j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123;
            j = next[j];
        &#125;
        if(s[i] == s[j + 1]) &#123;
            j ++;
        &#125;
        next[i] = j;
    &#125;
&#125;
int strStr(string haystack, string needle) &#123;
    int j = 0;
    if(needle.size() == 0) retrun 0;
    int next[needle.size()] &#123;0&#125;;
    getNext(next);
    for(int i = 0; i &lt; haystack.size(), i ++) &#123;
        while(j &gt; 0 &amp;&amp; haystack[i] != needle[j + 1]) &#123;
            j = next[j];
        &#125;
        if(haystack[i] == needle[j + 1]) &#123;
            j ++;
        &#125;
        //如果j指向了模式串t的末尾，那么就说明模式串t完全匹配文本串s里的某个子串了
        if(j == needle.size() - 1) &#123;
            return (i - needle.size() + 1);
        &#125;
    &#125;
       return -1;
&#125;
</code></pre>
<h5 id="c-44"><a href="#c-44" class="headerlink" title="c"></a>c</h5><pre><code class="c">void getNext(int* next, char* s) &#123;
    //KMP算法
    int j = -1;
    next[0] = j;
    int len = strlen(s);
    for(int i = 0; i &lt; len; i ++) &#123;
        while(j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123;
            //回退
            j = next[j];
        &#125;
        if(s[i] == s[j + 1]) &#123;
            j ++;
        &#125;
        next[i] = j;
    &#125;
&#125;
int strStr(char* haystack, char* needle) &#123;
    int hlen = strlen(haystack);
    int nlen = strlen(needle);
    int j = -1;
    int next[nlen] = 0;
    getNext(next, needle);
    for(int i = 0; i &lt; hlen; i ++) &#123;
        while(j != -1 &amp;&amp; haystack[i] != needle[j + 1]) j = next[j];
        if(haystact[i] == needle[j + 1]) j ++;
        if(j = nlen - 1) return i - nlen + 1;
    &#125;
&#125;
</code></pre>
<h5 id="js-25"><a href="#js-25" class="headerlink" title="js"></a>js</h5><pre><code class="js">function getNext(next, s) &#123;
    let j = -1;
    next[0] = j;
    for(let i = 0; i &lt; s.length; i ++) &#123;
        while(j != -1 &amp;&amp; s[i] != s[j + 1]) j = next[-1];
        if(s[i] == s[j + 1]) j ++;
        next[i] = j;
    &#125;
&#125;
function strStr(haystack, needle) &#123;
    let j = -1;
    let next = new Array(needle.length).fill(0);
    getNext(next, needle);
    for(int i = 0; i &lt; haystack.length; i ++) &#123;
        while(j != -1 &amp;&amp; haystack[i] != needle[j + 1]) j = next[j];
        if(haystack[i] == needle[j + 1]) j ++;
        if(j == needle.length - 1) return i - needle + 1;
    &#125;
&#125;
</code></pre>
<h5 id="java-25"><a href="#java-25" class="headerlink" title="java"></a>java</h5><pre><code class="java">private void getNext(int[] next, String s) &#123;
    char[] charA = s.toCharArray();
    int j = -1;
    next[0] = j;
    for(int i = 0; i &lt; charA.length(); i ++) &#123;
        while(j != -1 &amp;&amp; charA[i] != charA[j + 1]) j = next[j];
        if(charA[i] == charA[j + 1]) j ++;
        next[i] = j;
    &#125;
&#125;
public int strStr(String haystack, String needle) &#123;
    char[] hchar = haystack.toCharArray();
    char[] nchar = needle.toCharArray();
    int j = -1;
    int[] next = next int[nchar.length()];
    getNext(next, needle);
    for(int i = 0; i &lt; hchar.length(); i ++) &#123;
        while(j != -1 &amp;&amp; hchar[i] != nchar[j + 1]) j = next[j];
        if(hchar[i] == nchar[j + 1]) j ++;
        if(j == nchar.length() - 1) return i - nchar.length() + 1;
    &#125;
&#125;
</code></pre>
<h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:<br>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p>
<h5 id="c-45"><a href="#c-45" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">void getNext(int* next, string s) &#123;
    //自减一
    int j = -1;
    next[0] = j;
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        while(j != -1 &amp;&amp; s[i] != s[j + 1]) &#123;
            j = next[j];
        &#125;
        if(s[i] == s[j + 1]) &#123;
            j ++;
        &#125;
        next[j] = i;
    &#125;
&#125;
bool isRepeated(string s) &#123;
       if(s.size() == 0) &#123;
        return false;
    &#125;
    int len = s.size();
    int next[len];
    getNext(next, s);
    //---(next[s.size() - 1] + 1) 表示最长相等前后缀
    //---len - (next[s.size() - 1] + 1) 表示子串长度
    //---len % 字串长度 == 0 时表示为字串重复
    if(next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1))) &#123;
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<h5 id="c-46"><a href="#c-46" class="headerlink" title="c"></a>c</h5><pre><code class="c">void getNext(int* nums, char* s) &#123;
    int j = -1;
    nums[0] = j;
    int len = strlen(s);
    for(let i = 0; i &lt; len; i ++) &#123;
        if(j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) j = nums[j];
        if(s[j + 1] == s[i]) j ++;
        nums[i] = j;
    &#125;
&#125;
int isRepeated(char* s) &#123;
    int len = strlen(s);
    int* next[len] = &#123;&#125;;
    getNext(next, s);
    if(next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1)) == 0) return 1;
    return 0;
&#125;
</code></pre>
<h5 id="js-26"><a href="#js-26" class="headerlink" title="js"></a>js</h5><pre><code class="js">function getNext(next, s) &#123;
    let j = -1;
    next.push(j);
    for(let i = 0; i &lt; s.length; i ++) &#123;
        if(j != -1 &amp;&amp; s[i] != s[j + 1]) j = next[j];
        if(s[i] == s[j + 1]) j ++;
        next.push(j);
    &#125;
&#125;
function isRepeated(s) &#123;
    let len = s.length;
    let next = new Array(s.length).fill(0);
    getNext(next, s);
    if(s[len - 1] != -1 &amp;&amp; len % (len - (s[len - 1] + 1)) == 0) return true;
    return false;
&#125;
</code></pre>
<h5 id="java-26"><a href="#java-26" class="headerlink" title="java"></a>java</h5><pre><code class="java">public void getNext(int[] next, char[] charA) &#123;
    int j = -1;
    next[0] = j;
    for(int i = 0; i &lt; charA.length(); i ++) &#123;
        if(j != -1 &amp;&amp; charA[i] != charA[j + 1]) j = next[j];
        if(charA[i] == charA[j + 1]) j ++;
        next[i] = j;
    &#125;
&#125;
public bool isRepeated(String s) &#123;
    charA[] charA = s.toCharArray();
    int[] next = new Array(s.length());
    getNext(next, charA);
    int len = s.length;
    if(next[len - 1] != -1 &amp;&amp; len % (len - (len[len - 1] + 1)) == 0) return true;
    return false;
&#125;
</code></pre>
<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>使用栈实现队列的下列操作：</p>
<p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p>
<h5 id="c-47"><a href="#c-47" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">class MyQueue &#123;
    private : 
        stack&lt;int&gt; stackIn;
        stack&lt;int&gt; stackOut;
    public :
        MyQueue() &#123;&#125;
        int push(x) &#123;
            stackIn.push(x);
        &#125;
        int pop() &#123;
            if(stackOut.empty()) &#123;
                while (!stackIn.empty) &#123;
                    stackOut.push(stackIn.top());
                    stackIn.pop();
                &#125;
                int result = stackOut.top();
                stackOut.pop();
                return result;
            &#125;
        &#125;
        int peek() &#123;
               int result = this-&gt;pop();
            stackOut.push(result);
            return result;
        &#125;
        int empty() &#123;
            return stackIn.empty() &amp;&amp; stackOut.empty();
        &#125;
&#125;
</code></pre>
<h5 id="C语言-7"><a href="#C语言-7" class="headerlink" title="C语言"></a>C语言</h5><pre><code class="c">typedef struct &#123;
    int stackInTop, stackOutTop;
    int stackIn[100], stackOut[100];
&#125;MyQueue;

//初始化
MyQueue* queue() &#123;
    MyQueue* queue = (MyQueue *) malloc(sizeof(MyQueue));
    queue-&gt;stackInTop = 0;
    queue-&gt;stackOutTop = 0;
    return queue;
&#125;
int push(MyQueue* que, int x) &#123;
    que-&gt;stackIn[stackInTop] = x;
    stackInTop ++;
    return x;
&#125;
int pop(MyQueue* que) &#123;
    //避免多次操作内存
    int inTop = que-&gt;stackInTop;
    int outTop = que-&gt;stackOutTop;
    if(outTop == 0) &#123;
        while(inTop != 0) &#123;
            que-&gt;stackOut[outTop ++] = que-&gt;stackIn[-- inTop];
        &#125;
        int result = stackOut[--outTop];
        //将输入栈返回到输出栈
        while(outTop != 0) &#123;
            que-&gt;stackIn[inTop ++] = que-&gt;stackOut[-- outTop];
        &#125;
           que-&gt;stackInTop = inTop;
        que-&gt;stackOutTop = outTop;
        return result;
    &#125;
&#125;
int peek(MyQueue* que) &#123;
    return que-&gt;stackIn[0];
&#125;
int empty(MyQueue* que) &#123;
    return que-&gt;stackInTop == 0 &amp;&amp; que-&gt;stackTop == 0;
&#125;
void freeMyQueue(MyQueue* que) &#123;
    que-&gt;stackInTop = 0;
    que-&gt;stackOutTop = 0;
&#125;
</code></pre>
<h5 id="js-27"><a href="#js-27" class="headerlink" title="js"></a>js</h5><pre><code class="js">class solution &#123;
    let stackIn, let stackOut;
    constructor() &#123;
        //stackIn = new    Array();
        stackIn = [];
        stackOut = [];
    &#125;
    push(val) &#123;
        this.stackIn.push(val);
    &#125;
    pop() &#123;
        if(this.stackOut.length) return stackOut.pop());
        while(this.stackIn.length) &#123;
            this.stackOut.push(this.stackIn.pop());
        &#125;
        return this.stackOut.pop();
    &#125;
    peek() &#123;
        return stackIn[0];
    &#125;
    isEmpty() &#123;
        return !this.stackIn.length &amp;&amp; !this.stackOut.length;
    &#125;
&#125;
</code></pre>
<h5 id="java-27"><a href="#java-27" class="headerlink" title="java"></a>java</h5><pre><code class="java">class Solution &#123;
    Stack&lt;Integer&gt; stackIn;
    Stack&lt;Integer&gt; stackOut;
       //初始化
    public Solution() &#123;
         stackIn = new StackIn&lt;&gt; ();
        stackOut = new StackOut&lt;&gt; ();
    &#125;
    //队列添加元素
    public void push(int val) &#123;
        stackIn.push(val);
    &#125;
    //队列删除最前元素
    public void pop() &#123;
        insideOut();
        stackOut.pop();
    &#125;
    //返回队列第一个元素
    public int peek() &#123;
        insideOut();
        return stack.peek();
    &#125;
    //返回是否队列为空
    public bool isEmpty() &#123;
        return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();
    &#125;
    public void insideOut() &#123;
        if(!stackOut.isEmpty()) return ;
        while(!stackIn.isEmpty()) stackOut.push(stackIn.pop());
    &#125;
&#125;
</code></pre>
<h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<h5 id="c-48"><a href="#c-48" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">class MyStack &#123;
    public:
        queue&lt;int&gt; que1;
        queue&lt;int&gt; que2;
        int push(int x) &#123;
            que1.push(x);
        &#125;
        int pop() &#123;
            int size = que1.size();
            //留下最后一个元素
            size --;
            while(sizs --) &#123;
                que2.push(que1.front());
                que1.pop();
            &#125;
            int result = que1.front();
            que1.pop();
               while(!que2.empty()) &#123;
                que1.push(que2.front());
                que2.pop();
            &#125;
            return result;
        &#125;
        int top() &#123;
            return que1.back();
        &#125;
        int empty() &#123;
            return que1.empty();
        &#125;
&#125;
</code></pre>
<h5 id="优化使用一个队"><a href="#优化使用一个队" class="headerlink" title="优化使用一个队"></a>优化使用一个队</h5><pre><code class="c++">class MyStack &#123;
    public:
        int pop() &#123;
            int size = que.size();
            size --;
            while(size --) &#123;
                que.push(que.pop());
            &#125;
            int result = que.front();
            que.push(que.pop());
            return result;
        &#125;
&#125;
</code></pre>
<h4 id="c-49"><a href="#c-49" class="headerlink" title="c"></a>c</h4><p>C语言可以通过数组来实现顺序队列，通过实现逻辑环形的数组顺序队列</p>
<p>还可以用一个单链表链表记录队列中的节点并记录后一个节点</p>
<p>用另一个结构体包含头节点和尾节点的双指针</p>
<h5 id="结构体构建队列"><a href="#结构体构建队列" class="headerlink" title="结构体构建队列"></a>结构体构建队列</h5><pre><code class="c">typedef struct QueNode &#123;
    int val;
    //单向队列
    struct QueNode* next;
&#125;QNode;
typedef struct Que &#123;
    //指向队列尾部
    QNode* tail;
    //指向队列头部
    QNode* head;
&#125;Que;
//队列初始化
void QueInit(Que* que) &#123;
    //assert()宏接受一个整形表达式参数。
    //如果表达式的值为假，assert()宏就会调用_assert函数在标准错误流中打印一条错误信息，并调用abort()
    //（abort()函数的原型在stdlib.h头文件中）函数终止程序。
    assert(que);
    que-&gt;tail = que-&gt;head = NULL;
&#125;
</code></pre>
<h5 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h5><pre><code class="c">void push(Que* que, int val) &#123;
    Qpush(que, val);
&#125;
int pop(Que* que, int size) &#123;
    //留下最后一个元素
    size --;
       while(size --) &#123;
        Qpush(que, que-&gt;head-&gt;val);
        Qpop(que);
    &#125;
    int result = que-&gt;head-&gt;val;
    Qpop(que);
    return result;
&#125;
</code></pre>
<h5 id="js-28"><a href="#js-28" class="headerlink" title="js"></a>js</h5><pre><code class="js">class MyStack &#123;
    let que;
    constructor() &#123;
        que = []&#39;&#39;
    &#125;
    push(val) &#123;
        this.que.shift(val);
    &#125;
       pop() &#123;
        let size = this.que.length;
        size --;
        while(size --) &#123;
            //反向利用数组
            this.que.unshift(this.que.pop());
        &#125;
        return this.que.pop();
    &#125;
&#125;
</code></pre>
<h5 id="java-28"><a href="#java-28" class="headerlink" title="java"></a>java</h5><pre><code class="java">class MyStack &#123;
    Queue&lt;Integer&gt; que;
    public MyStack() &#123;
        que = new LinkedList&lt;&gt; ();
    &#125;
    public void push(int val) &#123;
        que.offer(val);
    &#125;
    public int pop() &#123;
        int size = que.size();
        while(size-- &gt; 1) &#123;
            que.offer(que.poll());
        &#125;
        return que.poll();
    &#125;
&#125;
</code></pre>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ul>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>注意空字符串可被认为是有效字符串。</li>
</ul>
<p>示例 1:</p>
<ul>
<li>输入: “()”</li>
<li>输出: true</li>
</ul>
<h5 id="c-50"><a href="#c-50" class="headerlink" title="c++"></a>c++</h5><pre><code class="c++">bool isValid(string s) &#123;
    if(s.size() % 2 != 0) return false;
    stack&lt;char&gt; stack;
    for(int i = 0; i &lt; s.size(), i ++) &#123;
        if(s[i] == &quot;[&quot; ) &#123;
            stack.push(&quot;]&quot;);
        &#125;else if(s[i] == &quot;&#123;&quot;) &#123;
            stack.push(&quot;&#125;&quot;);
        &#125;else if(s[i] == &quot;(&quot;) &#123;
            stack.push(&quot;)&quot;);
        &#125;else if(s[i] == stack.top()) &#123;
            stack.pop();
        &#125;else if(stack.empty() || s[i] != stack.top()) &#123;
            return false;
        &#125;else &#123;
            stack.pop();
        &#125;
    &#125;
    //为空则匹配成功
    retrun stack.empty();
&#125;
</code></pre>
<h5 id="c-51"><a href="#c-51" class="headerlink" title="c"></a>c</h5><pre><code class="c">typedef struct stack &#123;
    int stackTop;
    int stack[100];
&#125;Stack;
Stack* stackInit(Stack* stack) &#123;
    stack-&gt;stackTop = 0;
    return stack;
&#125;
int isValid(Stack* stack, char* s) &#123;
    int len = strlen(s);
    stackInit();
    for(int i = 0; i &lt; len; i ++) &#123;
        if(s[i] == &#39;[&#39; || s[i] == &#39;&#123;&#39; || s[i] == &#39;(&#39;) &#123;
            stack[stackTop ++] = s[i];
        &#125;else if(stackTop == 0 || s[i] != stack[stackTop - 1]) &#123;
            return -1;
        &#125;else &#123;
            //栈弹出
            stackTop --;
        &#125;
    &#125;
    return stackTop == 0 ? 1 : -1;
&#125;
</code></pre>
<h5 id="js-29"><a href="#js-29" class="headerlink" title="js"></a>js</h5><pre><code class="js">function isValid(s) &#123;
    let stack = [];
    for(let i = 0; i &lt; s.length; i ++) &#123;
        switch(s[i]) &#123;
            case &quot;&#123;&quot; : 
                stack.push(&quot;&#125;&quot;);
                break;
            case &quot;[&quot; :
                stack.push(&quot;]&quot;);
                break;
            case &quot;(&quot; : 
                stack.push(&quot;)&quot;);
                break;
            default: 
                if(s[i] != stack.pop()) return false;
        &#125;
    &#125;
    return !stack.length;
&#125;
</code></pre>
<h5 id="js-优化版"><a href="#js-优化版" class="headerlink" title="js 优化版"></a>js 优化版</h5><pre><code class="js">
</code></pre>
<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<ul>
<li>输入：”abbaca”</li>
<li>输出：”ca”</li>
</ul>
<pre><code class="c++">string findNeiborDel(string s) &#123;
    stack&lt;char&gt; stack;
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] == stack.top()) &#123;
            stack.pop();
        &#125;else if(stack.empty() || s[i] != stack.top()) &#123;
            stack.push(s[i]);
        &#125;
    &#125;
    string result = &quot;&quot;;
    while(!stack.empty()) &#123;
        result += stack.top();
        stack.pop();
    &#125;
    //反转字符串
    revese(result.begin(), result.end());
    return result;
&#125;
</code></pre>
<h5 id="直接将字符串作为栈"><a href="#直接将字符串作为栈" class="headerlink" title="直接将字符串作为栈"></a>直接将字符串作为栈</h5><pre><code class="c++">string findNeiborDel(string s) &#123;
       string result;
    for(char a : s) &#123;
        if(result.empty() || result.back() != a) &#123;
            result.push_back(a);
        &#125;else if(result.back() == a) &#123;
            result.pop_back();
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>说明：</p>
<p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p>示例 1：</p>
<ul>
<li>输入: [“2”, “1”, “+”, “3”, “ * “]</li>
<li>输出: 9</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入: [“4”, “13”, “5”, “/“, “+”]</li>
<li>输出: 6</li>
<li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</li>
</ul>
<pre><code class="c++">int evalRPN(vector&lt;string&gt; s) &#123;
    stack&lt;long long&gt; stack;
    for(int i = 0; i &lt; s.size(); i ++) &#123;
        if(s[i] == &quot;+&quot; || s[i] == &quot;-&quot; || s[i] == &quot;*&quot; || s[i] == &quot;/&quot;) &#123;
            long long num1 = stack.top();
            stack.pop();
            long long num2 = stack.top();
            stack.pop();
            if(s[i] == &quot;+&quot;) &#123;
                stack.push(num1 + num2);
            &#125;else if(s[i] == &quot;-&quot;) &#123;
                stack.push(num1 - num2);
            &#125;else if(s[i] == &quot;*&quot;) &#123;
                stack.push(num1 * num2);
            &#125;else if(s[i] == &quot;/&quot;) &#123;
                stack.push(num1 / num2);
            &#125;
        &#125;else &#123;
            stack.push(s[i]);
        &#125;
    &#125;
    return stack.top();
&#125;
</code></pre>
<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>思路：</p>
<p>使用一个单调队列，队列前面的值为最大值</p>
<pre><code class="c++">class Solution &#123;
    private:
        class MyQueue &#123;
            //使用双端队列
            deque&lt;int&gt; que;
            void pop(value) &#123;
                if(!que.empty() &amp;&amp; value == que.front()) &#123;
                    que.pop_front();
                &#125;
            &#125;
            void push(value) &#123;
                while(!que.empty() &amp;&amp; value &gt; que.back()) &#123;
                    que.pop_back();
                &#125;
                que.push_back(value);
            &#125;
            int front() &#123;
                return que.eqmpt() &amp;&amp; que.front();
            &#125;
        &#125;
      public: 
        vector&lt;int&gt; maxSiblingWindow(vector&lt;int&gt;&amp; num, int k) &#123;
            MyQueue que;
            vector&lt;int&gt; result;
            //将前K个放入单调队列
            for(int i = 0; i &lt; k; i ++) &#123;
                que.push(num[i]);
            &#125;
            result.push_back(que.front());
            for(int i = k; i &lt; num.size(); i ++) &#123;
                //删除k之后相同的值
                que.pop(num[i - k]);
                que.push(num[i]);
                //保存最前列的值
                que.push_back(que.front());
            &#125;
            return result;
        &#125;
&#125;
</code></pre>
<h3 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h3><pre><code class="c++">class Solution() &#123;
    public:
        class comparition() &#123;
            public:
                bool operator(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) &#123;
                    //左大于右，表示从大到小，优先级队列则为相反，用于构建小顶堆
                    return lhs.second &gt; rhs.second;
                &#125;
                vector&lt;int&gt; topKFrequent(vector&lt;int&gt; num, int k) &#123;
                    vector&lt;int&gt; result(k);
                    //用map来记录出现的频率
                    unordered_map&lt;int&gt; map;
                    //遍历获取频率
                    for(int i = 0; i &lt; num.size(); i ++) &#123;
                        //key 为 num的值，value 为出现频率
                        map[num[i]] ++;
                    &#125;
                    //构建小顶堆，使用优先级队列，使具备条件的最先出队，底层实现为堆
                    //参数为&lt;类型，存放数据容器， 比较方式&gt;
                    priority_queue&lt;const pair&lt;int, int&gt;, vector&lt;const pair&lt;int, int&gt;&gt;, comparition&gt; pri_que;
                    //将 map 的值 push 进队列
                    for(auto it : map) &#123;
                        pri_que.push(it);
                        //将超出 k 的弹出，即最小的元素
                        if(pri_que.size() &gt; k) &#123;
                            pri_que.pop();
                        &#125;
                    &#125;
                    //优先级队列为倒叙，输入结果容器
                    for(int i = k - 1; i &gt;= 0; i --) &#123;
                        //frist 为 key，即是数组元素 
                        result[i] = pri_que.top().frist;
                        pri_que.pop();
                    &#125;
                    return result;
                &#125;
        &#125;
</code></pre>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p>
<p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p>
<p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p>
<p>链式存储如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2020092019554618.png" alt="img"></p>
<p>链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？</p>
<p>其实就是用数组来存储二叉树，顺序存储的方式如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200920200429452.png" alt="img"></p>
<p>用数组来存储二叉树如何遍历的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<h3 id="二叉树种类"><a href="#二叉树种类" class="headerlink" title="二叉树种类"></a>二叉树种类</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><h5 id="二叉搜索树是一个有序树。"><a href="#二叉搜索树是一个有序树。" class="headerlink" title="二叉搜索树是一个有序树。"></a><strong>二叉搜索树是一个有序树</strong>。</h5><ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code class="c++">struct TreeNode&#123;
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(val): val(val), left(NULL), right(NULL) &#123;&#125;
&#125;
</code></pre>
<p>JavaScript</p>
<pre><code class="js">class TreeNode &#123;
    val;
    left;
    right;
    constructor(val = 0, left = null, right = null) &#123;
        this.val = val;
        this.left = left;
        this.right = right;
    &#125;
&#125;
</code></pre>
<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><pre><code class="c++">vector&lt;int&gt; traversal(TreeNode* cur, vector&lt;int&gt;&amp; num) &#123;
    if(cur == NULL) return;
    //根节点
    num.push_back(cur-&gt;val);
    //左子树
    traversal(cur-&gt;left, num);
    //右子树
    traversal(cur-&gt;right, num);
&#125;
 preorderTraversal(TreeNode* tree) &#123;
    //定义结果数组
    vector&lt;int&gt; result;
    traversal(tree, result);
    return result;
&#125;
</code></pre>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><pre><code class="c++">//左子树
traversal(cur-&gt;left, num);
//根节点
num.push_back(cur-&gt;val);
//右子树
traversal(cur-&gt;right, num);
</code></pre>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><pre><code class="c++">//左子树
traversal(cur-&gt;left, num);
//右子树
traversal(cur-&gt;right, num);
//根节点
num.push_back(cur-&gt;val);
</code></pre>
<h3 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h3><h5 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h5><pre><code class="c++">vector&lt;int&gt; preorderTraversal(TreeNode* tree) &#123;
       vector&lt;int&gt; result;
    //使用栈来存储节点
    stack&lt;TreeNode*&gt; st;
    //前序遍历先储存根节点
    st.push(tree);
    while(! st.empty()) &#123;
        TreeNode* cur = st.top();
        //将根节点的值放入结果数组中
        result.push_back(cur-&gt;val);
        st.pop();
           //入栈时先右后左，出栈则为先左后右
        if(cur-&gt;right) st.push(cur-&gt;right);
        if(cur-&gt;left) st.push(cur-&gt;left);
    &#125;
    return result;
&#125;
</code></pre>
<h5 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h5><pre><code class="c++">//思路是先把所有的左子树存入栈
vector&lt;int&gt; InorderTraversal(TreeNode* tree) &#123;
    vector&lt;int&gt; result;
    stack&lt;TreeNode*&gt; st;
    TreeNode* cur = tree;
    while(cur != NULL || ! st.empty()) &#123;
        //判断是否到最后一个左子树
        if(cur != NULL) &#123;
            st.push(cur);
            cur = cur-&gt;left;
        &#125;else &#123;
            //获取最后一个左子树
            cur = st.top();
            st.pop();
            result.push_back(cur-&gt;val);
            //遍历所有左子树最近的右子树
            cur = cur-&gt;right;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h5 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了</p>
<pre><code class="c++">vector&lt;int&gt; postorderTraversal(TreeNode* tree) &#123;
       vector&lt;int&gt; result;
    //使用栈来存储节点
    stack&lt;TreeNode*&gt; st;
    //前序遍历先储存根节点
    st.push(tree);
    while(! st.empty()) &#123;
        TreeNode* cur = st.top();
        //将根节点的值放入结果数组中
        result.push_back(cur-&gt;val);
        st.pop();
           //入栈时先左后左，出栈则为先右后左
        if(cur-&gt;left) st.push(cur-&gt;left);
        if(cur-&gt;right) st.push(cur-&gt;right);
    &#125;
    reverse(result.begin(), result.end());
    return result;
&#125;
</code></pre>
<h3 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a>二叉树的统一迭代法</h3><h5 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h5><pre><code class="c++">vector&lt;int&gt; inorderTraversal(TreeNode* tree) &#123;
    vector&lt;int&gt; result;
    stack&lt;TreeNode*&gt; st;
    if(tree != NULL) st.push(tree);
    while(!st.empty()) &#123;
        TreeNode* cur = st.top();
        if(cur != NULL) &#123;
            //中序遍历一次放入右，中，左
            //不为空再放入栈中
            if(cur-&gt;right) st.push(cur-&gt;right);
            
            //放入根节点
            st.push(cur);
            //用 NULL 作为标识来表示已经访问过根节点
            st.push(NULL);
            //放入左子树
            if(cur-&gt;left) st.push(cur-&gt;left);
           //为空表示所有节点遍历完成
        &#125;else &#123;
            //弹出NULL
            st.pop();
            cur = st.top();
            st.pop();
            result.push_back(cur-&gt;value);
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h5 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h5><pre><code class="c++">vector&lt;int&gt; postorderTraversal(TreeNode* tree) &#123;
    vector&lt;int&gt; result;
    stack&lt;TreeNode*&gt; st;
    if(tree != NULL) st.push(tree);
    while(! st.empty()) &#123;
        TreeNode* cur = st.top();
        if(cur != NULL) &#123;
            //后序遍历先放入根节点
            st.pop();
            st.push(cur);
            st.push(NULL);
            
            if(cur-&gt;right) st.push(cur-&gt;right);
            if(cur-&gt;left) st.push(cur-&gt;left);
        &#125;else &#123;
            //删除 NULL
            st.pop();
            cur = st.top();
            result.push_back(cur-&gt;val);
            st.pop();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><pre><code class="c++">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* tree) &#123;
    //构建一个队列来遍历每一层
    queue&lt;TreeNode*&gt; que;
       vector&lt;vector&lt;int&gt;&gt; result;
    if(tree != NULL) que.push(tree);
    while(!que.empty()) &#123;
        //构建每一层的容器
        vector&lt;int&gt; res;
        //计算每一层的数量
        int size = que.size();
        for(int i = 0; i &lt; size; i ++) &#123;
            TreeNode* cur = que.front;
            res.push_back(cur-&gt;val);
            que.pop();
            if(cur-&gt;right) que.push(cur-&gt;right);
            if(cur-&gt;left) que.push(cur-&gt;left);
        &#125;
        result.push_back(res);
    &#125;
    return result;
&#125;
</code></pre>
<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><pre><code class="c++">TreeNode* reverseTree(TreeNode* tree) &#123;
    if(tree == NULL) return tree;
    swap(tree-&gt;right, tree-&gt;left);
    reverseTree(tree-&gt;left);
    reverseTree(tree-&gt;right);
    return tree;
&#125;
</code></pre>
<h5 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h5><p>在前中后遍历时将结果数组的代码替换为</p>
<pre><code class="c++">swap(cur-&gt;left, cur-&gt;right);
</code></pre>
<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的</p>
<h5 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">bool compare(TreeNode* left, TreeNode* right) &#123;
    if(left == NULL &amp;&amp; right == NULL) return true;
    else if(left != NULL &amp;&amp; right == NULL) return false;
    else if(left == NULL &amp;&amp; right != NULL) return false;
    else if(left-&gt;val != right-&gt;val) return false;
    
    bool outside = compare(left-&gt;left, right-&gt;right);
    bool inside = compare(left-&gt;right, right-&gt;left);
    return outside &amp;&amp; inside;
&#125;
bool isSymmetric(TreeNode* tree) &#123;
    if(tree == NULL) return true;
    //判断二叉树是否对称，只需要判断根节点的左右子树是否对称
    return compare(tree-&gt;left, tree-&gt;right);
&#125;
</code></pre>
<h5 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">bool isSymmetric(TreeNode* tree) &#123;
    //使用队列来逐个判断子树是否对称（使用其他数据结构也可以）
    queue&lt;TreeNode*&gt; que;
       if(tree == NULL) return true;
    que.push(tree-&gt;left);
    que.push(tree-&gt;right);
    while(!que.empty()) &#123;
        TreeNode* left = que.front(); que.pop();
        TreeNode* right = que.front(); que.pop();
        if(left == NULL &amp;&amp; right == NULL) &#123;
            return true;
        &#125;
        if(!left || !right || (left-&gt;val != right-&gt;val)) &#123;
            return false;
        &#125;
        que.push(left-&gt;left);
        que.push(right-&gt;right);
        que.push(left-&gt;right);
        que.push(right-&gt;left);
    &#125;
    return true;
&#125;
</code></pre>
<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><pre><code class="c++">int getDepth(TreeNode* tree) &#123;
    if(tree == NUll) return 0;
    return 1 + max(getDepth(tree-&gt;left), getDepth(tree-&gt;right));
&#125;
</code></pre>
<h5 id="前序遍历-2"><a href="#前序遍历-2" class="headerlink" title="前序遍历"></a>前序遍历</h5><pre><code class="c++">class Solution &#123;
    public:
    int result;
    void getDepth(TreeNode* tree, int depth) &#123;
        result = result &gt; depth ? result : depth;
        if(tree-&gt;left == NULL &amp;&amp; tree-&gt;right == NULL) return;
        if(tree-&gt;left) &#123;
            getDepth(tree-&gt;left, depth + 1);
        &#125;
        if(tree-&gt;rigth) &#123;
            getDepth(tree-&gt;right, depth + 1);
        &#125;
        return ;
    &#125;
    int getMax(TreeNode* tree) &#123;
        int result = 0;
        if(tree == NULL) return result;
        getDepth(tree, 1);
        return result;
    &#125;
&#125;
</code></pre>
<h5 id="迭代法的层序遍历"><a href="#迭代法的层序遍历" class="headerlink" title="迭代法的层序遍历"></a>迭代法的层序遍历</h5><pre><code class="c++">int getDepth(TreeNode* tree) &#123;
    int depth = 0;
    queue&lt;TreeNode*&gt; que;
    que.push(tree);
    while(! que.empty()) &#123;
        int size = que.size();
        depth ++;
        for(int i = 0; i &lt; size; i ++) &#123;
            TreeNode* cur = que.front();
            que.pop();
            if(cur-&gt;left) que.push(cur-&gt;left);
            if(cur-&gt;right) que.push(cur-&gt;right);
        &#125;
    &#125;
    return depth;
&#125;
</code></pre>
<h4 id="N叉树的最大深度"><a href="#N叉树的最大深度" class="headerlink" title="N叉树的最大深度"></a>N叉树的最大深度</h4><h5 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">int maxDepth(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
    int depth = 0;
    for(int i = 0; i &lt; tree-&gt;children.size(); i ++) &#123;
        depth = max(depth, maxDepth(tree-&gt;chidren[i]));
    &#125;
    return depth + 1;
&#125;
</code></pre>
<h5 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h5><p>层序遍历</p>
<pre><code class="c++">int maxDepth(TreeNode* tree) &#123;
    int depth = 0;
    queue&lt;int&gt; que;
    que.push(tree);
    while(! que.empty()) &#123;
        int size = que.size();
        depth ++;
        for(int i = 0; i &lt; size; i ++) &#123;
            TreeNode* cur = que.front();
            que.pop();
            for(int j = 0; j &lt; cur-&gt;children.size(); j ++) &#123;
                if(que.children[j]) que.push(cur-&gt;children[j]);
            &#125;
        &#125;
    &#125;
    return depth;
&#125;
</code></pre>
<h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量</p>
<h5 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">int getMinDepth(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
       if(tree-&gt;left == NULL &amp;&amp; tree-&gt;right! = NULL) &#123;
        return 1 + getMinDepth(tree-&gt;right);
    &#125;
    if(tree-&gt;left != NULL &amp;&amp; tree-&gt;right == NULL) &#123;
        return 1 + getMinDepth(tree-&gt;left);
    &#125;
    return 1 + min(getMinDepth(tree-&gt;left), getMinDepth(tree-&gt;rigth));
&#125;
</code></pre>
<h5 id="迭代法-5"><a href="#迭代法-5" class="headerlink" title="迭代法"></a>迭代法</h5><p>层序遍历</p>
<pre><code class="c++">int getMinDepth(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
    queue&lt;TreeNode*&gt; que;
    int depth = 0;
    que.push(tree);
    while(! que.empty()) &#123;
        int size = que.size();
        depth ++;
        for(int i = 0; i &lt; size; i ++) &#123;
            TreeNode* cur = que.front();
            que.pop();
            if(cur-&gt;left) que.push(cur-&gt;left);
            if(cur-&gt;right) que.push(cur-&gt;right);
            //当左右子树都为空的时候则为最小深度
            if(! cur-&gt;left &amp;&amp; ! cur-&gt;right) &#123;
                return depth;
            &#125;
        &#125;
    &#125;
    return depth;
&#125;
</code></pre>
<h3 id="完全二叉树的节点数"><a href="#完全二叉树的节点数" class="headerlink" title="完全二叉树的节点数"></a>完全二叉树的节点数</h3><h4 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h4><h5 id="递归法-6"><a href="#递归法-6" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">int countNode(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
    return conutNode(tree-&gt;left) + countNode(tree-&gt;right) + 1;
&#125;
</code></pre>
<h5 id="迭代法-6"><a href="#迭代法-6" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">//层序遍历
int count;
for(;i &lt; size;) count ++;
</code></pre>
<h4 id="完全二叉树-1"><a href="#完全二叉树-1" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p>
<p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p>
<p>–&gt; 判断一个左子树或者右子树是不是满二叉树</p>
<p>在完全二叉树中，如果递归向左遍历的<code>深度</code>等于递归向右遍历的<code>深度</code>，那说明就是满二叉树</p>
<pre><code class="c++">int countNodes(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
    TreeNode* left = tree-&gt;left;
    TreeNodse* right = tree-&gt;right:
    int leftCount = 0, rightCount = 0;
    //完全二叉树中，左子树的数量若等于右子树的数量则说明是满二叉树，可以根据公式计算节点数量
    while(left) &#123;
        left = left-&gt;left;
        leftCount ++;
    &#125;
    while(right) &#123;
        right = right-&gt;right;
        rightCount ++;
    &#125;
    if(leftCount == rightCount) &#123;
        //(2 ^ h) - 1
        return (2 &lt;&lt; leftCount) - 1;
    &#125;
    //若不为满二叉树，则寻找子树的满二叉树
    return countNodes(tree-&gt;left) + countNodes(tree-&gt;right) + 1;
&#125;
</code></pre>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<pre><code class="c++">class Solution &#123;
    public: 
    int getHeight(TreeNode* node) &#123;
        if(node == NULL) return 0;
        //若递归时返回 -1 则都返回 -1
        int leftH = getHeight(node-&gt;left);
        if(leftH == -1) return -1;
        int rightH = getHeight(node-&gt;right);
        if(rightH == -1) return -1;
        //若相差大于1，则说明不为平衡二叉树, 或者返回深度
        return abs(leftH - rightH) &gt; 1 ? -1 : max(leftH, rightH);
    &#125;
    bool isBalanced(TreeNode* tree) &#123;
        return getHeight(tree);
    &#125;
&#125;
</code></pre>
<h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</p>
<p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。</p>
<p>前序遍历以及回溯的过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151702443.png" alt="257.二叉树的所有路径"></p>
<p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p>
<pre><code class="c++">class Solution &#123;
    public:
    void traversal(TreeNode* node, vector&lt;int&gt; path, vector&lt;string&gt; result) &#123;
        //通过不断的递归，将路径的值写入容器
        path += to_string(node-&gt;val);
        //递归的终止条件，遍历到叶子节点则回溯上一个，延展到其他路径
        if(node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) &#123;
               //将路经以 val -&gt; val 写入
            string paths;
            //最后一个元素另外写入
            for(int i = 0; i &lt; path.size() - 1; i ++) &#123;
                paths += to_string(path[i]);
                paths += &quot;-&gt;&quot;;
            &#125;
            paths += to_string(path[path.size() - 1]);
               result.push_back(paths);
            return ;
        &#125;
        //左子树的路径记录
        if(node-&gt;left) &#123;
            traversal(node-&gt;left, path, result);
            //进行回溯，上一代码有结果后，删除一个节点以更改路径
            path.pop_back();
        &#125;
        if(node-&gt;right) &#123;
            traversal(node-&gt;right, path, result);
            path.pop_back();
        &#125;
    &#125;
       vector&lt;string&gt; binaryTreePaths(TreeNode* tree) &#123;
        vector&lt;string&gt; result;
        vector&lt;int&gt; path;
        traversal(tree, path, result);
        return result;
    &#125;
&#125;
</code></pre>
<h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><pre><code class="c++">int sumOfLeftLeaves(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
    if(tree-&gt;left == NULL &amp;&amp; tree-&gt;right) return 0;
    //递归左子树
    int leftValue = sumOfLeftLeaves(tree-&gt;left); 
    //如果有左子树且左子树的左右都为空,则为叶子节点
    if(tree-&gt;left &amp;&amp; !tree-&gt;left-&gt;left &amp;&amp; !tree-&gt;right-&gt;right) &#123;
        leftValue = tree-&gt;left-&gt;val;
    &#125;
    //递归右子树
    int rightValue = sumOfLeftLeaves(tree-&gt;right);
    return  leftValue + rightValue;
&#125;
</code></pre>
<h5 id="迭代法（前）"><a href="#迭代法（前）" class="headerlink" title="迭代法（前）"></a>迭代法（前）</h5><pre><code class="c++">int sumOfLeftLeaves(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
    int result = 0;
    stack&lt;TreeNode*&gt; st;
    st.push(tree);
    while(! st.empty()) &#123;
        TreeNode* cur = st.top();
        st.pop();
        if(cur-&gt;left &amp;&amp; !cur-&gt;left-&gt;left &amp;&amp; !cur-&gt;left-&gt;right) &#123;
            result += cur-&gt;left-&gt;val;
           &#125;
        if(cur-&gt;left) st.push(cur-&gt;left);
        if(cur-&gt;right) st.push(cur-&gt;right);
    &#125;
    return result;
&#125;
</code></pre>
<h3 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h3><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<h5 id="递归法-7"><a href="#递归法-7" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">class Solution &#123;
    public:
    int result;
    int maxDepth = MAX_DEPTH;
    //使用 depth 来递归深度
    void traversal(TreeNode* node, int depth) &#123;
        if(tree == NULL) return 0; 
        //找到叶子节点则执行最终逻辑
        if(tree-&gt;left == NULL &amp;&amp; tree-&gt;right == NULL) &#123;
            if(depth &gt; maxDepth) &#123;
                maxDepth = depth;
                result = node-&gt;val;
            &#125;
            return ;
        &#125;
        //左子树
        if(tree-&gt;left) &#123;
            depth ++;
            traversal(node-&gt;left, depth);
            //进行回溯到上一个节点，往下进行递归，需要回溯来找最大深度
            depth --;
        &#125;
        //右子树
        if(tree-&gt;right) &#123;
            depth ++;
            traversal(node-&gt;right, depth);
            depth --;
        &#125;
        return ;
    &#125;
    int findBottomLeftValue(TreeNode* tree) &#123;
        int depth = 0;
        traversal(tree, depth);
        return result;
    &#125;
&#125;
</code></pre>
<h5 id="迭代法-7"><a href="#迭代法-7" class="headerlink" title="迭代法"></a>迭代法</h5><p>层序遍历</p>
<pre><code class="c++">int findBottomLeftValue(TreeNode* tree) &#123;
    if(tree == NULL) return 0;
    int result = 0;
    queue&lt;TreeNode*&gt; que;
    que.push(tree);
    while(! que.empty()) &#123;
        int size = que.size();
        for(int i = 0; i &lt; size; i ++) &#123;
            TreeNode* cur = que.front();
            que.pop();
            if(i == 0) result = cur-&gt;val;
            if(cur-&gt;left) que.push(cur-&gt;left);
            if(cur-&gt;right) que.push(cur-&gt;right);
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>bool</p>
<h5 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h5><pre><code class="c++">bool traversal(TreeNode* node, int sum) &#123;
    //如果遍历到叶子节点，并且sum 为 0 的时候说明存在路径
    if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; sum == 0) return true;
    //否则不存在
    if(!node-&gt;left &amp;&amp; !node-&gt;right) return false;
    if(node-&gt;left) &#123;
        sum -= node-&gt;left-&gt;val;
        traversal(node-&gt;left, sum);
        //回溯到上一节点，将减去的值恢复
        sum += node-&gt;left-&gt;val;
    &#125;
    if(node-&gt;right) &#123;
           /*
               隐藏回溯
               traversal(node-&gt;rigth, sum - node-&gt;val);
           */
           sum -= node-&gt;right-&gt;val;
        traversal(node-&gt;right, sum);
        //回溯到上一节点，将减去的值恢复
        sum += node-&gt;right-&gt;val;
    &#125;
    return false;
&#125;
bool hasPathSum(TreeNode* tree, int sum) &#123;
    if(tree == NULL) return 0;
    return traversal(tree, sum);
&#125;
</code></pre>
<h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>在栈中保存一个容器，容器包含当前节点以及路径到此节点相加的值</p>
<pre><code class="c++">bool hasPathSum(TreeNode* tree, int sum) &#123;
    if(tree == NULL) return 0;
       stack&lt;pair&lt;TreeNode*, int&gt;&gt; st;
    st.push(pair&lt;TreeNode*, int&gt; (tree, 0));
    while(! st.empty()) &#123;
           pair&lt;TreeNode*, int&gt; node = st.top();
        st.pop();
        //判断叶子节点来执行
        if(!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum = node.second) return true;
        //遍历左子树和右子树
        if(node.first-&gt;left) &#123;
            st.push(pair&lt;TreeNode*, int&gt; (node.first-&gt;left, node.second + node.first-&gt;left.val));
        &#125;
        if(node.first-&gt;right) &#123;
            st.push(pair&lt;TreeNode*, int&gt; (node.first-&gt;right, node.second + node.second-&gt;right.val));
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h3 id="路径总和-ii"><a href="#路径总和-ii" class="headerlink" title="路径总和 ii"></a>路径总和 ii</h3><p>计算出所有相加为 sum 的路径并放在结果数组</p>
<h5 id="递归法-8"><a href="#递归法-8" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">class Solution &#123;
    public:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void traversal(TreeNode* node, int count) &#123;
           //判断为叶子节点执行
        if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; count == 0) &#123;
            result.push_back(path);
              return ;
        &#125;
        if(!node-&gt;left &amp;&amp; !node-&gt;right) return;
        //左右子树遍历
        if(node-&gt;left) &#123;
            count -= node-&gt;left-&gt;val;
            path.push_back(node-&gt;left-&gt;val);
            traversal(node-&gt;left, count);
            //回溯
            count += node-&gt;val;
            path.pop();
        &#125;
        if(node-&gt;right) &#123;
               count -= node-&gt;right-&gt;val;
            path.push_back(node-&gt;right-&gt;val);
            traversal(node-&gt;rigth, count);
            //回溯
            count += node-&gt;right-&gt;val;
            path.pop();
        &#125;
        return ;
    &#125;
     vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* tree, int sum) &#123;
        if(tree ==     NULL) return;
        traversal(tree, sum);
        return result;
    &#125;   
&#125;
</code></pre>
<h3 id="从中序和后序遍历构建二叉树"><a href="#从中序和后序遍历构建二叉树" class="headerlink" title="从中序和后序遍历构建二叉树"></a>从中序和后序遍历构建二叉树</h3><p>就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p>
<p>流程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p>
<p>说到一层一层切割，就应该想到了递归。</p>
<p>来看一下一共分几步：</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<pre><code class="c++">class Solution &#123;
    TreeNode* traversal(vector&lt;int&gt; inorder, vector&lt;int&gt; postorder) &#123;
        //设定终止条件
        if(inorder.size() == 0) return     NULL;
        //让后序遍历的最后一个节点作为根节点
        int rootValue = postorder[postorder.size() - 1];
        //创建一个新节点
        TreeNode* tree = new TreeNode(rootValue);
        
        //以后序数组的最后一个元素为界，分割前序数组
        int delimiterInorder;
        for(delimiterInorder = 0; delimiterInorder &lt; inorder.size(); delimiterInorder ++) &#123;
            if(inorder[delimiterInorder] == rootValue);
        &#125;
        //开始切割前序数组
        //左前序数组[0, delimiterInorder)
        vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + delimiterInorder);
        //右前序数组[delimiterInorder + 1, inorder.end);
        vector&lt;int&gt; rightInorder(delimiterInorder + 1, inorder.end());
        
        //后序数组删除最后一位，重新定义内存
        postorder.resize(postorder.size() - 1);
        
        //用前序数组切割后序数组
        //左后序数组
        vector&lt;int&gt; leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        vector&lt;int&gt; rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());
        
        //进行左子树递归
        tree-&gt;left = traversal(leftInorder, leftPostorder);
        //右子树递归
           tree-&gt;right = traversal(rightInorder, rightPostorder);
        
        return tree;
    &#125;
      TreeNode* buildTree(vector&lt;int&gt; inorder, vector&lt;int&gt; postorder) &#123;
        if(inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, postorder);
    &#125;
&#125;
</code></pre>
<h5 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h5><pre><code class="c++">TreeNode* traversal (vector&lt;int&gt;&amp; inorder, int inorderBegin, int inorderEnd, vector&lt;int&gt;&amp; postorder, int postorderBegin, int postorderEnd) 
    
        // 切割中序数组
        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了

        root-&gt;left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root-&gt;right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);
</code></pre>
<h3 id="前序遍历和后序遍历构造二叉树"><a href="#前序遍历和后序遍历构造二叉树" class="headerlink" title="前序遍历和后序遍历构造二叉树"></a>前序遍历和后序遍历构造二叉树</h3><pre><code class="c++">// 切割中序数组
        // 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割前序数组
        // 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)
        int leftPreorderBegin =  preorderBegin + 1;
        int leftPreorderEnd = preorderBegin + 1 + delimiterIndex - inorderBegin; // 终止位置是起始位置加上中序左区间的大小size
        // 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)
        int rightPreorderBegin = preorderBegin + 1 + (delimiterIndex - inorderBegin);
        int rightPreorderEnd = preorderEnd;
</code></pre>
<h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<pre><code class="c++">class Solution &#123;
    public:
    TreeNode* traversal(vector&lt;int&gt; nums, int left, int right) &#123;
        if(right &gt;= left) return nullptr;
        
        int maxValueIndex = left;
        for(int i = left + 1; i &lt; right; i ++) &#123;
            if(nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;
        &#125;
        //创建新的节点，值为数组的最大值
        TreeNode* tree = new TreeNode(nums[maxValueIndex]);
        
        //表示区间[nums.begin(), maxValueIndex)
        int leftNum = nums.begin() + maxValueIndex;
        int rightNum = maxValueIndex + 1;
        
        //节点的左子树
        tree-&gt;left = traversal(nums, nums.begin(), nums.begin() + maxValueIndex);
        //节点右子树
        tree-&gt;right = traversal(nums, maxValueIndex + 1, nums.end());
        
        return tree;
    &#125;
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt; nums) &#123;
        return traversal(nums, 0, nums.size());
    &#125;
&#125;
</code></pre>
<h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<h5 id="递归法-9"><a href="#递归法-9" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">//更改t1的结构
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
    if(t1 == NULL) return t2;
    if(t2 == NULL) return t1;
    
    t1-&gt;val += t2-&gt;val;
    t1-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);
    t2-&gt;right = mergeTree(t1-&gt;right, t2-&gt;right);
    return t1;
&#125;
//重新构建一个二叉树
TreeNode* mergeTrees(TreeNode* t1, TreeNode * t2) &#123;
    if(t1 == NULL) return t1;
    if(t2 == NULL) return t2;
    TreeNode* tree = new TreeNode(0);
    tree-&gt;val = t1-&gt;val + t2-&gt;val;
    tree-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);
    tree-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);
    return tree;
&#125;
</code></pre>
<h5 id="迭代法-8"><a href="#迭代法-8" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">TreeNode* mergeTree(TreeNode* t1, TreeNode* t2) &#123;
    if(t1 == NULL) return t1;
    if(t2 ==NULL) return t2;
    queue&lt;TreeNode*&gt; que;
    que.push(t1);
    que.push(t2);
    while(! que.empty()) &#123;
        TreeNode* tree1 = que.front(); que.pop();
        TreeNode* tree2 = que.front(); que.pop();
        tree1-&gt;val += tree2-&gt;val;
        
        if(tree1-&gt;left != NULL &amp;&amp; tree2-&gt;left != NULL) &#123;
            que.push(tree1-&gt;left);
            que.push(tree2-&gt;left);
        &#125;
        if(tree1-&gt;right != NULL &amp;&amp; tree2-&gt;right != NULL) &#123;
            que.push(tree1-&gt;right);
            que.push(tree2-&gt;right);
        &#125;
        if(tree1-&gt;left != NULL &amp;&amp; tree2-&gt;left == NULL) &#123;
            tree1-&gt;left = tree1-&gt;left;
        &#125;
        if(tree1-&gt;right == NULL &amp;&amp; tree2-&gt;right != NULL) &#123;
            tree1-&gt;right = tree2-&gt;right;
        &#125;
    &#125;
    return tree1;
&#125;
</code></pre>
<h5 id="使用指针直接更改树"><a href="#使用指针直接更改树" class="headerlink" title="使用指针直接更改树"></a>使用指针直接更改树</h5><pre><code class="c++">void traversal(TreeNode** t1, TreeNode** t2) &#123;
    if((*t1) == NULL &amp;&amp; (*t2) == NULL) return ;
    if((*t1) != NULL &amp;&amp; (*t2) != NULL) &#123;
        (*t1)-&gt;val += (*t2)-&gt;val;
    &#125;
    if((*t1) != NULL &amp;&amp; (*t2) == NULL) &#123;
        return ;
    &#125;
    if((*t1) == NULL &amp;&amp; (*t2) != NULL) &#123;
        *t1 = *t2;
    &#125;
    traversal((*t1)-&gt;left, (*t2)-&gt;left);
       traversal((*t1)-&gt;right, (*t2)-&gt;right);
&#125;
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123;
    if(t1 == NULL &amp;&amp; t2 == NULL) return NULL;
    //传递引用，形参就为指针的指针
    traversal(&amp;t1, &amp;t2);
    return t1;
&#125;
</code></pre>
<h3 id="二叉搜索树的搜索"><a href="#二叉搜索树的搜索" class="headerlink" title="二叉搜索树的搜索"></a>二叉搜索树的搜索</h3><p>因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。</p>
<p>如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL</p>
<h5 id="递归法-10"><a href="#递归法-10" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">TreeNode* searchBST(TreeNode* node, int val) &#123;
    if(node == NULL &amp;&amp; node-&gt;val == val) return node;
    if(node-&gt;val &gt; val) return searchBST(node-&gt;left, val);
    if(node-&gt;val &lt; val) return searchBST(node-&gt;right, val);
    return NULL;
&#125;
</code></pre>
<h5 id="迭代法-9"><a href="#迭代法-9" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">TreeNode* searchBST(TreeNode* tree, int val) &#123;
    while(tree != NULL) &#123;
        if(tree-&gt;val &gt; val) &#123;
            tree = tree-&gt;left;
        &#125;else if(tree-&gt;val &lt; val) &#123;
            tree = tree-&gt;right;
        &#125;else &#123;
            return tree;
        &#125;
    &#125;
    return NULL;
&#125;
</code></pre>
<h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h5 id="递归法-11"><a href="#递归法-11" class="headerlink" title="递归法"></a>递归法</h5><pre><code class="c++">class Solution &#123;
       public:
    vector&lt;int&gt; result;
    void traversal(TreeNode* node) &#123;
        if(node == NULL) return ;
        //遍历到最左边的叶子节点
        traversal(node-&gt;left);
        //从后往前开始记录
        result.push_back(node-&gt;val);
        traversal(node-&gt;right);
    &#125;
    bool isBST(TreeNode* tree) &#123;
           if(tree == NULL) return false;
        traversal(tree);
        //判断结果数组是否有序递增，有序说明是搜索树
        for(int i = 0; i &lt; result.size(); i ++) &#123;
            if(result[i] &lt; result[i - 1]) return false;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h5 id="递归法2"><a href="#递归法2" class="headerlink" title="递归法2"></a>递归法2</h5><p>利用不断遍历，寻找有序的最大值，有序则代表搜索树合理</p>
<pre><code class="c++">long long MaxValue = LONG_INT;
bool isVaildBST(TreeNode* tree) &#123;
    if(tree == NULL) return ;
    //中序遍历
    bool left = isVaildBST(tree-&gt;left);
    
    if(MaxValue &lt; tree-&gt;val) MaxValue = tree-&gt;val;
    else return false;
    //右子树
    bool right = isVaildBST(tree-&gt;right);
    
    return left &amp;&amp; right;
&#125;
</code></pre>
<h5 id="迭代法-10"><a href="#迭代法-10" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">bool isVaildBST(TreeNode* tree) &#123;
    stack&lt;TreeNode*&gt; st;
    TreeNode* cur = tree;
    TreeNode* pre = NULL;
       while(cur != NULL &amp;&amp; ! st.empty()) &#123;
        if(cur != NULL) &#123;
            st.push(cur);
               cur = cur-&gt;left;
        &#125;else &#123;
            cur = st.top();
            st.pop();
            //若当前的节点的值小于前一个节点，说明不是有序递增
            if(pre != NULL &amp;&amp; cur-&gt;val &lt;= pre-&gt;val) return false;
            
            //记录当前节点作为前一个节点
            pre = cur;
               cur = cur-&gt;right;
        &#125;
    &#125;
    return true;
&#125;
</code></pre>
<h3 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h3><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<h5 id="递归法-12"><a href="#递归法-12" class="headerlink" title="递归法"></a>递归法</h5><p>中序遍历</p>
<pre><code class="c++">class Solution &#123;
    public:
    vector&lt;int&gt; vec;
    void traversal(TreeNode* tree) &#123;
        if(tree == NULL) return;
        if(tree-&gt;left) traversal(tree-&gt;left);
        result.push_back(tree-&gt;val);
        if(tree-&gt;right) traversal(tree-&gt;right);
    &#125;
    int getMinimumDifference(TreeNode* tree) &#123;
        traversal(tree);
           if(vec.size() &lt; 2) return ;
        int result = INT_MAX;
        for(int i = 0; i &lt; vec.size(); i ++) &#123;
               result = min(result, vec[i] - vec[i - 1]);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h5 id="递归法2-1"><a href="#递归法2-1" class="headerlink" title="递归法2"></a>递归法2</h5><p>记录前一个节点，与当前节点做比对</p>
<pre><code class="c++">class Solution &#123;
    public:
    int result = INT_MAX;
    TreeNode* pre = NULL;
    void traversal(TreeNode* tree) &#123;
           if(tree == NULL) return ;
           traversal(tree-&gt;left);
        if(pre != NULL) &#123;
            result = min(result, tree-&gt;val - pre-&gt;val);
        &#125;
        pre = tree;
           traversal(tree-&gt;right);
    &#125;
    int getMinimumDifference(TreeNode* tree) &#123;
        if(tree == NULL) return;
        traversal(tree);
        return result;
    &#125;
&#125;
</code></pre>
<h5 id="迭代法-11"><a href="#迭代法-11" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">int getMinimumDifference(TreeNode* tree) &#123;
    stack&lt;TreeNode*&gt; st;
    TreeNode* cur = tree;
    TreeNode* pre = NULL;
    int result = INT_MAX;
    while(cur != NULL || ! st.empty()) &#123;
        if(cur != NULL) &#123;
            st.push(cur);
            st.pop();
            cur = cur-&gt;left;
        &#125;else &#123;
            cur = st.top();
            if(pre != NULL) &#123;
                   result = min(result, cur-&gt;val - pre-&gt;val);
            &#125;
            pre = cur;
            cur = cur-&gt;rigth;
        &#125;
    &#125;
    return result;
&#125;
</code></pre>
<h3 id="二叉搜索树的众数"><a href="#二叉搜索树的众数" class="headerlink" title="二叉搜索树的众数"></a>二叉搜索树的众数</h3><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<h4 id="如果不是二叉搜索树"><a href="#如果不是二叉搜索树" class="headerlink" title="如果不是二叉搜索树"></a>如果不是二叉搜索树</h4><ol>
<li>这个树都遍历了，用map统计频率</li>
<li>把统计的出来的出现频率（即map中的value）排个序</li>
</ol>
<p>要把map转化数组即vector，再进行排序，当然vector里面放的也是<code>pair&lt;int, int&gt;</code>类型的数据，第一个int为元素，第二个int为出现频率。</p>
<p>​    3.    取前面高频的元素</p>
<pre><code class="c++">class Solution &#123;
    private:
    //递归遍历节点，将节点的值和频率存储在map中
    void traversal(TreeNode* node, unorder_map map) &#123;
        if(node == NULL) return ;
        map[node-&gt;val] ++;
        traversal(node-&gt;left);
        traversal(node-&gt;right);
    &#125;
    //定义排序方式
    bool cmp(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123;
        //升序排序
        return a.second &gt; b.second;
    &#125;
    public:
    vector&lt;int&gt; findMode(TreeNode* tree) &#123;
        vector&lt;int&gt; result;
        unorder_map&lt;int, int&gt; map;
        if(tree == NULL) return result;
        traversal(tree, map);
        vector&lt;pair&lt;int, int&gt;&gt; vec(map.begin(), map.end());
        //进行排序
        sort(vec.begin(), vec.end(), cmp);
        result.push_back(vec[0].first);
        for(int i = 0; i &lt; vec.size(); i ++) &#123;
            if(vec[i].second == vec[0].second) 
                result.push_back(vec[i]);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h4 id="如果是二叉搜索树"><a href="#如果是二叉搜索树" class="headerlink" title="如果是二叉搜索树"></a>如果是二叉搜索树</h4><pre><code class="c++">class Solution &#123;
    private:
    int count = 0;
    int maxCount = 0;
    TreeNode* cur = NULL;
    vector&lt;int&gt; result
    //中序遍历
    void traversal(TreeNode* tree) &#123;
        if(tree == NULL) return ;
        //左
        traversal(tree-&gt;left);
        //中
        if(pre == NULL) &#123;
            count = 1;
        &#125;else if(pre-&gt;val == tree-&gt;val) &#123;
            count ++;
        &#125;else &#123;
            count = 1;
        &#125;
        pre = cur;
        if(count == maxCount) &#123;
            result.push_back(tree-&gt;val);
        &#125;
        if(count &gt; maxCount) &#123;
            maxCount = count;
            result.clear();
            result.push_back(tree-&gt;val);
        &#125;
        //右
        traversal(tree-&gt;right);
        return ;
    &#125;
    public:
    vector&lt;int&gt; findMode(TreeNode* tree) &#123;
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL;
        result.clear();
        traversal(tree);
        return result;
    &#125;
&#125;
</code></pre>
<h5 id="迭代法-12"><a href="#迭代法-12" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">vector&lt;int&gt; findMode(TreeNode* tree) &#123;
    int count = 0;
    int maxCount = 0;
    TreeNode* cur = tree;
    vector&lt;int&gt; result;
    stack&lt;int&gt; st;
    //中序遍历
    while(cur != NULL &amp;&amp; ! st.empty()) &#123;
        if(cur != NULL) &#123;
            st.push(cur);
            cur = cur-&gt;left;
        &#125;else &#123;
            cur = st.top();
            st.pop();
            if(tree == NULL) return ;
            //左
            traversal(tree-&gt;left);
            //中
            //第一个节点
            if(pre == NULL) &#123;
                count = 1;
            &#125;else if(pre-&gt;val == tree-&gt;val) &#123;
                count ++;
            &#125;else &#123;
                count = 1;
            &#125;
            pre = cur;
            if(count == maxCount) &#123;
                result.push_back(tree-&gt;val);
            &#125;
            if(count &gt; maxCount) &#123;
                maxCount = count;
                result.clear();
                result.push_back(tree-&gt;val);
            &#125;
            cur = cur-right;
        &#125;
    &#125;
       return result;
&#125;
</code></pre>
<h3 id="二叉树最近的公共祖先"><a href="#二叉树最近的公共祖先" class="headerlink" title="二叉树最近的公共祖先"></a>二叉树最近的公共祖先</h3><pre><code class="c++">TreeNode* lowestCommonAncestor(TreeNode* tree, TreeNode* p, TreeNode* q)  &#123;
       if(q == tree || p == tree || tree == NULL) return NULL;
    TreeNode* left = lowestCommonAncestor(tree-&gt;left);
    TreeNode* right = lowestCommonAncestor(tree-&gt;right);
    if(left != NULL &amp;&amp; right != NULL) return tree;
    if(left == NULL &amp;&amp; right != NULL) return right;
    else if(left != NULL &amp;&amp; right == NULL) return left;
    else if(left == NULL &amp;&amp; right == NULL) return NULL;
&#125;
</code></pre>
<h3 id="二叉搜索树最近的公共祖先"><a href="#二叉搜索树最近的公共祖先" class="headerlink" title="二叉搜索树最近的公共祖先"></a>二叉搜索树最近的公共祖先</h3><pre><code class="c++">TreeNode* traversal(TreeNode* tree, TreeNode* p, TreeNode* q) &#123;
    if(tree == NULL) return tree;
       //从左开始遍历
    if(tree-&gt;val &gt; p-&gt;val &amp;&amp; tree-&gt;val &gt; q-&gt;val) &#123;
        TreeNode* left = traversal(tree-&gt;left);
        if(left != NULL) &#123;
            return left;
        &#125;
    &#125;
    //从右开始遍历
    if(tree-&gt;val &lt; p-&gt;val &amp;&amp; tree-&gt;val &lt; q-&gt;val) &#123;
        TreeNode* right = traversal(tree-&gt;right);
        if(right != NULL) &#123;
             return right;
        &#125;
    &#125;
    //处在中间范围内的节点
    return tree;
&#125;
</code></pre>
<h3 id="迭代法-13"><a href="#迭代法-13" class="headerlink" title="迭代法"></a>迭代法</h3><pre><code class="c++">TreeNode* lowestCommonAncestor(TreeNode* tree, TreeNode* p, TreeNode* q) &#123;
    while(tree != NULL) &#123;
        if(tree-&gt;val &gt; p-&gt;val &amp;&amp; tree-&gt;val &gt; q-&gt;val) &#123;
               tree = tree-&gt;left;
        &#125;else if(tree-&gt;val &lt; p-&gt;val &amp;&amp; tree-&gt;val &lt; q-&gt;val) &#123;
            tree = tree-&gt;right;
        &#125;else &#123;
            return tree;
        &#125;
    &#125;
    return NULL;
&#125;
</code></pre>
<h3 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h3><h5 id="递归法-13"><a href="#递归法-13" class="headerlink" title="递归法"></a>递归法</h5><p>（有返回值）</p>
<pre><code class="c++">TreeNode* traversal(TreeNode* tree, int val) &#123;
    //结束条件
       if(tree == NULL) &#123;
        TreeNode* node = new TreeNode(val);
        return node;
    &#125;
    //判断值是否大于或是小于来决定遍历方向,并直接添加节点
    if(tree-&gt;val &gt; val) tree-&gt;left = traversal(tree-&gt;left, val);
    if(tree-&gt;val &lt; val) tree-&gt;right = traversal(tree-&gt;right, val);
    
    //返回原节点
    return tree;
&#125;
</code></pre>
<p>（无返回值） </p>
<pre><code class="c++">class Solution &#123;
    public:
    TreeNode* parent;
    void traversal(TreeNode* tree, int val) &#123;
        if(tree == NULL) &#123;
            TreeNode* node = new TreeNode(val);
            if(val &gt; parent-&gt;val) parent-&gt;right = node;
            else parent-&gt;left = node;
            return ;
        &#125;
        //记录当前的节点，作为下一节点的父节点
        parent = tree;
        if(tree-&gt;val &gt; val) traversal(tree-&gt;left, val);
        else if(tree-val &lt; val) traversal(tree-&gt;right, val);
        return ;
    &#125;
    TreeNode* insertIntoBST(TreeNode* tree, int val) &#123;
        parent = new TreeNode(0);
        if(tree == NULL) &#123;
            TreeNode* newNode = TreeNode(val);
        &#125;
        traversal(tree, val);
        return tree;
    &#125;
&#125;
</code></pre>
<h5 id="迭代法-14"><a href="#迭代法-14" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">TreeNode* insertIntoBST(TreeNode* tree) &#123;
    if(tree == NULL) &#123;
        TreeNode* node = new TreeNode(val);
        return node;
    &#125;
    TreeNode* cur = tree;
    //记录上一个节点
    TreeNode* parent = tree;
    while(cur != NULL) &#123;
        parent = cur;
        if(cur-&gt;val &gt; val) cur = cur-&gt;left;
        else if(cur-&gt;val &lt; val) cur = cur-&gt;right;
    &#125;
    //到空节点，定义一个新的节点
    TreeNode* node = new TreeNode(val);
    if(val &gt; parent-&gt;val) parent-&gt;right = node;
    else if(val &lt; parent-&gt;val) parent-&gt;left = node;
    return node;
&#125;
</code></pre>
<h3 id="删除二叉搜索树的节点"><a href="#删除二叉搜索树的节点" class="headerlink" title="删除二叉搜索树的节点"></a>删除二叉搜索树的节点</h3><p>有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<h5 id="迭代法-15"><a href="#迭代法-15" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">TreeNode* deleteNode(TreeNode* tree, int key) &#123;
    if(tree == NULL) return tree;
    if(tree-&gt;val ==key) &#123;
        //左右孩子都为空
        if(tree-&gt;left == NULL &amp;&amp; tree-&gt;right == NULL) &#123;
            delete tree;
        &#125;
        //左节点为空
        else if(tree-&gt;left == NULL &amp;&amp; tree-&gt;right != NULL) &#123;
            TreeNode* temp = tree;
            delete temp;
            return tree;
        &#125;
        //右节点为空
           else if(tree-&gt;right != NULL &amp;&amp; tree-&gt;left == NULL) &#123;
            TreeNode* temp = tree;
            delete temp;
            return tree;
        &#125;
           //左右节点都不为空
        else &#123;
            TreeNode* cur = tree-&gt;right;
            while(cur-&gt;left != NULL) &#123;
                cur = cur-&gt;left;
            &#125;
            cur-&gt;left = tree-&gt;left;
            tree = tree-&gt;right;
            TreeNode* temp = tree;
            delete temp;
            return tree;
        &#125;
    &#125;
    if(tree-&gt;val &gt; key) tree-left = traversal(tree-&gt;left);
    if(tree-&gt;val &lt; key) tree-&gt;right = traversal(tree-&gt;right);
    return tree;
&#125;
</code></pre>
<h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<pre><code class="c++">TreeNode* trimBST(TreeNode* tree, int L, int R) &#123;
    if(tree == NULL) return tree;
    if(tree-&gt;val &gt; R) &#123;
        TreeNode* left = traversal(tree-&gt;left);
        return left;
    &#125; 
    if(tree-&gt;val &lt; L) &#123;
        TreeNode* right = traversal(tree-&gt;right);
        return right;
    &#125;
    tree-&gt;left = traversal(tree-&gt;left);
    tree-&gt;right = traversal(tree-&gt;right);
    return tree;
&#125;
</code></pre>
<h5 id="迭代法-16"><a href="#迭代法-16" class="headerlink" title="迭代法"></a>迭代法</h5><p>因为二叉搜索树的有序性，不需要使用栈模拟递归的过程。</p>
<p>在剪枝的时候，可以分为三步：</p>
<ul>
<li>将root移动到[L, R] 范围内，注意是左闭右闭区间</li>
<li>剪枝左子树</li>
<li>剪枝右子树</li>
</ul>
<pre><code class="c++">TreeNode* trimBST(TreeNode* tree, int L, int R) &#123;
    if(tree == NULL) return NULL;
    //将节点移动到[L, R] 范围内
    while(tree != NULL &amp;&amp; (tree-&gt;val &lt; L || tree-&gt;val &gt; R)) &#123;
        if(tree-&gt;val &gt; L) tree = tree-&gt;left;
        else tree = tree-&gt;right;
    &#125;
    //修剪左子树
    TreeNode* cur = tree;
    while(cur != NULL) &#123;
        while(cur-&gt;left != NULL &amp;&amp; cur-&gt;left-&gt;val &lt; L) &#123;
            cur-&gt;left = cur-&gt;left-&gt;right;
        &#125;
        cur = cur-&gt;left;
    &#125;
    //恢复当前节点
    cur = tree;
    //修剪右子树
    while(cur != NULL) &#123;
        while(cur-&gt;right != NULL &amp;&amp; cur-&gt;right-&gt;val &gt; L) &#123;
            cur-&gt;right = cur-&gt;right-&gt;left;
        &#125;
        cur = cur-&gt;right;
    &#125;
    return tree;
&#125;
</code></pre>
<h4 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h4><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<pre><code class="c++">class Solution &#123;
    private:
    TreeNode* traversal(vector&lt;int&gt; nums, int left, int right) &#123;
        if(left &gt; right) return NULL;
        int mid = left + ((left + right) / 2);
        TreeNode* newNode = TreeNode(nums[mid]);
        newNode-&gt;left = traversal(nums, left, mid - 1);
        newNode-&gt;right = traversal(nums, mid + 1, right);
        return newNode;
    &#125;
    public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt; nums) &#123;
        TreeNode* node = traversal(nums, 0, nums.size() - 1);
        return node;
    &#125;
&#125;
</code></pre>
<h5 id="迭代法-17"><a href="#迭代法-17" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">TreeNode* sortedArrayToBST(vector&lt;int&gt; nums) &#123;
    if(nums.size() == 0) return NULL;
    //创建一个节点
    TreeNode* node = new TreeNode(0);
    //创建三个队列，存放新创建的节点，左数组区间，和右数组区间
    queue&lt;TreeNode*&gt; nodeQ;
    queue&lt;int&gt; leftQ;
    queue&lt;int&gt; rightQ;
    nodeQ.push(node);
    leftQ.push(0);
    rightQ.push(nums.size() - 1);
    while(! nodeQ.empty()) &#123;
        TreeNode* cur = nodeQ.front();
        nodeQ.pop();
        int left = leftQ.front();
        leftQ.pop();
        int right = rightQ.front();
        rightQ.pop();
        int mid = left + ((left + right) / 2);
        //给节点赋值
        node-&gt;val = nums[mid];
        //处理左边的节点
        if(left &lt; mid - 1) &#123;
              node-&gt;left = new TreeNode(0);
            nodeQ.push(node-&gt;left);
            leftQ.push(left);
            rightQ.push(mid - 1);
        &#125;
        //处理左边的节点
        if(right &gt; mid + 1) &#123;
            node-&gt;right = new TreeNode(0);
            nodeQ.push(node-&gt;right);
            leftQ.push(mid + 1);
            rightQ.push(right);
        &#125;
    &#125;
    return node;
&#125;
</code></pre>
<h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<h5 id="我们需要反中序遍历这个二叉树，然后顺序累加就可以了。"><a href="#我们需要反中序遍历这个二叉树，然后顺序累加就可以了。" class="headerlink" title="我们需要反中序遍历这个二叉树，然后顺序累加就可以了。"></a>我们需要反中序遍历这个二叉树，然后顺序累加就可以了。</h5><pre><code class="c++">class Solution &#123;
    private:
    int pre;
    void traversal(TreeNode* node) &#123;
        if(node == NULL) return ;
        //反中序遍历
        traversal(node-&gt;right);
           node-&gt;val += pre;
        pre = node-&gt;val;
        treversal(node-&gt;left);
    &#125;
    public:
    TreeNode* convertBST(TreeNode* tree) &#123;
        pre = 0;
        traversal(tree);
           return tree;
    &#125;
&#125;
</code></pre>
<h5 id="迭代法-18"><a href="#迭代法-18" class="headerlink" title="迭代法"></a>迭代法</h5><pre><code class="c++">TreeNode* convertBST(TreeNode* tree) &#123;
    int pre = 0;
       if(tree == NULL) return tree;
    stack&lt;int&gt; st;
    TreeNode* cur = tree;
    while(cur != NULL &amp;&amp; ! st.empty()) &#123;
        if(cur != NULL) &#123;
            st.push(cur);
            cur = cur-&gt;right;
        &#125;else &#123;
            cur = st.top();
            st.pop();
               cur-&gt;val += pre;
            pre = cur-&gt;val;
            cur = cur-&gt;right;
        &#125;
    &#125;
    return tree;
&#125;
</code></pre>
<ul>
<li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li>
<li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li>
<li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li>
</ul>
<p>注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，[二叉树：找所有路径 ]也用了前序，这是为了方便让父节点指向子节点。</p>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

                                        <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
        <script>
            const loader = document.querySelector('.load');
            const paper = document.querySelector('.paper');
            const ch_span = document.querySelector('.load .h-mes>#chs');
            const no_wait = document.querySelector('.load #noWait');
    
            const ch_array = ['" 或许再等一会.. "', '" 等待是为了更好的阅读体验 "', '" 就快加载完了 "', '" 还差一点... "', '" 感谢你的坚持 ! "']
            let i = 0, j = 0;
            var show_main = setInterval(() => {
                ch_span.innerHTML = ch_array[i];
                i > 3 ? i = 0 : i ++;
                j > 5 ? no_wait.style.display = 'block' : j ++;
            }, 1800);
            // console.log(23542365)
            window.addEventListener('load',showMain);
            no_wait.addEventListener('click', showMain);
    
            function showMain() {
                loader.style.display = 'none';
                paper.style.display = 'block';
                show_main = null;
                clearInterval(show_main);
                console.log(1)
            }
        </script>
    </body>
</html>