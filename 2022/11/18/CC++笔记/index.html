<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:600px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:600px)" href="/css/style.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <div class="bgimg"></div>
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            C/C++笔记
        </div>
        <div class="post-meta">
            2022-11-18
        </div>
    
<hr>
    <div class="post-md">
        <h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><pre><code class="c">//表示扫描除回车以外的字符
scanf(&quot;%[^\n]&quot;, xx);

//%* 表示跳过
</code></pre>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>宏</p>
<pre><code class="c">// &quot;\&quot; 将多行宏拼接为一行
#define Max(a, b) (&#123;\
    //根据参数获取类型
    __typeof(a) _a = (a);\
    __typeof(b) _b = (b);\
    _a &gt; _b ? _a : _b;\
&#125;)
    
#define P(a) (&#123;\
    //&#39;#&#39; 表示字符串化
    printf(&quot;%s = %d&quot;, #a, a);\
&#125;)

//__FILE__ //__func__ // __LINE__
//args -&gt; 变参宏
//frm —&gt; 格式控制
#define log(frm, args...) &#123;\
    printf(&quot;[%s, %s, %d]&quot;, __FILE__ , __func__, __LINE__)
    //&#39;##&#39; 表示连接
    printf(frm, ##args);\
    printf(&quot;\n&quot;);\
&#125;
printf(&quot;%d&quot;, xxx);

//后期去掉debug
#ifdef DEBUG
#define  log(frm, args...) &#123;\
    ...
&#125;
#else 
#define log(frm, args...)

//函数上方添加，将会优先于 main 函数
__attribute__((constructor))
</code></pre>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><pre><code class="c">if(str[i][j] != &#39;B&#39;) continue;
//&#39;n&#39; 表示安全操作
if(strncmp(str[i][j], &quot;xxx&quot;, 3)) continue; 
strncpy(str[i][j], &quot;xxxx&quot;, 4);
//移位
move(str[i][j] + 4);


//move
void move(char *p) &#123;
    int i = 0;
       for(; p[i]; i++) &#123;
        p[i] = p[i++]
    &#125;
    p[i] = &#39;\0&#39;;
    return ;
&#125;
</code></pre>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><blockquote>
<p>调用函数灵活修改实参变量的值</p>
<p>支持动态内存分配，方便实现动态的数据结构</p>
<p>提高某些程序的效率</p>
<p>实现缓冲方式文件存取</p>
</blockquote>
<p>指针转换</p>
<pre><code class="c">//void * 
(int *) malloc(20);
</code></pre>
<p>字符数组</p>
<pre><code class="c">char a[] = &quot;werwe&quot;;
char *p
p = a // p = &amp;a[0]
</code></pre>
<p>字符数组存储在全局数据区或栈区，字符指针的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）<code>只有读取权限，没有写入权限。</code></p>
<p>函数指针</p>
<pre><code class="c">//p 为函数的地址
//p = strcmp
void process(char *a, char *b, int(* p)(const char*, const char *))
</code></pre>
<p>字符串转化大小写</p>
<pre><code class="text">#define CONVERT(c) (((c) &gt;= &#39;A&#39; &amp;&amp; (c) &lt;= &#39;Z&#39;) ? ((c) - &#39;A&#39; + &#39;a&#39;) : (c))
</code></pre>
<p>当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。</p>
<pre><code class="c">unsigned int aa;
</code></pre>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><blockquote>
<p>默认用最大的字节来对齐</p>
</blockquote>
<pre><code class="c">//结构体变量
//函数的传递结构体
void output(struct stru str[2])//结构体数组
    
//结构体指针
struct student &#123;
    long num;
    char *name; // char name[20]
&#125;
struct student stu;
struct student *p;
p = &amp;stu;
stu.name = 123;
//指针数组分配内存
stu.name = (char *)malloc(20);

(*p).name ==&gt; p-&gt;name
</code></pre>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><blockquote>
<p>将几种不同类型的变量存放在同一内存单元中，实现覆盖技术</p>
</blockquote>
<pre><code class="c">union IP &#123;
       struct &#123;
        unsigned char a1;
        unsigned char a2;
        unsigned char a3;
        unsigned char a4;
    &#125; ip;
    unsigned int num;
&#125;
</code></pre>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><pre><code class="c++">//输出
std::cout &lt;&lt; &quot;123123\n&quot;;
//输入
unsigned int aa;
std::cin &gt;&gt; aa

//系统        
system(&quot;cls/ shutdown /a/ pause &quot;);

//定义变量
int year&#123; 12 &#125;
</code></pre>
<h5 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h5><pre><code class="c++">static_cast&lt;int&gt;
//(int) c
</code></pre>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><pre><code class="c++">enum class EquipLv: int &#123;
    normal = 10,
    high,
    rare
&#125;;
EquipLv weapon1 (EquipLv::normal);
EquipLv weapon2 (EquipLv::rare);
</code></pre>
<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><pre><code class="c++">using namespace std;
//之后不用使用std
/
using std::cin/cout;
</code></pre>
<pre><code class="c++">namespace Game &#123;
    int HP&#123; 1000 &#125;;
    namespace Weapon &#123;
        int damage&#123; 3000 &#125;
    &#125;
&#125;
//使用时 ‘::’ 限定符
int c = Game::Weapon::HP;
//不能放在函数体内
</code></pre>
<p>if 与 switch 中的临时变量</p>
<pre><code class="c++">//17语法
if(int a, b, c; 条件)

switch(int a, b; 条件)
</code></pre>
<h5 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h5><pre><code class="c++">#include &lt;coion.h&gt;

_getch();
</code></pre>
<h5 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h5><pre><code class="c++">#include &lt;iomanip&gt;

std::cout &lt;&lt; std::setfill(&#39;0&#39;);
std::cout &lt;&lt; std::setw(3) &lt;&lt; xx
</code></pre>
<h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><pre><code class="c++">for(int aa : 数组);
</code></pre>
<h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><pre><code class="c++">#include &lt;array&gt;
//较为安全的定义数组
std::array&lt;int, 3&gt; shu&#123;1, 2, 3&#125;;
//填充
shu.fill(23);
//元素个数
shu.size();
//访问成员
shu.at(2)
    
//向量
std::vector&lt;int&gt; studentId;
//动态添加一个元素
studentId.push_back(9600);
studentId.clear();
//判断是否为空
studentId.empty();
</code></pre>
<h5 id="判断一段程序是由c编译还是由c-编译程序编译的？"><a href="#判断一段程序是由c编译还是由c-编译程序编译的？" class="headerlink" title="判断一段程序是由c编译还是由c++编译程序编译的？"></a>判断一段程序是由c编译还是由c++编译程序编译的？</h5><pre><code class="cpp">#ifdef __cplusplus
    cout &lt;&lt; &quot;c++&quot;;
#else
    printf(&quot;c&quot;);
#endif
</code></pre>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><pre><code class="c++">int * pa = (int *) malloc(4);
//
int * pa = new int[5];

pa = (int *) realloc(pa, 8);

//内存释放
free(pa);
//释放new分配的内存
delete[] pa;
</code></pre>
<h5 id="风险："><a href="#风险：" class="headerlink" title="风险："></a>风险：</h5><p>碎片化的内存</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>不能改变其他引用</p>
<pre><code class="c++">int a&#123;500&#125;;
int &amp; la&#123;a&#125;;
int &amp; lla&#123;a&#125;;
</code></pre>
<p>数组引用</p>
<pre><code class="c++">int a[100];
int (&amp;b)[100] = a
</code></pre>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><pre><code class="c++">std::unique_ptr&lt;类型&gt; intPtr&#123;&#125;;
//
std::unique_ptr&lt;类型&gt; intPtr&#123;std::make_unique&lt;int []&gt;(5 &gt;个数) &#125;;

//释放内存,地址清零
intPtr.reset();
</code></pre>
<p>共享指针</p>
<pre><code class="c++">std::share_ptr&lt;类型&gt; intPtr&#123;&#125;;
</code></pre>
<p>安全的C语言输入</p>
<pre><code class="c++">char str[0xff]
wscanf_s(&quot;%s&quot;, wstr, 可接受最大字符值);
</code></pre>
<h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><pre><code class="c++">typedef struct Role &#123;
    int HP;
&#125;* PRole, * ARole;

Role user;
PRole puser = &amp;user;
//
PRole puesr = new Role;
//使用
puser-&gt;HP;
</code></pre>
<h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><pre><code class="c++">union USER &#123;
    short sHp;
    int nHp;
&#125;
</code></pre>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code class="c++">//截取起始位置， 个数
std::string str&#123;&quot;sdfsjd 123&quot;,1 ,3&#125;;
using std::string;
str.length();

//复制，（个数， ‘字符’）
std::string str(6, &#39;a&#39;);

//拼接
str.append(&quot;234&quot;);
//截取
str.substr(1);/ str.substr(1, 3);
//比较
str.compare(&quot;123&quot;);/ str.compare(1, 3, &quot;123&quot;);
//查找/反向为 rfind
str.find(&quot;123&quot;);/ str.find(&quot;123&quot;, 1, 3);

//未找到返回 std:string::npos int返回 -1

//插入
str.insert(位置, &quot;123&quot;);
//insert(位置, “123”, 截取起始, 截取长度);
str.insert(位置, 个数, &#39;8&#39;); // 插入字符

//替换 长度
str.replace(1, 3, &quot;123&quot;);

//删除，清除
str.erase(); / str.clear();
</code></pre>
<p>计算中文字符长度</p>
<pre><code class="c++">if(str[i] &lt; 0) i++;
count += 1;
</code></pre>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="c++">//传递引用参数  
bool act(const Role&amp; Acter)
//默认参数, 放在最后
int add(int a, int b = 100)
</code></pre>
<h5 id="不定量参数"><a href="#不定量参数" class="headerlink" title="不定量参数"></a>不定量参数</h5><pre><code class="c++">int Average(int count, ...) &#123;
    char * arg;
    //存储
    va_start(arg, count);
    //依次读取
    int x = va_arg(arg, int);
    //释放
    va_end(arg);
&#125;
</code></pre>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>声明函数指针<code>类型</code></p>
<pre><code class="c++">int Add(int a, int b) &#123;
    return a + b;
&#125;

typedef char(*pfAdd) (int, int);
//
using pFAdd = char (*) (int, int);

pfAdd pAdd = (pfAdd) Add;
</code></pre>
<p>声明函数指针</p>
<pre><code class="c++">int (*pxAdd) (int, int) = Add;

pxAdd(100, 100);
</code></pre>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>参数类型不同，参数个数不同，函数名相同</p>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><pre><code class="c++">template &lt;typename t1, typename t2,,,&gt; 
t1 ave(t1 a, t2 b) &#123;
    t1 x;
    t2 *px;
    return (a + b)/2;
&#125;
//指定类型
ave &lt;int, float&gt; (123, 123); 
</code></pre>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>