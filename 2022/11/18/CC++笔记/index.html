<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:700px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:700px)" href="/css/stylePC.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>
<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <!-- <div class="bgimg"></div> -->
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            C/C++笔记
        </div>
        <div class="post-meta">
            2022-11-18
        </div>
    
<hr>
    <div class="post-md">
        <h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><h5 id="“-“-将多行宏拼接为一行"><a href="#“-“-将多行宏拼接为一行" class="headerlink" title="“\“ 将多行宏拼接为一行"></a>“\“ 将多行宏拼接为一行</h5><pre><code class="c">//获取最大值
#define Max(a, b) (&#123;\
    //根据参数获取类型
    __typeof(a) _a = (a);\
    __typeof(b) _b = (b);\
    _a &gt; _b ? _a : _b;\
&#125;)
    
#define P(a) (&#123;\
    //&#39;#a&#39; 表示字符串化a
    printf(&quot;%s = %d&quot;, #a, a);\
&#125;)
</code></pre>
<blockquote>
<h5 id="args-gt-变参宏"><a href="#args-gt-变参宏" class="headerlink" title="args -&gt; 变参宏"></a>args -&gt; 变参宏</h5><h5 id="frm-gt-格式控制"><a href="#frm-gt-格式控制" class="headerlink" title="frm -&gt; 格式控制"></a>frm -&gt; 格式控制</h5><p><code>__FILE__</code>宏用于检查当前文件名</p>
<p><code>__FUNCTION__</code>/ <code>__func__</code>宏输出当前函数名</p>
<p><code>__LINE__</code>宏输出当前代码是该文件中的第几行</p>
</blockquote>
<pre><code class="c">#define log(frm, args...) &#123;\
    printf(&quot;[%s, %s, %d]&quot;, __FILE__ , __func__, __LINE__);\
    
    //##args 表示把args…中的多个参数，串连起来。
    //如果写成 #fmt的话，就是把fmt传进来的内容以字符串形式输出。
    printf(frm, ##args);\
    printf(&quot;\n&quot;);\
&#125;
printf(&quot;%d&quot;, xxx);

//函数上方添加，将会优先于 main 函数
__attribute__((constructor))
</code></pre>
<h5 id="宏定义debug"><a href="#宏定义debug" class="headerlink" title="宏定义debug"></a>宏定义debug</h5><pre><code class="c">//后期去掉debug
#ifdef DEBUG
#define  log(frm, args...) &#123;\
    ...
&#125;
#else 
#define log(frm, args...)
</code></pre>
<h5 id="字符转化大小写"><a href="#字符转化大小写" class="headerlink" title="字符转化大小写"></a>字符转化大小写</h5><pre><code class="c">#define CONVERT(c) (((c) &gt;= &#39;A&#39; &amp;&amp; (c) &lt;= &#39;Z&#39;) ? ((c) - &#39;A&#39; + &#39;a&#39;) : (c))
</code></pre>
<p>当表达式中存在有符号类型和无符号类型时所有的操作，</p>
<p>数都自动转换为无符号类型。</p>
<pre><code class="c">unsigned int aa;
</code></pre>
<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><pre><code class="c">//表示扫描除回车以外的字符
//%* 表示跳过
scanf(&quot;%[^\n]&quot;, xx);
</code></pre>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>1.调用函数灵活修改实参变量的值</p>
<p>2.支持动态内存分配，方便实现动态的数据结构</p>
<p>3.提高某些程序的效率</p>
<p>4.实现缓冲方式文件存取</p>
</blockquote>
<h3 id="malloc-calloc-realloc-区别"><a href="#malloc-calloc-realloc-区别" class="headerlink" title="malloc / calloc  / realloc 区别"></a>malloc / calloc  / realloc 区别</h3><h4 id="（1）malloc函数"><a href="#（1）malloc函数" class="headerlink" title="（1）malloc函数"></a>（1）malloc函数</h4><p>其原型void *malloc(unsigned int num_bytes)；<br>num_byte为要申请的空间大小，需要我们手动的去计算</p>
<pre><code class="c">//指针转换
int *p = (int *)malloc(20*sizeof(int))
</code></pre>
<p>如果编译器默认int为4字节存储的话，那么计算结果是80Byte，</p>
<p>一次申请一个80Byte的连续空间，并将空间基地址强制转换为int类型，赋值给指针p,此时申请的内存值是不确定的。</p>
<h4 id="（2）calloc函数"><a href="#（2）calloc函数" class="headerlink" title="（2）calloc函数"></a>（2）calloc函数</h4><p>其原型void *calloc(size_t n, size_t size)；<br>不需要人为的计算空间的大小</p>
<pre><code class="c">int *p = (int *)calloc(20, sizeof(int)）
</code></pre>
<p>省去了人为空间计算的麻烦。malloc申请后空间的值是随机的，并没有进行初始化，</p>
<p>而calloc却在申请后，对空间逐一进行初始化，并设置值为0。</p>
<p>因此calloc 较于 malloc 效率较低。</p>
<h4 id="（3）realloc函数"><a href="#（3）realloc函数" class="headerlink" title="（3）realloc函数"></a>（3）realloc函数</h4><p>和上面两个有本质的区别，其原型void realloc(void *ptr, size_t new_Size)</p>
<p>用于对动态内存进行扩容(及已申请的动态空间不够使用，需要进行空间扩容操作)，ptr为指向原来空间基址的指针， new_size为接下来需要扩充容量的大小。</p>
<pre><code class="c">int size = 2000;
int *p = (int *)malloc(20*sizeof(int));
int *pp = (int *)realloc(p, size*sizeof(int));
</code></pre>
<p><code>如果size较小</code>，原来申请的动态内存后面还有空余内存，系统将直接在原内存空间后面扩容，并返回原动态空间基地址；</p>
<p><code>如果size较大</code>，原来申请的空间后面没有足够大的空间扩容，系统将重新申请一块(20+size)*sizeof(int)的内存，并把原来空间的内容拷贝过去，原来空间free;</p>
<p><code>如果size非常大</code>，系统内存申请失败，返回NULL,原来的内存不会释放。注意：如果扩容后的内存空间较原空间小，将会出现数据丢失，如果直接realloc(p, 0);相当于free(p).</p>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><pre><code class="c">char a[] = &quot;hello&quot;;
</code></pre>
<h5 id="指针指向字符数组"><a href="#指针指向字符数组" class="headerlink" title="指针指向字符数组"></a>指针指向字符数组</h5><pre><code class="c">char *p
p = a; 
// p = &amp;a[0]
</code></pre>
<h4 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h4><pre><code class="c">char *str = &quot;hello&quot;;
</code></pre>
<p>字符数组存储在<code>全局数据区或栈区</code></p>
<p>字符指针的字符串存储在<code>常量区</code>。</p>
<p>全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）<code>只有读取权限，没有写入权限。</code></p>
<h4 id="字符数组操作"><a href="#字符数组操作" class="headerlink" title="字符数组操作"></a>字符数组操作</h4><pre><code class="c">if(str[i][j] != &#39;B&#39;) continue;
//&#39;n&#39; 表示安全操作
if(strncmp(str[i][j], &quot;xxx&quot;, 3)) continue; 
strncpy(str[i][j], &quot;xxxx&quot;, 4);
//移位
move(str[i][j] + 4);


//move
void move(char *p) &#123;
    int i = 0;
       for(; p[i]; i++) &#123;
        p[i] = p[i++]
    &#125;
    p[i] = &#39;\0&#39;;
    return ;
&#125;
</code></pre>
<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><pre><code class="c">//p 为函数的地址
//p = strcmp
void process(char *a, char *b, int(* p)(const char*, const char *))
</code></pre>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><blockquote>
<p>默认用最大的字节来对齐</p>
</blockquote>
<h4 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h4><pre><code class="c">//函数的传递结构体
void output(struct stru str[2])//结构体数组
</code></pre>
<h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><pre><code class="c">struct Student &#123;
    long num;
    char *name; // char name[20]
&#125;
struct student stu;
struct student *p;
p = &amp;stu;
p-&gt;num = 123;
//指针数组分配内存
p-&gt;name = (char *)malloc(20);
</code></pre>
<h5 id="结构体指针的形式"><a href="#结构体指针的形式" class="headerlink" title="结构体指针的形式"></a>结构体指针的形式</h5><pre><code class="c">(*p).name ==&gt; p-&gt;name
</code></pre>
<h4 id="定义指针类型"><a href="#定义指针类型" class="headerlink" title="定义指针类型"></a>定义指针类型</h4><pre><code class="c">typedef struct Student &#123;
    int HP;
&#125;Stu, * PStu;

PStu newStu = (PStu) malloc(sizeof(Stu));
newStu-&gt;HP = 1000;
</code></pre>
<h4 id="结构体构建队列"><a href="#结构体构建队列" class="headerlink" title="结构体构建队列"></a>结构体构建队列</h4><pre><code class="c">#include &lt;assert.h&gt;

typedef struct QueNode &#123;
    int val;
    //单向队列
    struct QueNode* next;
&#125;QNode;
typedef struct Que &#123;
    //指向队列尾部
    QNode* tail;
    //指向队列头部
    QNode* head;
&#125;Que;
//队列初始化
void QueInit(Que* que) &#123;
    //assert()宏接受一个整形表达式参数。
    //如果表达式的值为假，assert()宏就会调用_assert函数在标准错误流中打印一条错误信息，并调用abort()
    //（abort()函数的原型在stdlib.h头文件中）函数终止程序。
    assert(que);
    que-&gt;tail = que-&gt;head = NULL;
&#125;
</code></pre>
<h5 id="数据入队列"><a href="#数据入队列" class="headerlink" title="数据入队列"></a>数据入队列</h5><pre><code class="c">void push(Que* que, int val) &#123;
    assert(que);
    Que* newNode = (QNode *) malloc(sizeof(QNode));
    newNode-&gt;val = val;
    newNode-&gt;next = NULL;
    //队列为空
    if(que-&gt;tail == NULL) &#123;
        que-&gt;tail = que-&gt;head = newNode;
    &#125;else &#123;
        //尾指针指向的节点，下一个节点指向新节点
        que-tail-&gt;next = newNode;
        //尾指针指向新节点
        que-&gt;tail = newNode;
    &#125;
&#125;
</code></pre>
<h5 id="数据出队列"><a href="#数据出队列" class="headerlink" title="数据出队列"></a>数据出队列</h5><pre><code class="c">void pop(Que* que) &#123;
    assert(que);
       assert(que-&gt;head);s
    //只有一个节点
    if(que-&gt;head-&gt;next == NULL) &#123;
        que-&gt;tail = que-&gt;head = NULL;
         return ;   
    &#125;
    Que* temp = que-&gt;head;
    que-&gt;head = que-&gt;head-&gt;next;
    free(temp);
&#125;
</code></pre>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><blockquote>
<p>将几种不同类型的变量存放在同一内存单元中，实现覆盖技术</p>
</blockquote>
<pre><code class="c">union IP &#123;
       struct &#123;
        unsigned char a1;
        unsigned char a2;
        unsigned char a3;
        unsigned char a4;
    &#125; ip;
    unsigned int num;
&#125;
</code></pre>
<h2 id="传递二维数组"><a href="#传递二维数组" class="headerlink" title="传递二维数组"></a>传递二维数组</h2><h5 id="1-传递时指指定列数"><a href="#1-传递时指指定列数" class="headerlink" title="1.传递时指指定列数"></a>1.传递时指指定列数</h5><pre><code class="c">void foo(int a[][3], int m, int n)
</code></pre>
<h5 id="2-参数声明为一个指向数组的指针"><a href="#2-参数声明为一个指向数组的指针" class="headerlink" title="2.参数声明为一个指向数组的指针"></a>2.参数声明为一个指向数组的指针</h5><pre><code class="c">void foo(int (*a)[3], int m, int n)
</code></pre>
<h5 id="3-把参数声明为指向指针的指针"><a href="#3-把参数声明为指向指针的指针" class="headerlink" title="3.把参数声明为指向指针的指针"></a>3.把参数声明为指向指针的指针</h5><pre><code class="c">void foo(int **a, int m, int n)
    
    int a[2][3] = &#123;
        &#123;1,2,3&#125;,
        &#123;4,5,6&#125;
    &#125;;
    int * p[3] = &#123;a[0], a[1], a[2]&#125;;
    foo(p, 2, 3);
</code></pre>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><pre><code class="c++">//输出
std::cout &lt;&lt; &quot;123123\n&quot;;
//输入
unsigned int aa;
std::cin &gt;&gt; aa

//系统        
system(&quot;cls/ shutdown /a/ pause &quot;);

//定义变量
int year&#123; 12 &#125;
</code></pre>
<h5 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h5><pre><code class="c++">static_cast&lt;int&gt;
//(int) c
</code></pre>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><pre><code class="c++">enum class EquipLv: int &#123;
    normal = 10,
    high,
    rare
&#125;;
EquipLv weapon1 (EquipLv::normal);
EquipLv weapon2 (EquipLv::rare);
</code></pre>
<h5 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h5><pre><code class="c++">using namespace std;
//之后不用使用std
/
using std::cin/cout;
</code></pre>
<pre><code class="c++">namespace Game &#123;
    int HP&#123; 1000 &#125;;
    namespace Weapon &#123;
        int damage&#123; 3000 &#125;
    &#125;
&#125;
//使用时 ‘::’ 限定符
int c = Game::Weapon::HP;
//不能放在函数体内
</code></pre>
<p>if 与 switch 中的临时变量</p>
<pre><code class="c++">//17语法
if(int a, b, c; 条件)

switch(int a, b; 条件)
</code></pre>
<h5 id="获取键盘输入"><a href="#获取键盘输入" class="headerlink" title="获取键盘输入"></a>获取键盘输入</h5><pre><code class="c++">#include &lt;coion.h&gt;

_getch();
</code></pre>
<h5 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h5><pre><code class="c++">#include &lt;iomanip&gt;

std::cout &lt;&lt; std::setfill(&#39;0&#39;);
std::cout &lt;&lt; std::setw(3) &lt;&lt; xx
</code></pre>
<h5 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h5><pre><code class="c++">for(int aa : 数组);
</code></pre>
<h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><pre><code class="c++">#include &lt;array&gt;
//较为安全的定义数组
std::array&lt;int, 3&gt; shu&#123;1, 2, 3&#125;;
//填充
shu.fill(23);
//元素个数
shu.size();
//访问成员
shu.at(2)
    
//向量
std::vector&lt;int&gt; studentId;
//动态添加一个元素
studentId.push_back(9600);
studentId.clear();
//判断是否为空
studentId.empty();
</code></pre>
<h5 id="判断一段程序是由c编译还是由c-编译程序编译的？"><a href="#判断一段程序是由c编译还是由c-编译程序编译的？" class="headerlink" title="判断一段程序是由c编译还是由c++编译程序编译的？"></a>判断一段程序是由c编译还是由c++编译程序编译的？</h5><pre><code class="cpp">#ifdef __cplusplus
    cout &lt;&lt; &quot;c++&quot;;
#else
    printf(&quot;c&quot;);
#endif
</code></pre>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><pre><code class="c++">int * pa = (int *) malloc(4);
//
int * pa = new int[5];

pa = (int *) realloc(pa, 8);

//内存释放
free(pa);
//释放new分配的内存
delete[] pa;
</code></pre>
<h5 id="风险："><a href="#风险：" class="headerlink" title="风险："></a>风险：</h5><p>碎片化的内存</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>不能改变其他引用</p>
<pre><code class="c++">int a&#123;500&#125;;
int &amp; la&#123;a&#125;;
int &amp; lla&#123;a&#125;;
</code></pre>
<p>数组引用</p>
<pre><code class="c++">int a[100];
int (&amp;b)[100] = a
</code></pre>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><pre><code class="c++">std::unique_ptr&lt;类型&gt; intPtr&#123;&#125;;
//
std::unique_ptr&lt;类型&gt; intPtr&#123;std::make_unique&lt;int []&gt;(5 &gt;个数) &#125;;

//释放内存,地址清零
intPtr.reset();
</code></pre>
<p>共享指针</p>
<pre><code class="c++">std::share_ptr&lt;类型&gt; intPtr&#123;&#125;;
</code></pre>
<p>安全的C语言输入</p>
<pre><code class="c++">char str[0xff]
wscanf_s(&quot;%s&quot;, wstr, 可接受最大字符值);
</code></pre>
<h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><pre><code class="c++">typedef struct Role &#123;
    int HP;
&#125;* PRole, * ARole;

Role user;
PRole puser = &amp;user;
//
PRole puesr = new Role;
//使用
puser-&gt;HP;
</code></pre>
<h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><pre><code class="c++">union USER &#123;
    short sHp;
    int nHp;
&#125;
</code></pre>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><pre><code class="c++">//截取起始位置， 个数
std::string str&#123;&quot;sdfsjd 123&quot;,1 ,3&#125;;
using std::string;
str.length();

//复制，（个数， ‘字符’）
std::string str(6, &#39;a&#39;);

//拼接
str.append(&quot;234&quot;);
//截取
str.substr(1);/ str.substr(1, 3);
//比较
str.compare(&quot;123&quot;);/ str.compare(1, 3, &quot;123&quot;);
//查找/反向为 rfind
str.find(&quot;123&quot;);/ str.find(&quot;123&quot;, 1, 3);

//未找到返回 std:string::npos int返回 -1

//插入
str.insert(位置, &quot;123&quot;);
//insert(位置, “123”, 截取起始, 截取长度);
str.insert(位置, 个数, &#39;8&#39;); // 插入字符

//替换 长度
str.replace(1, 3, &quot;123&quot;);

//删除，清除
str.erase(); / str.clear();
</code></pre>
<p>计算中文字符长度</p>
<pre><code class="c++">if(str[i] &lt; 0) i++;
count += 1;
</code></pre>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code class="c++">//传递引用参数  
bool act(const Role&amp; Acter)
//默认参数, 放在最后
int add(int a, int b = 100)
</code></pre>
<h5 id="不定量参数"><a href="#不定量参数" class="headerlink" title="不定量参数"></a>不定量参数</h5><pre><code class="c++">int Average(int count, ...) &#123;
    char * arg;
    //存储
    va_start(arg, count);
    //依次读取
    int x = va_arg(arg, int);
    //释放
    va_end(arg);
&#125;
</code></pre>
<h4 id="函数指针-1"><a href="#函数指针-1" class="headerlink" title="函数指针"></a>函数指针</h4><p>声明函数指针<code>类型</code></p>
<pre><code class="c++">int Add(int a, int b) &#123;
    return a + b;
&#125;

typedef char(*pfAdd) (int, int);
//
using pFAdd = char (*) (int, int);

pfAdd pAdd = (pfAdd) Add;
</code></pre>
<p>声明函数指针</p>
<pre><code class="c++">int (*pxAdd) (int, int) = Add;

pxAdd(100, 100);
</code></pre>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>参数类型不同，参数个数不同，函数名相同</p>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><pre><code class="c++">//设置默认值 
template &lt;typename t1=int, typename t2,,,&gt; 
t1 ave(t1 a, t2 b) &#123;
    t1 x;
    t2 *px;
    return (a + b)/2;
&#125;
//指定类型
ave &lt;int, float&gt; (123, 123); 

//模板参数
template &lt;typename t1, short count&gt;
t1 ave(t1 (&amp;ary) [count]) &#123;
    for (int i = 0; i &lt; count; i++)
&#125;
</code></pre>
<p>头文件</p>
<pre><code class="c++">//多次引用只生效一次
#pragma once
//有定义才执行
#ifdef aa
</code></pre>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><pre><code class="c++">class ROLE &#123;
    private: 
        int damage;
    public: 
        int hp;
        void act();
        void init() &#123;
            hp = 1;
        &#125;
   //构造函数
   ROLE() &#123;
       cout &lt;&lt; &quot;构造&quot;;
   &#125;
   //默认构造
    ROLE() = default;
&#125;
ROLE aa&#123;&#125;;  
//外联
//以引用的形式返回
ROLE&amp; ROLE::act () &#123;
    cout &lt;&lt; &quot;23423&quot;;
    //返回指针
    return *this;
&#125;
</code></pre>
<h5 id="禁止类型转换"><a href="#禁止类型转换" class="headerlink" title="禁止类型转换"></a>禁止类型转换</h5><pre><code class="c++">explicit Role() &#123;&#125;
</code></pre>
<h5 id="成员初始化列表"><a href="#成员初始化列表" class="headerlink" title="成员初始化列表"></a>成员初始化列表</h5><blockquote>
<p>效率更高</p>
<p>在某些情况下，只能用这种方式进行初始化</p>
</blockquote>
<pre><code class="c++">Role(int _lv, int _damage): lv&#123;_lv&#125;, damage&#123;_damage&#125; &#123;
    
&#125;
</code></pre>
<h5 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h5><blockquote>
<p>只能委托一次</p>
</blockquote>
<pre><code class="c++">Role(int _lv, int _damage):Role(_lv)&#123;&#125;
</code></pre>
<h5 id="副本构造"><a href="#副本构造" class="headerlink" title="副本构造"></a>副本构造</h5><pre><code class="c++">Role(Role &amp; role): hp( role.hp)
</code></pre>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数在类的生命结束时，自动调用，若没有则会添加一个空的析构函数，且只能有一个</p>
<pre><code class="c++">~Role = default;
</code></pre>
<h4 id="Static-静态成员函数"><a href="#Static-静态成员函数" class="headerlink" title="Static 静态成员函数"></a>Static 静态成员函数</h4><blockquote>
<p>没有创建实例，都可以访问静态成员函数</p>
<p>静态成员函数不能访问非静态成员变量</p>
<p>不能是 const</p>
<p>不能使用 this 指针</p>
</blockquote>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元函数</p>
<pre><code class="c++">class T &#123;
    friend void Set(T&amp; t1);
&#125;
void Set(T&amp; t1) &#123;&#125;
</code></pre>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><pre><code class="c++">class Role &#123;
    class Weapon &#123;
        int lv;
    &#125;
&#125;
Role::Weapon wp;
</code></pre>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>