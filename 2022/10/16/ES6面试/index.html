<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:600px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:600px)" href="/css/style.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <!-- <div class="bgimg"></div> -->
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            ES6面试
        </div>
        <div class="post-meta">
            2022-10-16
        </div>
    
<hr>
    <div class="post-md">
        <h2 id="var-let-const之间的区别"><a href="#var-let-const之间的区别" class="headerlink" title="var, let , const之间的区别"></a>var, let , const之间的区别</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><blockquote>
<p>声明的变量既是全局变量，也是顶级变量</p>
<p>存在变量提升</p>
<p>可以多次声明，前面的会覆盖后面的</p>
<p>函数中是局部的</p>
</blockquote>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote>
<p>块级作用域</p>
<p>没有变量提升，声明前不存在，“暂时性死区”</p>
<p>不允许重复</p>
</blockquote>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote>
<p>声明简单数据类型为常量，不能改变</p>
<p>声明复杂数据类型，保存指向实际数据的指针，变量的结构可以改变</p>
<p>块级作用域</p>
<p>没有变量提升，声明前不存在，“暂时性死区”</p>
</blockquote>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<p>主要用于函数调用的时候，将一个数组变为参数序列</p>
<pre><code class="js">const numbers = [4, 38];
add(...numbers) // 42

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>可以简单实现复制与合并数组</p>
<p>通过扩展运算符实现的是<code>浅拷贝</code></p>
<p>将字符串转为数组</p>
<pre><code class="js">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<ul>
<li><p>遍历器（Iterator）。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<h4 id="遍历器的作用"><a href="#遍历器的作用" class="headerlink" title="遍历器的作用"></a>遍历器的作用</h4><p>（1）为各种数据结构，提供一个统一的、简便的访问接口；<br>（2）使得数据结构的成员能够按某种次序排列；<br>（3） ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费（for of遍历的对象必须存在遍历器接口 才可以遍历）</p>
<h4 id="Iterator-的遍历过程"><a href="#Iterator-的遍历过程" class="headerlink" title="Iterator 的遍历过程"></a>Iterator 的遍历过程</h4><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。<br>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。<br>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。<br>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。<br>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>
</li>
</ul>
<h5 id="关于构造函数，数组新增的方法有如下："><a href="#关于构造函数，数组新增的方法有如下：" class="headerlink" title="关于构造函数，数组新增的方法有如下："></a>关于构造函数，数组新增的方法有如下：</h5><blockquote>
<ul>
<li><p>Array.from()</p>
<p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
</li>
<li><p>Array.of()</p>
<p>用于将一组值，转换为数组</p>
<p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，Array()才会返回由参数组成的新数组</p>
</li>
</ul>
</blockquote>
<p>Array.from()</p>
<pre><code class="js">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<h2 id="关于数组实例对象新增的方法"><a href="#关于数组实例对象新增的方法" class="headerlink" title="关于数组实例对象新增的方法"></a>关于数组实例对象新增的方法</h2><blockquote>
<ul>
<li><h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<p>参数如下：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="js">[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5]
</code></pre>
<blockquote>
<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>参数是一个回调函数，接受三个参数依次为value, key, arr</p>
<h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h4><p>返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</p>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
</blockquote>
<blockquote>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p>使用给定值，填充一个数组</p>
<p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
</blockquote>
<blockquote>
<p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>用于判断数组是否包含给定的值</p>
<h4 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h4><p>将数组扁平化处理(降维)，返回一个新数组，对原数据没有影响</p>
</blockquote>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数设置默认值"><a href="#参数设置默认值" class="headerlink" title="参数设置默认值"></a>参数设置默认值</h4><pre><code class="js">function def(x, y = &#39;default&#39;) &#123;
  console.log(x, y);
&#125;
</code></pre>
<h5 id="与解构结合"><a href="#与解构结合" class="headerlink" title="与解构结合"></a>与解构结合</h5><pre><code class="js">function def(&#123;x, y = 5&#125;)
</code></pre>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h5 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h5><p><code>length</code>将返回没有指定默认值的参数个数</p>
<p><code>rest</code> 参数也不会计入<code>length</code>属性</p>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>返回该函数的函数名</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>
<h3 id="Set、Map"><a href="#Set、Map" class="headerlink" title="Set、Map"></a>Set、Map</h3><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<ul>
<li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合 </li>
<li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同 </li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>成员的值都是唯一的，没有重复的值</p>
<p><code>Set</code>的实例关于增删改查的方法：</p>
<blockquote>
<ul>
<li> add() </li>
<li> delete() </li>
<li> has() </li>
<li> clear() </li>
</ul>
</blockquote>
<p>关于遍历的方法，有如下：</p>
<blockquote>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</blockquote>
<pre><code class="js">for(let item of set.keys()) &#123;
    console.log(item)
&#125;

set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
</code></pre>
<p>实现并集、交集、和差集</p>
<pre><code class="js">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>
<p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<blockquote>
<ul>
<li><p>size 属性</p>
</li>
<li><p>set()</p>
<p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
</li>
<li><p>get()</p>
<p>get<code>方法读取</code>key<code>对应的键值，如果找不到</code>key<code>，返回</code>undefined</p>
</li>
<li><p>has()</p>
</li>
<li><p>delete()</p>
</li>
<li><p>clear()</p>
</li>
</ul>
</blockquote>
<p><code>Map</code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<blockquote>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
</blockquote>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<blockquote>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>clear</code>清空方法</li>
</ul>
</blockquote>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>异步编程的一种解决方案</p>
<p><code>promise</code>解决异步操作的优点：</p>
<blockquote>
<ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
</blockquote>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>promise</code>对象仅有三种状态</p>
<blockquote>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code class="js">const promise = new Promise(function(resolve, reject) &#123;&#125;);
</code></pre>
<p><code>Promise</code>构建出来的实例存在以下方法：</p>
<blockquote>
<ul>
<li>then()</li>
<li>catch()</li>
<li>finally()</li>
</ul>
</blockquote>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
<p><code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h4><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>
<h4 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h4><p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</p>
<pre><code class="js">const p = Promise.all([p1, p2, p3]);
</code></pre>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
</ul>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h4><p>将现有对象转为 <code>Promise</code>对象</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p>参数可以分成四种情况，分别如下：</p>
<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
<h4 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h4><pre><code class="js">const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>异步编程解决方法</p>
<p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>
<p>形式上，<code>Generator</code>函数是一个普通函数，但是有两个特征：</p>
<blockquote>
<ul>
<li><code>function</code>关键字与函数名之间有一个星号</li>
<li>函数体内部使用<code>yield</code>表达式，定义不同的内部状态</li>
</ul>
</blockquote>
<pre><code class="js">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
</code></pre>
<p><code>Generator</code> 函数会返回一个遍历器对象，即具有<code>Symbol.iterator</code>属性，并且返回给自己</p>
<pre><code class="js">g[Symbol.iterator] === g
</code></pre>
<p>yield 关键字可以暂停返回遍历器对象的状态</p>
<p>通过<code>next</code>方法才会遍历到下一个内部状态，其运行逻辑如下：</p>
<ul>
<li>遇到<code>yield</code>表达式，就暂停执行后面的操作，并将紧跟在<code>yield</code>后面的那个表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>下一次调用<code>next</code>方法时，再继续往下执行，直到遇到下一个<code>yield</code>表达式</li>
<li>如果没有再遇到新的<code>yield</code>表达式，就一直运行到函数结束，直到<code>return</code>语句为止，并将<code>return</code>语句后面的表达式的值，作为返回的对象的<code>value</code>属性值。</li>
<li>如果该函数没有<code>return</code>语句，则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ul>
<pre><code class="js">function* helloWorldGenerator() &#123;
  yield &#39;hello&#39;;
  yield &#39;world&#39;;
  return &#39;ending&#39;;
&#125;
var hw = helloWorldGenerator();

hw.next() 
//&#123;value: hello, done: false&#125;

hw.next() 
//&#123;value: undefine, done: true&#125;
</code></pre>
<p>返回的iterator对象可以用 for of 遍历</p>
<p><code>yield</code>表达式可以暂停函数执行，<code>next</code>方法用于恢复函数执行，这使得<code>Generator</code>函数非常适合将异步任务同步化</p>
<pre><code class="js">const gen = function* () &#123;
  const f1 = yield readFile(&#39;/etc/fstab&#39;);
  const f2 = yield readFile(&#39;/etc/shells&#39;);
  console.log(f1.toString());
  console.log(f2.toString());
&#125;;
</code></pre>
<h3 id="anysc-await异步最终解决方案"><a href="#anysc-await异步最终解决方案" class="headerlink" title="anysc/await异步最终解决方案"></a>anysc/await异步最终解决方案</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>async是一个加在函数前的修饰符，被async定义的函数会默认返回一个Promise对象resolve的值。因此对async函数可以直接then，返回值就是then方法传入的函数。</p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p>await 也是一个修饰符，只能放在async定义的函数内。</p>
<p>await 修饰的如果是Promise对象：可以获取Promise中返回的内容（resolve或reject的参数），且取到值后语句才会往下执行；</p>
<p>如果不是Promise对象：把这个非promise的东西当做await表达式的结果。</p>
<h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p><strong>定义：</strong> 用于定义基本操作的自定义行为</p>
<p><strong>本质：</strong> 修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程<code>(meta programming)</code></p>
<p>元编程（Metaprogramming，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作</p>
<p>用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>
<blockquote>
<p>用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）</p>
</blockquote>
<p>Proxy为 构造函数，用来生成 Proxy实例</p>
<pre><code class="js">var proxy = new Proxy(target, handler)
</code></pre>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><blockquote>
<p><code>target</code>表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</p>
<p><code>handler</code>通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</p>
</blockquote>
<h3 id="handler解析"><a href="#handler解析" class="headerlink" title="handler解析"></a>handler解析</h3><p>关于<code>handler</code>拦截属性，有如下：</p>
<ul>
<li>get(target,propKey,receiver)：拦截对象属性的读取</li>
<li>set(target,propKey,value,receiver)：拦截对象属性的设置</li>
<li>has(target,propKey)：拦截<code>propKey in proxy</code>的操作，返回一个布尔值</li>
<li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li>
<li>ownKeys(target)：拦截<code>Object.keys(proxy)</code>、<code>for...in</code>等循环，返回一个数组</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象</li>
<li>defineProperty(target, propKey, propDesc)：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>，返回一个布尔值</li>
<li>preventExtensions(target)：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值</li>
<li>getPrototypeOf(target)：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象</li>
<li>isExtensible(target)：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值</li>
<li>setPrototypeOf(target, proto)：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作</li>
</ul>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>若需要在<code>Proxy</code>内部调用对象的默认行为，建议使用<code>Reflect</code>，其是<code>ES6</code>中操作对象而提供的新 <code>API</code></p>
<p>基本特点：</p>
<ul>
<li>只要<code>Proxy</code>对象具有的代理方法，<code>Reflect</code>对象全部具有，以静态方法的形式存在</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回<code>false</code>）</li>
<li>让<code>Object</code>操作都变成函数行为</li>
</ul>
<blockquote>
<p><code>get</code>能够对数组增删改查进行拦截，下面是试下数组读取负数的索引</p>
</blockquote>
<pre><code class="js">function() createArray(...el) &#123;
    lel handler = &#123;
        get(target, propKey, receiver) &#123;
            let index = Number(propKey) 
            if(index &lt; 0) &#123;
                propKey = String(target.length + index);   
            &#125;
            return Reflect get(target, propKey, receiver);
        &#125;
    &#125;
       ler target = [];
    target.push(...el);
    return new proxy(target, handler;
&#125;
</code></pre>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 <code>Proxy</code> 实例本身</p>
<p>假定<code>Person</code>对象有一个<code>age</code>属性，该属性应该是一个不大于 200 的整数，那么可以使用<code>Proxy</code>保证<code>age</code>的属性值符合要求</p>
<pre><code class="javascript">let validator = &#123;
  set: function(obj, prop, value) &#123;
    if (prop === &#39;age&#39;) &#123;
      if (!Number.isInteger(value)) &#123;
        throw new TypeError(&#39;The age is not an integer&#39;);
      &#125;
      if (value &gt; 200) &#123;
        throw new RangeError(&#39;The age seems invalid&#39;);
      &#125;
    &#125;

    // 对于满足条件的 age 属性以及其他属性，直接保存
    obj[prop] = value;
  &#125;
&#125;;

let person = new Proxy(&#123;&#125;, validator);

person.age = 100;

person.age // 100
person.age = &#39;young&#39; // 报错
person.age = 300 // 报错
</code></pre>
<p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p>
<p>如果目标对象自身的某个属性，不可写且不可配置，那么<code>set</code>方法将不起作用</p>
<pre><code class="js">Object.defineProperty(obj, &#39;foo&#39;, &#123;
    value: &#39;bar&#39;,
    writable: false
&#125;)
</code></pre>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><code>Proxy</code>其功能非常类似于设计模式中的代理模式，常用功能如下：</p>
<ul>
<li>拦截和监视外部对对象的访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验或对所需资源进行管理</li>
</ul>
<p>使用 <code>Proxy</code> 保障数据类型的准确性</p>
<pre><code class="javascript">let numericDataStore = &#123; count: 0, amount: 1234, total: 14 &#125;;
numericDataStore = new Proxy(numericDataStore, &#123;
    set(target, key, value, proxy) &#123;
        if (typeof value !== &#39;number&#39;) &#123;
            throw Error(&quot;属性只能是number类型&quot;);
        &#125;
        return Reflect.set(target, key, value, proxy);
    &#125;
&#125;);

numericDataStore.count = &quot;foo&quot;
// Error: 属性只能是number类型

numericDataStore.count = 333
// 赋值成功
</code></pre>
<p>声明了一个私有的 <code>apiKey</code>，便于 <code>api</code> 这个对象内部的方法调用，但不希望从外部也能够访问 <code>api._apiKey</code></p>
<pre><code class="javascript">let api = &#123;
    _apiKey: &#39;123abc456def&#39;,
    getUsers: function()&#123; &#125;,
    getUser: function(userId)&#123; &#125;,
    setUser: function(userId, config)&#123; &#125;
&#125;;
const RESTRICTED = [&#39;_apiKey&#39;];
api = new Proxy(api, &#123;
    get(target, key, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可访问.`);
        &#125; return Reflect.get(target, key, proxy);
    &#125;,
    set(target, key, value, proxy) &#123;
        if(RESTRICTED.indexOf(key) &gt; -1) &#123;
            throw Error(`$&#123;key&#125; 不可修改`);
        &#125; return Reflect.get(target, key, value, proxy);
    &#125;
&#125;);

console.log(api._apiKey)
api._apiKey = &#39;987654321&#39;
// 上述都抛出错误
</code></pre>
<p>还能通过使用<code>Proxy</code>实现观察者模式</p>
<p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行</p>
<p><code>observable</code>函数返回一个原始对象的 <code>Proxy</code> 代理，拦截赋值操作，触发充当观察者的各个函数</p>
<pre><code class="javascript">const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);

function set(target, key, value, receiver) &#123;
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
&#125;
</code></pre>
<p>观察者函数都放进<code>Set</code>集合，当修改<code>obj</code>的值，在会<code>set</code>函数中拦截，自动执行<code>Set</code>所有的观察者</p>
<h2 id="ES6模块"><a href="#ES6模块" class="headerlink" title="ES6模块"></a>ES6模块</h2><h4 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h4><ul>
<li>代码抽象</li>
<li>代码封装</li>
<li>代码复用</li>
<li>依赖管理</li>
</ul>
<p>模块化的机制：</p>
<ul>
<li>CommonJs (典型代表：node.js早期)</li>
<li>AMD (典型代表：require.js)</li>
<li>CMD (典型代表：sea.js)</li>
</ul>
<p>（自动采用严格模式）模块功能主要由两个命令构成：</p>
<blockquote>
<ul>
<li><code>export</code>：用于规定模块的对外接口</li>
<li><code>import</code>：用于输入其他模块提供的功能</li>
</ul>
</blockquote>
<pre><code class="js">//export 
let year = &#39;year&#39;
let mouth = &#39;mouth&#39;
let day = &#39;day&#39;
export &#123;
year as Year, //重命名
mouth,
day
&#125;

//import
import &#123;Year as nian, mouth, day&#125; from &#39;./js&#39;

//导入整个模块
import * as all from &#39;./js&#39;

//如果只有一个模块名，需要有配置文件，告诉引擎模块的位置
import &#123; myMethod &#125; from &#39;util&#39;;
</code></pre>
<p>在编译阶段，<code>import</code>会提升到整个模块的头部，首先执行</p>
<p>多次重复执行同样的导入，只会执行一次</p>
<p>如果不需要知道变量名或函数就完成加载，就要用到<code>export default</code>命令，为模块指定默认输出</p>
<pre><code class="javascript">// export-default.js
export default function () &#123;
    console.log(&#39;foo&#39;);
&#125;
</code></pre>
<p>加载该模块的时候，<code>import</code>命令可以为该函数指定任意名字</p>
<pre><code class="javascript">// import-default.js
import customName from &#39;./export-default&#39;;
customName(); // &#39;foo&#39;
</code></pre>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>允许您仅在需要时动态加载模块，而不必预先加载所有模块，这存在明显的性能优势</p>
<p>这个新功能允许您将import()作为函数调用，将其作为参数传递给模块的路径。 它返回一个 promise，它用一个模块对象来实现，让你可以访问该对象的导出</p>
<pre><code class="js">import(&#39;/modules/myModule.mjs&#39;)
  .then((module) =&gt; &#123;
    // Do something with the module.
  &#125;);
</code></pre>
<h1 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h1><p>简单来讲，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p>
<blockquote>
<ul>
<li>代码可读性变强了，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原来功能进行扩展</li>
</ul>
</blockquote>
<pre><code class="js">//这里定义一个士兵，这时候他什么装备都没有
class soldier&#123; 
&#125;

//定义一个得到 AK 装备的函数，即装饰器
function strong(target)&#123;
    target.AK = true
&#125;

//使用该装饰器对士兵进行增强
@strong
class soldier&#123;
&#125;

//这时候士兵就有武器了
soldier.AK // true
</code></pre>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>