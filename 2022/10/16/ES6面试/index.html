<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:600px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:600px)" href="/css/style.css" type="text/css" />
    <title>iLx1 | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div class="backg"></div>
    <div class="paper">
        <div class="paper-main">
            <div class="bgimg"></div>
            <div class="cover"></div>
            <!-- <div class="bgimgB"></div> -->
            
            <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
            
            <div class="post-main">
    
        <div class="post-main-title">
            ES6面试
        </div>
        <div class="post-meta">
            2022-10-16
        </div>
    
<hr>
    <div class="post-md">
        <h2 id="var-let-const之间的区别"><a href="#var-let-const之间的区别" class="headerlink" title="var, let , const之间的区别"></a>var, let , const之间的区别</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><blockquote>
<p>声明的变量既是全局变量，也是顶级变量</p>
<p>存在变量提升</p>
<p>可以多次声明，前面的会覆盖后面的</p>
<p>函数中是局部的</p>
</blockquote>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote>
<p>块级作用域</p>
<p>没有变量提升，声明前不存在，“暂时性死区”</p>
<p>不允许重复</p>
</blockquote>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote>
<p>声明简单数据类型为常量，不能改变</p>
<p>声明复杂数据类型，保存指向实际数据的指针，变量的结构可以改变</p>
<p>块级作用域</p>
<p>没有变量提升，声明前不存在，“暂时性死区”</p>
</blockquote>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>扩展元素符<code>...</code>，好比 <code>rest</code> 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<p>主要用于函数调用的时候，将一个数组变为参数序列</p>
<pre><code class="js">const numbers = [4, 38];
add(...numbers) // 42

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre>
<p>可以简单实现复制与合并数组</p>
<p>通过扩展运算符实现的是<code>浅拷贝</code></p>
<p>将字符串转为数组</p>
<pre><code class="js">[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre>
<p>定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p>
<ul>
<li><p>遍历器（Iterator）。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<h4 id="遍历器的作用"><a href="#遍历器的作用" class="headerlink" title="遍历器的作用"></a>遍历器的作用</h4><p>（1）为各种数据结构，提供一个统一的、简便的访问接口；<br>（2）使得数据结构的成员能够按某种次序排列；<br>（3） ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费（for of遍历的对象必须存在遍历器接口 才可以遍历）</p>
<h4 id="Iterator-的遍历过程"><a href="#Iterator-的遍历过程" class="headerlink" title="Iterator 的遍历过程"></a>Iterator 的遍历过程</h4><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。<br>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。<br>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。<br>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。<br>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>
</li>
</ul>
<h5 id="关于构造函数，数组新增的方法有如下："><a href="#关于构造函数，数组新增的方法有如下：" class="headerlink" title="关于构造函数，数组新增的方法有如下："></a>关于构造函数，数组新增的方法有如下：</h5><blockquote>
<ul>
<li><p>Array.from()</p>
<p>将两类对象转为真正的数组：类似数组的对象和可遍历<code>（iterable）</code>的对象（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p>
<p>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p>
</li>
<li><p>Array.of()</p>
<p>用于将一组值，转换为数组</p>
<p>没有参数的时候，返回一个空数组</p>
<p>当参数只有一个的时候，实际上是指定数组的长度</p>
<p>参数个数不少于 2 个时，Array()才会返回由参数组成的新数组</p>
</li>
</ul>
</blockquote>
<p>Array.from()</p>
<pre><code class="js">let arrayLike = &#123;
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
&#125;;
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre>
<h2 id="关于数组实例对象新增的方法"><a href="#关于数组实例对象新增的方法" class="headerlink" title="关于数组实例对象新增的方法"></a>关于数组实例对象新增的方法</h2><blockquote>
<ul>
<li><h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p>将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p>
<p>参数如下：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="js">[1, 2, 3, 4, 5].copyWithin(0, 3) // 将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2
// [4, 5, 3, 4, 5]
</code></pre>
<blockquote>
<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p>参数是一个回调函数，接受三个参数依次为value, key, arr</p>
<h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h4><p>返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1</p>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。</p>
</blockquote>
<blockquote>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p>使用给定值，填充一个数组</p>
<p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置</p>
</blockquote>
<blockquote>
<p><code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历</p>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p>用于判断数组是否包含给定的值</p>
<h4 id="flat"><a href="#flat" class="headerlink" title="flat()"></a>flat()</h4><p>将数组扁平化处理(降维)，返回一个新数组，对原数据没有影响</p>
</blockquote>
<h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="参数设置默认值"><a href="#参数设置默认值" class="headerlink" title="参数设置默认值"></a>参数设置默认值</h4><pre><code class="js">function def(x, y = &#39;default&#39;) &#123;
  console.log(x, y);
&#125;
</code></pre>
<h5 id="与解构结合"><a href="#与解构结合" class="headerlink" title="与解构结合"></a>与解构结合</h5><pre><code class="js">function def(&#123;x, y = 5&#125;)
</code></pre>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h5 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h5><p><code>length</code>将返回没有指定默认值的参数个数</p>
<p><code>rest</code> 参数也不会计入<code>length</code>属性</p>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了</p>
<h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h5><p>返回该函数的函数名</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul>
<li>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>
<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 <code>rest</code> 参数代替</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数</li>
</ul>
<h3 id="Set、Map"><a href="#Set、Map" class="headerlink" title="Set、Map"></a>Set、Map</h3><p><code>Set</code>是一种叫做集合的数据结构，<code>Map</code>是一种叫做字典的数据结构</p>
<ul>
<li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合 </li>
<li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key 各不相同 </li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>成员的值都是唯一的，没有重复的值</p>
<p><code>Set</code>的实例关于增删改查的方法：</p>
<blockquote>
<ul>
<li> add() </li>
<li> delete() </li>
<li> has() </li>
<li> clear() </li>
</ul>
</blockquote>
<p>关于遍历的方法，有如下：</p>
<blockquote>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
</blockquote>
<pre><code class="js">for(let item of set.keys()) &#123;
    console.log(item)
&#125;

set.forEach((value, key) =&gt; console.log(key + &#39; : &#39; + value))
</code></pre>
<p>实现并集、交集、和差集</p>
<pre><code class="js">let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
// 并集
let union = new Set([...a, ...b]);
// Set &#123;1, 2, 3, 4&#125;

// 交集
let intersect = new Set([...a].filter(x =&gt; b.has(x)));
// set &#123;2, 3&#125;

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x =&gt; !b.has(x)));
// Set &#123;1&#125;
</code></pre>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p>
<p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p>
<p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p>
<blockquote>
<ul>
<li><p>size 属性</p>
</li>
<li><p>set()</p>
<p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构</p>
<p>如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键</p>
<p>同时返回的是当前<code>Map</code>对象，可采用链式写法</p>
</li>
<li><p>get()</p>
<p>get<code>方法读取</code>key<code>对应的键值，如果找不到</code>key<code>，返回</code>undefined</p>
</li>
<li><p>has()</p>
</li>
<li><p>delete()</p>
</li>
<li><p>clear()</p>
</li>
</ul>
</blockquote>
<p><code>Map</code>结构原生提供三个遍历器生成函数和一个遍历方法：</p>
<blockquote>
<ul>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回所有成员的遍历器</li>
<li>forEach()：遍历 Map 的所有成员</li>
</ul>
</blockquote>
<p>在<code>API</code>中<code>WeakMap</code>与<code>Map</code>有两个区别：</p>
<blockquote>
<ul>
<li>没有遍历操作的<code>API</code></li>
<li>没有<code>clear</code>清空方法</li>
</ul>
</blockquote>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>异步编程的一种解决方案</p>
<p><code>promise</code>解决异步操作的优点：</p>
<blockquote>
<ul>
<li>链式操作减低了编码难度</li>
<li>代码可读性明显增强</li>
</ul>
</blockquote>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>promise</code>对象仅有三种状态</p>
<blockquote>
<ul>
<li><code>pending</code>（进行中）</li>
<li><code>fulfilled</code>（已成功）</li>
<li><code>rejected</code>（已失败）</li>
</ul>
</blockquote>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote>
<ul>
<li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li>
<li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li>
</ul>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre><code class="js">const promise = new Promise(function(resolve, reject) &#123;&#125;);
</code></pre>
<p><code>Promise</code>构建出来的实例存在以下方法：</p>
<blockquote>
<ul>
<li>then()</li>
<li>catch()</li>
<li>finally()</li>
</ul>
</blockquote>
<h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数</p>
<p><code>Promise</code>对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h4><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p>
<h4 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h4><p><code>Promise.all()</code>方法用于将多个 <code>Promise</code>实例，包装成一个新的 <code>Promise</code>实例</p>
<pre><code class="js">const p = Promise.all([p1, p2, p3]);
</code></pre>
<ul>
<li>只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数</li>
</ul>
<h4 id="resolve"><a href="#resolve" class="headerlink" title="resolve()"></a>resolve()</h4><p>将现有对象转为 <code>Promise</code>对象</p>
<pre><code class="javascript">Promise.resolve(&#39;foo&#39;)
// 等价于
new Promise(resolve =&gt; resolve(&#39;foo&#39;))
</code></pre>
<p>参数可以分成四种情况，分别如下：</p>
<ul>
<li>参数是一个 Promise 实例，<code>promise.resolve</code>将不做任何修改、原封不动地返回这个实例</li>
<li>参数是一个<code>thenable</code>对象，<code>promise.resolve</code>会将这个对象转为 <code>Promise</code>对象，然后就立即执行<code>thenable</code>对象的<code>then()</code>方法</li>
<li>参数不是具有<code>then()</code>方法的对象，或根本就不是对象，<code>Promise.resolve()</code>会返回一个新的 Promise 对象，状态为<code>resolved</code></li>
<li>没有参数时，直接返回一个<code>resolved</code>状态的 Promise 对象</li>
</ul>
<h4 id="reject"><a href="#reject" class="headerlink" title="reject()"></a>reject()</h4><pre><code class="js">const p = Promise.reject(&#39;出错了&#39;);
// 等同于
const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))

p.then(null, function (s) &#123;
  console.log(s)
&#125;);
// 出错了
</code></pre>
<h3 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h3><p>异步编程解决方法</p>
<p>执行 <code>Generator</code> 函数会返回一个遍历器对象，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p>

    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
     <div class="menuShow">
     <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24"><path d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z" fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path></svg>
    </div>
    <div class="top">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

</div>

<script src="/js/nav.js"></script>

            <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>


<link rel="stylesheet" href="/css/nord.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

        </div>
    </div>
</body>

<script src="/js/memo.js"></script>

</html>