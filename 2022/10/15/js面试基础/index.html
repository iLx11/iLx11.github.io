<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:700px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:700px)" href="/css/stylePC.css" type="text/css" />
    <link rel="stylesheet" href="/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="/css/markdown.css" type="text/css" />
    <link rel="stylesheet" href="/css/fonts.css" type="text/css" />

    <title>
        iLx1 |
            
    </title>
    <!-- 
<link rel="stylesheet" href="/css/reset.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/markdown.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/fonts.css">
 -->
<meta name="generator" content="Hexo 5.4.2"></head>
    <style>
        /*页面加载开始*/
        .load {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 35em;
            z-index: 999;
        }

        .loader {
            --path: #323641;
            --dot: #6a95bd;
            --duration: 1.5s;
            width: 55px;
            height: 55px;
            align-items: center;
            justify-items: center;
            position: relative;
        }
        .h-mes {
            width: 100%;
            height: 20%;
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-flow: column nowrap;
            justify-content: space-evenly;
            align-items: center;
        }
        .h-mes span {
            width: 100%;
            height: 10%;
            text-align: center;
        }
        .loader:before {
            content: "";
            width: 6px;
            height: 6px;
            border-radius: 50%;
            position: absolute;
            display: block;
            background: var(--dot);
            top: 37px;
            left: 19px;
            transform: translate(-18px, -18px);
        }

        .loader svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .loader svg polygon {
            fill: none;
            stroke: var(--path);
            stroke-width: 10px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .loader svg polygon {
            stroke-dasharray: 145 76 145 76;
            stroke-dashoffset: 0;
            animation: pathTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }

        .loader.triangle {
            width: 48px;
        }

        .loader.triangle:before {
            left: 21px;
            transform: translate(-10px, -18px);
            animation: dotTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }
        #noWait {
            color: rgba(51,51,51, 0.4);
            margin-top: 3em;
            cursor: pointer;
            display: none;
        }
        @keyframes pathTriangle {
            33% {
                stroke-dashoffset: 74;
            }

            66% {
                stroke-dashoffset: 147;
            }

            100% {
                stroke-dashoffset: 221;
            }
        }

        @keyframes dotTriangle {
            33% {
                transform: translate(0, 0);
            }

            66% {
                transform: translate(10px, -18px);
            }

            100% {
                transform: translate(-10px, -18px);
            }

        }
    </style>

    <body>
        <!-- 页面加载效果 -->
        <div class="load">
            <div class="loader triangle">
                <svg viewBox="0 0 86 80">
                    <polygon points="43 8 79 72 7 72"></polygon>
                </svg>
            </div>
            <div class="h-mes">
                <span id="chs">" 请稍等一会... "</span>
                <span>Please wait for a long time</span>
                <span id="noWait"><我不等啦！></span>
            </div>
        </div>
        
        <!-- 页面加载结束 -->
        <div class="backg"></div>
        <div class="paper">
            <div class="paper-main">
                
                
                <!-- <div class="bgimg"></div> -->
                <div class="cover"></div>
                <!-- <div class="bgimgB"></div> -->
                
                    <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                        
                                    <section class="post-struction">
    <div class="post-main">
        
            <div class="post-main-title">
                js面试基础
            </div>
            <div class="post-meta">
                2022-10-15
            </div>
            
                <hr>
                <div class="post-md">
                    <h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>六种类型，Undefined, Null, Boolean, String , Number,Object ,Symbol</p>
<blockquote>
<p>基本数据类型：Undefined, Null, Boolean, String , Number</p>
</blockquote>
<p>有固定长度，保存在栈上</p>
<blockquote>
<p>引用数据类型：Object</p>
</blockquote>
<p>不可预知长度，保存在堆中，栈中保存指向堆内存的地址</p>
<p>js是动态类型（弱类型）</p>
<h5 id="typeof来判断类型"><a href="#typeof来判断类型" class="headerlink" title="typeof来判断类型"></a>typeof来判断类型</h5><p>判断一个值是不是 null 类型</p>
<pre><code class="js">function isNull(o) &#123;
    return !o &amp;&amp;  typeof o === &quot;object&quot;
&#125;
</code></pre>
<ul>
<li>undefined 不是未定义，两者有区别。尝试去读一个未定义的变量的值其实会直接<code>Reference Error</code></li>
<li>typeof 不能区分未定义，还是定义了但是没有值。两者都会都会返回undefined</li>
<li>typeof 一个未定义的变量不会触发<code>Reference Error</code></li>
</ul>
<blockquote>
<p>Array是一种容器类型</p>
</blockquote>
<p>本质上是对象</p>
<blockquote>
<p>number事实上是浮点数</p>
</blockquote>
<p>JavaScript 明确地使用了“双精度”（也就是“64位二进制”）格式。</p>
<p>这部分常考的一个点是精度问题。</p>
<pre><code class="js">0.1 + 0.2 === 0.3; // false
</code></pre>
<p> “错误舍入”值作为比较的 容差，这个很小的值经常被称为“机械极小值（machine epsilon）”， 对于 JavaScript 来说这种 number 通常为 Number.EPSILON。</p>
<pre><code class="js">function numbersCloseEnoughToEqual(n1,n2) &#123;
    return Math.abs( n1 - n2 ) &lt; Number.EPSILON;
&#125;

var a = 0.1 + 0.2;
var b = 0.3;

numbersCloseEnoughToEqual( a, b );                    // true
numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );    // false
</code></pre>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><blockquote>
<p>全局上下文 ：window对象</p>
<p>函数执行上下文：每当函数被调用一次，就创建一个函数执行上下文</p>
</blockquote>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>创建 -&gt; 执行 -&gt; 回收</p>
<p>创建阶段做了三件事：</p>
<ul>
<li>确定 this 的值，也被称为 <code>This Binding</code></li>
<li>LexicalEnvironment（词法环境） 组件被创建</li>
<li>VariableEnvironment（变量环境） 组件被创建</li>
</ul>
<p>执行阶段</p>
<p>如果 <code>Javascript</code> 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 <code>undefined</code> 值</p>
<p>回收阶段</p>
<p>执行上下文出栈等待虚拟机回收执行上下文</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合</p>
<p>包括</p>
<ul>
<li> 全局作用域 </li>
<li> 函数作用域 </li>
<li> 块级作用域 </li>
</ul>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><p>又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，<code>JavaScript</code> 遵循的就是词法作用域</p>
<blockquote>
<p>作用域背后地原理是<code>词法环境</code></p>
</blockquote>
<p>词法环境由两部分组成：</p>
<ol>
<li><p>环境记录， 这其实就是JavaScript用来存变量地地方，一个key-value对在这里被成为一个binding。</p>
<p>是一个没有外部环境的词法环境，其外部环境引用为<code>null</code>，有一个全局对象，<code>this</code> 的值指向这个全局对象 </p>
</li>
<li><p>外部环境的引用</p>
<p>用户在函数中定义的变量被存储在环境记录中，包含了<code>arguments</code> 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境 </p>
</li>
</ol>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</p>
<p>在 <code>JavaScript</code>中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁</p>
<p>使用场景</p>
<blockquote>
<ul>
<li><p>创建私有变量</p>
</li>
<li><p>延长变量的生命周期</p>
<p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p>
</li>
</ul>
</blockquote>
<p>一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的</p>
<h1 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是一种代码复用的方式。在面向对象编程中，继承是一个很重要的点。</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>在JS中继承背后的原理是原型<code>prototype</code>, 这种实现继承的方式，我们称之为原型继承。</p>
<pre><code class="js">function Parent() &#123;
    this.name = &#39;parent&#39;;
  &#125;
  function Child() &#123;
    this.type = &#39;child&#39;;
  &#125;
  Child.prototype = new Parent();
  console.log(new Child())
</code></pre>
<p>问题： 多个实例对象共用一个原型对象，会相互影响</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><pre><code class="js">function Parent() &#123;
    this.name = &#39;parent&#39;;
&#125;
Parent.prototype.method = function()&#123;&#125;

function Child() &#123;
       Parent.call(this)
&#125;
new Child();
</code></pre>
<p>问题： 父类原型对象自己定义的方法无法继承</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><pre><code class="js">function Child() &#123;
    //第二次调用Parent
    Parent.call(this)
&#125; 
//第一次调用Parent
Child.prototype = new Parent();
//手动挂载构造器，指向自己的构造函数
Child.prototype.consturctor = Child;
</code></pre>
<p>问题： 增加了构造的性能开销</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>借助Object.create实现普通对象继承</p>
<pre><code class="js">  let Child = Object.create(Parent);
  Child.name = &quot;xxx&quot;;
</code></pre>
<p>问题： 实现的是浅拷贝，引用数据类型指向相同的内存</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><pre><code class="js">function clone(original) &#123;
    let clone = Object.create(original);
    clone.getFriends = function() &#123;
        return this.friends;
    &#125;;
    return clone;
&#125;

let Child = clone(parent);
</code></pre>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><pre><code class="JS">function clone (parent, child) &#123;
    // 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程
    child.prototype = Object.create(parent.prototype);
    child.prototype.constructor = child;
&#125;

function Parent6() &#123;
    this.name = &#39;parent6&#39;;
    this.play = [1, 2, 3];
&#125;
Parent6.prototype.getName = function () &#123;
    return this.name;
&#125;
function Child6() &#123;
    Parent6.call(this);
    this.friends = &#39;child5&#39;;
&#125;

clone(Parent6, Child6);

Child6.prototype.getFriends = function () &#123;
    return this.friends;
&#125;
</code></pre>
<p>这种继承方式是目前最优的继承方式，ES6中的extents 关键字也是采用这种方式</p>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>JS中一些全局内置函数，分别为Functon, Array, Object.</p>
<pre><code class="js">console.log(Object); // -&gt; ƒ Object() &#123; [native code] &#125;
console.log(Array); // -&gt; ƒ Array() &#123; [native code] &#125;
console.log(Function); // -&gt; ƒ Function() &#123; [native code] &#125;Copy to clipboardErrorCopied
</code></pre>
<ul>
<li>所有的数组对象，都是由全局内置函数Array创建的</li>
<li>所有的object对象，都是由全局内置函数Object创建的</li>
<li>所有的函数对象，都是由全局内置函数Function创建的</li>
</ul>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><p><strong>proto</strong> 是一个内部属性，不建议对其进行直接操作。 而是建议通过prototype来进行操作。</p>
<blockquote>
<p>每个函数都有一个特殊的属性叫作原型prototype</p>
<p>一个对象的__proto__总是指向它的构造函数的prototype</p>
</blockquote>
<p>当我们访问一个对象的属性的时候，引擎首先会在当前对象进行查找，如果找不到就会访问该对象的<code>__proto__</code>， 如果<code>__proto__</code>有了，就返回，如果没有则递归执行上述过程，直到<code>__proto__</code> 为 <code>null</code>。</p>
<p><img src="https://gitee.com/iLx1/resource-img/raw/master/images.jpg" alt="img"></p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><blockquote>
<p>this的设计目的就是指向函数运行时所在的环境</p>
</blockquote>
<h3 id="判定this指向"><a href="#判定this指向" class="headerlink" title="判定this指向"></a>判定this指向</h3><h4 id="一、默认绑定"><a href="#一、默认绑定" class="headerlink" title="一、默认绑定"></a>一、默认绑定</h4><p>1、严格模式下</p>
<p>不能将全局对象<code>window</code>作为默认绑定，此时<code>this</code>会绑定到<code>undefined</code>，但是在严格模式下调用函数则不会影响默认绑定。</p>
<p>2、非严格模式下</p>
<p>this指向全局对象</p>
<h4 id="二、隐式绑定"><a href="#二、隐式绑定" class="headerlink" title="二、隐式绑定"></a>二、隐式绑定</h4><p>当函数作为对象的属性存在，通过<strong>对象属性执行函数</strong>时，此时隐式绑定规则会将<code>this</code>绑定到对象上；</p>
<blockquote>
<p>赋值操作后执行函数，会应用默认绑定</p>
</blockquote>
<blockquote>
<p>函数传参也是一种隐式赋值，此时在回调函数中会丢失this绑定。(函数定义位置不在对象内)</p>
</blockquote>
<h4 id="三、显式绑定"><a href="#三、显式绑定" class="headerlink" title="三、显式绑定"></a>三、显式绑定</h4><blockquote>
<p>通过call apply bind绑定</p>
</blockquote>
<p><code>call</code>做了哪些事儿。</p>
<ul>
<li>将函数设为对象的属性</li>
<li>指定函数的this，并进行传参</li>
<li>执行&amp;删除函数</li>
<li>判定如果没有指定要绑定的this，非严格模式下默认指向全局对象</li>
</ul>
<pre><code class="js">foo.call(obj); // Heternally  调用call方法后强行将foo函数的this指向来obj对象上

foo.call(obj).call(obj1); // Heternally  多次调用call方法，以第一次为准

foo.call();// zl 没有传入指定对象，所以this默认指向全局对象
</code></pre>
<h4 id="四、通过new绑定"><a href="#四、通过new绑定" class="headerlink" title="四、通过new绑定"></a>四、通过new绑定</h4><p><code>new</code>后，执行了什么操作：</p>
<ul>
<li>它创建（构造）了一个全新的对象</li>
<li>它会被执行[[Prototype]]（也就是__proto__）链接</li>
<li>它使this指向新创建的对象</li>
<li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上</li>
<li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用</li>
</ul>
<p>在使用<code>new</code>调用构造函数后，会构造一个新对象并将函数调用中的<code>this</code>绑定到新对象上。</p>
<h4 id="箭头函数的this指向"><a href="#箭头函数的this指向" class="headerlink" title="箭头函数的this指向"></a>箭头函数的this指向</h4><blockquote>
<p>根据它外层（函数/全局）作用域来决定</p>
</blockquote>
<p>箭头函数不能沿用以上的绑定this指向的方法</p>
<h1 id="数组的操作方法"><a href="#数组的操作方法" class="headerlink" title="数组的操作方法"></a>数组的操作方法</h1><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><blockquote>
<ul>
<li>push() 尾部添加，改变原数组，返回新长度</li>
<li>unshift() 头部添加</li>
<li>splice( 开始位置，删除个数（0），插入元素) 改变原数组</li>
<li>concat(xx,[xx]) 返回新数组</li>
</ul>
</blockquote>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><blockquote>
<ul>
<li>pop() 删除尾部，返回被删除元素</li>
<li>shift() 删除头部，返回删除元素</li>
<li>splice(开始位置，元素数量)</li>
<li>slice(删除位置（非索引）)</li>
</ul>
</blockquote>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><blockquote>
<ul>
<li>indexOf() 查找元素位置，没有返回-1</li>
<li>includes() 查找元素位置，有则true，没有false</li>
<li>find() 返回第一个匹配元素</li>
</ul>
</blockquote>
<blockquote>
<p>reverse() 反转数组</p>
<p>sort() 冒泡排序</p>
</blockquote>
<h4 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h4><blockquote>
<p>join(“|”) 以字符串分割数组，返回字符串</p>
</blockquote>
<h4 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h4><p>传入执行函数</p>
<blockquote>
<ul>
<li>some(value, key) 至少一个返回true， 则返回true</li>
<li>every() 所有元素返回true， 则返回true</li>
<li>forEach() 遍历数组</li>
<li>filter() 返回元素为true的新数组</li>
<li>map() 每一项运行传入函数</li>
</ul>
</blockquote>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><h4 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h4><blockquote>
<p>concat() 拼接</p>
<p>+/ ${}</p>
</blockquote>
<h4 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h4><blockquote>
<ul>
<li>slice(开始位置， 结束位置) </li>
<li>substr(开始位置， 结束位置)</li>
<li>substring( 开始位置， 截取长度)</li>
</ul>
</blockquote>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><blockquote>
<ul>
<li> trim()、trimLeft()、trimRight() </li>
<li> repeat(次数) </li>
<li> padStart(长度，填充字符)、padEnd() </li>
<li> toLowerCase()、 toUpperCase() </li>
</ul>
</blockquote>
<h4 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h4><blockquote>
<ul>
<li> chatAt(索引位置) 返回对应字符串  </li>
<li> indexOf(字符) 返回字符位置 </li>
<li> startWith(字符串) 包含与否返回布尔值 </li>
<li> includes(字符串) 包含与否返回布尔值</li>
</ul>
</blockquote>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><blockquote>
<p>split(“|”) 根据字符转换为数组</p>
</blockquote>
<h4 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h4><blockquote>
<ul>
<li>match() 匹配模板，返回数组</li>
<li>search() 匹配模板，匹配失败返回-1</li>
<li>replace(匹配内容， 替换元素) </li>
</ul>
</blockquote>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>转换为布尔</p>
<blockquote>
<ul>
<li>undefined</li>
<li>null</li>
<li>false</li>
<li>+0</li>
<li>-0</li>
<li>NaN</li>
<li>“”</li>
</ul>
<p>除了上面几种会被转化成<code>false</code>，其他都换被转化成<code>true</code></p>
</blockquote>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><blockquote>
<p>除了<code>+</code>有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值</p>
</blockquote>
<h4 id="和"><a href="#和" class="headerlink" title="==和==="></a>==和===</h4><p>相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换</p>
<h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><blockquote>
<p>深拷贝</p>
</blockquote>
<p>开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p>
<ul>
<li> _.cloneDeep() </li>
<li> jQuery.extend() </li>
<li> JSON.stringify() </li>
<li> 手写循环递归 </li>
</ul>
<pre><code class="js">循环递归
function deepClone(obj, hash = new WeakMap()) &#123;
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== &quot;object&quot;) return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) &#123;
    if (obj.hasOwnProperty(key)) &#123;
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    &#125;
  &#125;
  return cloneObj;
&#125;
</code></pre>
<blockquote>
<p>浅拷贝</p>
</blockquote>
<p>指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址</p>
<pre><code class="js">function shallowClone(obj) &#123;
    const newObj = &#123;&#125;;
    for(let prop in obj) &#123;
        if(obj.hasOwnProperty(prop))&#123;
            newObj[prop] = obj[prop];
        &#125;
    &#125;
    return newObj;
&#125;
</code></pre>
<ul>
<li><code>Object.assign</code></li>
<li><code>Array.prototype.slice()</code>, <code>Array.prototype.concat()</code></li>
</ul>
<h2 id="事件与事件流"><a href="#事件与事件流" class="headerlink" title="事件与事件流"></a>事件与事件流</h2><p><code>javascript</code>中的事件，可以理解就是在<code>HTML</code>文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等</p>
<p>由于<code>DOM</code>是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念</p>
<p>事件流都会经历三个阶段：</p>
<blockquote>
<ul>
<li>事件捕获阶段(capture phase)</li>
<li>处于目标阶段(target phase)</li>
<li>事件冒泡阶段(bubbling phase)</li>
</ul>
</blockquote>
<p><img src="D:\Users\Administrator\Desktop\images" alt="img"></p>
<p>事件冒泡是一种从下往上的传播方式，由最具体的元素（触发节点）然后逐渐向上传播到DOM中最高层的父节点</p>
<p>事件捕获与事件冒泡相反，事件最开始由不太具体的节点最早接受事件, 而最具体的节点（触发节点）最后接受事件</p>
<h3 id="原始事件模型"><a href="#原始事件模型" class="headerlink" title="原始事件模型"></a>原始事件模型</h3><blockquote>
<ul>
<li><p>行内绑定</p>
</li>
<li><p>js代码绑定</p>
</li>
</ul>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>绑定速度快</li>
</ul>
<p><code>DOM0</code>级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，可能页面还未完全加载出来，以至于事件可能无法正常运行</p>
<ul>
<li> 只支持冒泡，不支持捕获 </li>
<li> 同一个类型的事件只能绑定一次 </li>
</ul>
<p>删除 <code>DOM0</code> 级事件处理程序只要将对应事件属性置为<code>null</code>即可</p>
<h3 id="标准事件模型"><a href="#标准事件模型" class="headerlink" title="标准事件模型"></a>标准事件模型</h3><p>在该事件模型中，一次事件共有三个过程:</p>
<blockquote>
<ul>
<li>事件捕获阶段：事件从<code>document</code>一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
<li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li>
<li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li>
</ul>
</blockquote>
<pre><code class="js">addEventListener(eventType, handler, useCapture)
</code></pre>
<p>参数如下：</p>
<ul>
<li><code>eventType</code>指定事件类型(不要加on)</li>
<li><code>handler</code>是事件处理函数</li>
<li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在捕获阶段进行处理，一般设置为<code>false</code>与IE浏览器保持一致</li>
</ul>
<h3 id="AJAX都有哪些优点和缺点？"><a href="#AJAX都有哪些优点和缺点？" class="headerlink" title="AJAX都有哪些优点和缺点？"></a>AJAX都有哪些优点和缺点？</h3><p>解析：</p>
<p>ajax的优点是：</p>
<p>1.最大的一点是页面无刷新，用户的体验非常好。</p>
<p>2.使用异步方式与服务器通信，具有更加迅速的响应能力。</p>
<p>3.可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。</p>
<p>4.基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</p>
<p>ajax的缺点是：</p>
<p>1.ajax不支持浏览器back按钮。</p>
<p>2.安全问题 AJAX暴露了与服务器交互的细节。</p>
<p>3.对搜索引擎的支持比较弱。</p>
<p>4.破坏了程序的异常机制。</p>
<p>5.不容易调试。</p>
<h3 id="如何进行网站性能优化"><a href="#如何进行网站性能优化" class="headerlink" title="如何进行网站性能优化"></a>如何进行网站性能优化</h3><p>解析：</p>
<p>\1. 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。</p>
<p>\2. 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。</p>
<p>总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。</p>
<p>前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。</p>
<p>一、页面级优化</p>
<p>\1. JavaScript 压缩和模块打包</p>
<p>\2. 按需加载资源</p>
<p>\3. 在使用 DOM 操作库时用上 array-ids</p>
<p>\4. 缓存</p>
<p>\5. 启用 HTTP/2</p>
<p>\6. 应用性能分析</p>
<p>\7. 使用负载均衡方案</p>
<p>\8. 为了更快的启动时间考虑一下同构</p>
<p>\9. 使用索引加速数据库查询</p>
<p>\10. 使用更快的转译方案</p>
<p>\11. 避免或最小化 JavaScript 和 CSS 的使用而阻塞渲染</p>
<p>\12. 用于未来的一个建议：使用 service workers + 流</p>
<p>\13. 图片编码优化</p>
<h3 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a><strong>优雅降级和渐进增强</strong></h3><p>解析：</p>
<p>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p>
<p>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p>
<p>其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容</p>
<h3 id="JS实现对货币数字格式化函数（三位加逗号）"><a href="#JS实现对货币数字格式化函数（三位加逗号）" class="headerlink" title="**JS实现对货币数字格式化函数（三位加逗号） **"></a>**JS实现对货币数字格式化函数（三位加逗号） **</h3><h4 id="调用示例-formatMoney-‘1234567890’-1-234-567-890"><a href="#调用示例-formatMoney-‘1234567890’-1-234-567-890" class="headerlink" title="// 调用示例 formatMoney(‘1234567890’); // 1,234,567,890"></a><strong>// 调用示例 formatMoney(‘1234567890’); // 1,234,567,890</strong></h4><p>解析：</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
function outputmoney(number) &#123;
number = number.replace(/\,/g, &quot;&quot;);
if(isNaN(number) || number == &quot;&quot;)return &quot;&quot;;
number = Math.round(number * 100) / 100;
    if (number &lt; 0)
        return &#39;-&#39; + outputdollars(Math.floor(Math.abs(number) - 0) + &#39;&#39;) + outputcents(Math.abs(number) - 0);
    else
        return outputdollars(Math.floor(number - 0) + &#39;&#39;) + outputcents(number - 0);
&#125; 
//格式化金额
function outputdollars(number) &#123;
    if (number.length &lt;= 3)
        return (number == &#39;&#39; ? &#39;0&#39; : number);
    else &#123;
        var mod = number.length % 3;
        var output = (mod == 0 ? &#39;&#39; : (number.substring(0, mod)));
        for (i = 0; i &lt; Math.floor(number.length / 3); i++) &#123;
            if ((mod == 0) &amp;&amp; (i == 0))
                output += number.substring(mod + 3 * i, mod + 3 * i + 3);
            else
                output += &#39;,&#39; + number.substring(mod + 3 * i, mod + 3 * i + 3);
        &#125;
        return (output);
    &#125;
&#125;
function outputcents(amount) &#123;
    amount = Math.round(((amount) - Math.floor(amount)) * 100);
    return (amount &lt; 10 ? &#39;.0&#39; + amount : &#39;.&#39; + amount);
&#125;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=text   maxlength=&quot;8&quot; id=&quot;test&quot; onblur=&quot;this.value=outputmoney(this.value);&quot; &gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="异步笔试题"><a href="#异步笔试题" class="headerlink" title="异步笔试题"></a>异步笔试题</h3><p>请写出下面代码的运行结果</p>
<pre><code>async function async1() &#123;
    console.log(&#39;async1 start&#39;);
    await async2();
    console.log(&#39;async1 end&#39;);
&#125;
async function async2() &#123;
    console.log(&#39;async2&#39;);
&#125;
console.log(&#39;script start&#39;);
setTimeout(function() &#123;
    console.log(&#39;setTimeout&#39;);
&#125;, 0)
async1();
new Promise(function(resolve) &#123;
    console.log(&#39;promise1&#39;);
    resolve();
&#125;).then(function() &#123;
    console.log(&#39;promise2&#39;);
&#125;);
console.log(&#39;script end&#39;);
</code></pre>
<h3 id="变式一"><a href="#变式一" class="headerlink" title="变式一"></a>变式一</h3><pre><code>
async function async1() &#123;
    console.log(&#39;async1 start&#39;);
    await async2();
    console.log(&#39;async1 end&#39;);
&#125;
async function async2() &#123;
    //async2做出如下更改：
    new Promise(function(resolve) &#123;
    console.log(&#39;promise1&#39;);
    resolve();
&#125;).then(function() &#123;
    console.log(&#39;promise2&#39;);
    &#125;);
&#125;
console.log(&#39;script start&#39;);

setTimeout(function() &#123;
    console.log(&#39;setTimeout&#39;);
&#125;, 0)
async1();

new Promise(function(resolve) &#123;
    console.log(&#39;promise3&#39;);
    resolve();
&#125;).then(function() &#123;
    console.log(&#39;promise4&#39;);
&#125;);

console.log(&#39;script end&#39;);
</code></pre>
<p>可以先自己看看输出顺序会是什么，下面来公布结果：</p>
<pre><code>script start
async1 start
promise1
promise3
script end
promise2
async1 end
promise4
setTimeout
</code></pre>
<p>在第一次macrotask执行完之后，也就是输出<code>script end</code>之后，会去清理所有microtask。所以会相继输出<code>promise2</code>，<code>async1 end</code>，<code>promise4</code>，其余不再多说。</p>
<h4 id="执行下列的代码会输出什么？"><a href="#执行下列的代码会输出什么？" class="headerlink" title="执行下列的代码会输出什么？"></a>执行下列的代码会输出什么？</h4><pre><code class="js">const a = &#123;&#125;
const b = &#123; key: &#39;b&#39; &#125;
const c = &#123; key: &#39;c&#39; &#125;

a[b] = 123
a[c] = 456

console.log(a[b])

答案：456
</code></pre>
<p>解析：</p>
<p>对象的键会自动转换为字符串，我们试图将对象b设置为对象a的键。<br>当将一个对象转化为字符串的时候，会变成”[object Object]” 所以，a[“[object Object]”] = 123 。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[“[object Object]”] =456。然后，我们打印 a[b]，也就是 a[“[object Object]”]。之前刚设置为 456，因此返回的是 456。</p>
<h3 id="js原型遵循5个规则："><a href="#js原型遵循5个规则：" class="headerlink" title="js原型遵循5个规则："></a>js原型遵循5个规则：</h3><p>1、所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”以外）；</p>
<p>2、所有的引用类型（数组、对象、函数），都有一个__proto__（隐式原型）属性，属性值是一个普通的对象；</p>
<p>3、所有的函数，都有一个prototype（显式原型）属性，属性值也是一个普通对象；</p>
<p>4、所有的引用类型（数组、对象、函数），__proto__属性值指向（完全相等）它的构造函数的 “prototype” 属性值；</p>
<p>5、当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去 proto（ 即它的构造函数的 prototype 中）寻找。</p>
<h3 id="js实现把一个字符串的大小写取反"><a href="#js实现把一个字符串的大小写取反" class="headerlink" title="js实现把一个字符串的大小写取反"></a>js实现把一个字符串的大小写取反</h3><p>方法1：利用正则表达式</p>
<p>思路：</p>
<p>大小写取反，最先想到的是替换 replace<br>怎么实现替换，通过正则，首先找到所有字母 /[a-zA-Z]/g<br>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br>实现：如果当前的字母转化为大写还和自己一样，那么他铁定就是大写字母，利用三木运算，是大写，那么就变为小写，反之<br>每一次正则匹配的结果返回<br>代码：</p>
<pre><code class="js">function reverseChar(str) &#123;
    // 使用正则的全局匹配
    str = str.replace(/[a-zA-Z]/g, content =&gt; &#123;
        // content : 每一次正则匹配的结果
        return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase()
    &#125;)
    return str;
&#125;
</code></pre>
<p>方法2：利用 charAt()</p>
<p> // 第二种方法是利用 字符串中的charAt(i) —来获取字符串中的每一个字符（）—–再比较编码集<br>  //charAt()——–比较的是Unicode编码集—–charAt(i)找的是字符串中第i个字符</p>
<pre><code class="js">    var str1 = &quot;azcBfHIjs&quot;
    console.log(str1);

    var newStr = &#39;&#39;;//保存转换后的字符串

    for (var i = 0; i &lt; str1.length; i++) &#123;
    
        if (str1.charAt(i) &gt;= &#39;a&#39;) &#123;//a unicode是97、比a大的是小写字母
            aa = str1.charAt(i).toUpperCase();
        &#125;
        else if (str1.charAt(i) &gt;= &#39;A&#39;) &#123;//A unicode 是65、比A 大的是大写字母
            aa = str1.charAt(i).toLowerCase();

        &#125;
        newStr = newStr + aa;//字符串的拼接的思想就是 新建一个数组
    &#125;

    console.log(newStr);
</code></pre>
<h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><h5 id="简单遍历"><a href="#简单遍历" class="headerlink" title="简单遍历"></a>简单遍历</h5><pre><code class="js">let arr = [1, [2, [4, [5, [6]]]]];
function flat(arr) &#123;
    let result = [];
    arr.forEach((item) =&gt; &#123;
        if(Array.isArray(item)) &#123;
            result = result.concat(flat(item));
        &#125;else &#123;
            result.push(item);
        &#125;
    &#125;)
    return: result;
&#125;
</code></pre>
<h4 id="利用reduce函数迭代"><a href="#利用reduce函数迭代" class="headerlink" title="利用reduce函数迭代"></a>利用reduce函数迭代</h4><pre><code class="js">var arr = [1, [2, [4, [5, [6]]]]]
function flatten1(arr) &#123;
   return arr.reduce((res, next) =&gt; &#123;
      return res.concat(Array.isArray(next) ? flatten1(next) : next)
   &#125;, [])
&#125;
console.log(flatten1(arr))  // [1,2,3,4,5,6]
</code></pre>
<h3 id="js-加载过程阻塞，解决方法"><a href="#js-加载过程阻塞，解决方法" class="headerlink" title="js 加载过程阻塞，解决方法"></a>js 加载过程阻塞，解决方法</h3><p>指定 script 标签的 async 属性。</p>
<p>如果<code>async=&quot;async&quot;</code>，脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）。</p>
<p>如果不使用 async 且 <code>defer=&quot;defer&quot;</code>：脚本将在页面完成解析时执行。</p>

                </div>

                <div class="menuShow">
                    <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24">
                        <path
                            d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z"
                            fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path>
                    </svg>
                </div>
                <div class="top">
                    <svg width="8" height="14" viewBox="0 0 8 14">
                        <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd"
                            stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
</section>
<script src="/js/nav.js"></script>
<!-- 
<script src="/js/nav.js"></script>
 -->
                                        <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>

<link rel="stylesheet" href="/css/nord.css" type="text/css" />
<script src="/js/highlight.min.js"></script>
<script src="/js/highlightjs-line-numbers.js"></script>

<!-- 
<link rel="stylesheet" href="/css/nord.css">

    
<script src="/js/highlight.min.js"></script>

        
<script src="/js/highlightjs-line-numbers.js"></script>
 -->

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
            </div>
        </div>
        <script>
            const loader = document.querySelector('.load');
            const paper = document.querySelector('.paper');
            const ch_span = document.querySelector('.load .h-mes>#chs');
            const no_wait = document.querySelector('.load #noWait');
    
            const ch_array = ['" 或许再等一会.. "', '" 等待是为了更好的阅读体验 "', '" 就快加载完了 "', '" 还差一点... "', '" 感谢你的坚持 ! "']
            let i = 0, j = 0;
            var show_main = setInterval(() => {
                ch_span.innerHTML = ch_array[i];
                i > 3 ? i = 0 : i ++;
                j > 1 ? no_wait.style.display = 'block' : j ++;
            }, 1800);
            // console.log(23542365)
            window.addEventListener('load',showMain);
            no_wait.addEventListener('click', showMain);
    
            function showMain() {
                loader.style.display = 'none';
                paper.style.display = 'block';
                show_main = null;
                clearInterval(show_main);
                console.log(1)
            }
        </script>
    </body>
</html>