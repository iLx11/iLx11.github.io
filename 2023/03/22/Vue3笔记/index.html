<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:700px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:700px)" href="/css/stylePC.css" type="text/css" />
    <link rel="stylesheet" href="/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="/css/markdown.css" type="text/css" />
    <link rel="stylesheet" href="/css/fonts.css" type="text/css" />

    <title>
        iLx1 |
            
    </title>
    <!-- 
<link rel="stylesheet" href="/css/reset.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/markdown.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/fonts.css">
 -->
<meta name="generator" content="Hexo 5.4.2"></head>
    <style>
        /*页面加载开始*/
        .load {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 35em;
            z-index: 999;
        }

        .loader {
            --path: #323641;
            --dot: #6a95bd;
            --duration: 1.5s;
            width: 55px;
            height: 55px;
            align-items: center;
            justify-items: center;
            position: relative;
        }
        .h-mes {
            width: 100%;
            height: 20%;
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-flow: column nowrap;
            justify-content: space-evenly;
            align-items: center;
        }
        .h-mes span {
            width: 100%;
            height: 10%;
            text-align: center;
        }
        .loader:before {
            content: "";
            width: 6px;
            height: 6px;
            border-radius: 50%;
            position: absolute;
            display: block;
            background: var(--dot);
            top: 37px;
            left: 19px;
            transform: translate(-18px, -18px);
        }

        .loader svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .loader svg polygon {
            fill: none;
            stroke: var(--path);
            stroke-width: 10px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .loader svg polygon {
            stroke-dasharray: 145 76 145 76;
            stroke-dashoffset: 0;
            animation: pathTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }

        .loader.triangle {
            width: 48px;
        }

        .loader.triangle:before {
            left: 21px;
            transform: translate(-10px, -18px);
            animation: dotTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }
        #noWait {
            color: rgba(51,51,51, 0.4);
            margin-top: 3em;
            cursor: pointer;
            display: none;
        }
        @keyframes pathTriangle {
            33% {
                stroke-dashoffset: 74;
            }

            66% {
                stroke-dashoffset: 147;
            }

            100% {
                stroke-dashoffset: 221;
            }
        }

        @keyframes dotTriangle {
            33% {
                transform: translate(0, 0);
            }

            66% {
                transform: translate(10px, -18px);
            }

            100% {
                transform: translate(-10px, -18px);
            }

        }
    </style>

    <body>
        <!-- 页面加载效果 -->
        <div class="load">
            <div class="loader triangle">
                <svg viewBox="0 0 86 80">
                    <polygon points="43 8 79 72 7 72"></polygon>
                </svg>
            </div>
            <div class="h-mes">
                <span id="chs">" 请稍等一会... "</span>
                <span>Please wait for a long time</span>
                <span id="noWait"><我不等啦！></span>
            </div>
        </div>
        
        <!-- 页面加载结束 -->
        <div class="backg"></div>
        <div class="paper">
            <div class="paper-main">
                
                
                <!-- <div class="bgimg"></div> -->
                <div class="cover"></div>
                <!-- <div class="bgimgB"></div> -->
                
                    <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                        
                                    <section class="post-struction">
    <div class="post-main">
        
            <div class="post-main-title">
                Vue3笔记
            </div>
            <div class="post-meta">
                2023-03-22
            </div>
            
                <hr>
                <div class="post-md">
                    <p>d</p>
<h2 id="创建-Vue3-项目"><a href="#创建-Vue3-项目" class="headerlink" title="创建 Vue3 项目"></a>创建 Vue3 项目</h2><h3 id="vue-cil"><a href="#vue-cil" class="headerlink" title="vue-cil"></a>vue-cil</h3><pre><code class="sh">npm install -g @vue/cli

vue create project 
# Manually select features
# 选择 3.x
#（*）空格选择
# no history mode -&gt; hash模式
# Standard config
# lint in save
# dedicated config files
# Sava preset(模板)
</code></pre>
<h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用 NPM:</p>
<pre><code class="bash">npm init vite@latest
</code></pre>
<p>使用 Yarn:</p>
<pre><code class="sql">yarn create vite
</code></pre>
<p>使用 PNPM:</p>
<pre><code class="sql">pnpm create vite
</code></pre>
<h4 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h4><pre><code class="sh">npm init vite-app &lt;project-name&gt;
cd &lt;project-name&gt;
npm install 
</code></pre>
<h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><pre><code class="sh">npm run dev
# yarn dev
# vite
</code></pre>
<p>组合 API （Composition API)</p>
<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><ul>
<li>新的option, 所有的组合API函数都在此使用, 只在初始化时执行一次</li>
<li>函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><h4 id="基本类型响应式数据"><a href="#基本类型响应式数据" class="headerlink" title="基本类型响应式数据"></a>基本类型响应式数据</h4><blockquote>
<p>创建一个包含响应式数据的引用(reference)对象</p>
<p>js中操作数据: xxx.value</p>
<p>模板中操作数据: 不需要.value</p>
</blockquote>
<pre><code class="ts">import &#123; ref &#125; from &#39;vue&#39;

export default &#123;
    setup() &#123;
        const count = ref(10)
        function updataCount() &#123;
            count.value += 6;
        &#125;
        // 模板中使用
        return &#123;
            count,
            updataCount
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><h4 id="定义多个数据响应式"><a href="#定义多个数据响应式" class="headerlink" title="定义多个数据响应式"></a>定义多个数据响应式</h4><blockquote>
<p>const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象</p>
<p>响应式转换是“深层的”：会影响对象内部所有<code>嵌套的属性</code></p>
<p>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</p>
</blockquote>
<pre><code class="ts">import &#123; reactive &#125; from &#39;vue&#39;

export default &#123;
    setup() &#123;
        const student = reactive(&#123;
            name: &#39;li&#39;,
            hobby: &#123;
                   kind: &#39;draw&#39;
            &#125;
        &#125;)
        const updataStudent = () =&gt; &#123;
            student.name += &#39;--&#39;
            student.hobby.kind += &#39;--&#39;
        &#125;
        return &#123;
            student
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="响应式比较"><a href="#响应式比较" class="headerlink" title="响应式比较"></a>响应式比较</h2><p>-</p>
<h3 id="vue2的响应式"><a href="#vue2的响应式" class="headerlink" title="vue2的响应式"></a>vue2的响应式</h3><h4 id="核心"><a href="#核心" class="headerlink" title="核心:"></a>核心:</h4><ul>
<li>对象: 通过defineProperty对对象的已有属性值的读取和修改进行劫持(监视/拦截)</li>
<li>数组: 通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持</li>
</ul>
<pre><code class="js">Object.defineProperty(data, &#39;count&#39;, &#123;
    get () &#123;&#125;, 
    set () &#123;&#125;
&#125;)
</code></pre>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h4><ul>
<li>对象直接新添加的属性或删除已有属性, 界面不会自动更新</li>
<li>直接通过下标替换元素或更新length, 界面不会自动更新 arr[1] = {}</li>
</ul>
<p>-</p>
<h3 id="Vue3的响应式"><a href="#Vue3的响应式" class="headerlink" title="Vue3的响应式"></a>Vue3的响应式</h3><h4 id="核心-1"><a href="#核心-1" class="headerlink" title="核心:"></a>核心:</h4><ul>
<li><p>通过Proxy(代理): 拦截对data任意属性的任意(13种)操作, 包括属性值的读写, 属性的添加, 属性的删除等…</p>
</li>
<li><p>通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作</p>
</li>
<li><p>文档:</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
</li>
</ul>
<pre><code class="js">new Proxy(data, &#123;
    // 拦截读取属性值
    get (target, prop) &#123;
        return Reflect.get(target, prop)
    &#125;,
    // 拦截设置属性值或添加新属性
    set (target, prop, value) &#123;
        return Reflect.set(target, prop, value)
    &#125;,
    // 拦截删除属性
    deleteProperty (target, prop) &#123;
        return Reflect.deleteProperty(target, prop)
    &#125;
&#125;)

proxy.name = &#39;tom&#39;  
</code></pre>
<h2 id="setup细节"><a href="#setup细节" class="headerlink" title="setup细节"></a>setup细节</h2><ul>
<li>setup执行的时机<ul>
<li>在beforeCreate之前执行(一次), 此时组件对象还没有创建</li>
<li>this是undefined, 不能通过this来访问data/computed/methods / props</li>
<li>其实所有的composition API相关回调函数中也都不可以</li>
</ul>
</li>
<li>setup的返回值<ul>
<li>一般都返回一个对象: 为模板提供数据, 也就是模板中可以直接使用此对象中的所有属性/方法</li>
<li>返回对象中的属性会与data函数返回对象的属性合并成为组件对象的属性</li>
<li>返回对象中的方法会与methods中的方法合并成功组件对象的方法</li>
<li>如果有重名, setup优先</li>
<li>注意:</li>
<li>一般不要混合使用: methods中可以访问setup提供的属性和方法, 但在setup方法中不能访问data和methods</li>
<li>setup不能是一个async函数: 因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性数据</li>
</ul>
</li>
<li>setup的参数<ul>
<li>setup(props, context) / setup(props, {attrs, slots, emit})</li>
<li>props: 包含props配置声明且传入了的所有属性的对象</li>
<li>attrs: 包含没有在props配置中声明的属性的对象, 相当于 this.$attrs</li>
<li>slots: 包含所有传入的插槽内容的对象, 相当于 this.$slots</li>
<li>emit: 用来分发自定义事件的函数, 相当于 this.$emit</li>
</ul>
</li>
</ul>
<h2 id="reactive与ref-细节"><a href="#reactive与ref-细节" class="headerlink" title="reactive与ref-细节"></a>reactive与ref-细节</h2><ul>
<li>是Vue3的 composition API中2个最重要的响应式API</li>
<li>ref用来处理基本类型数据, reactive用来处理对象(递归深度响应式)</li>
<li>如果用ref对象/数组, 内部会自动将对象/数组转换为reactive的代理对象</li>
<li>ref内部: 通过给value属性添加getter/setter来实现对数据的劫持</li>
<li>reactive内部: 通过使用Proxy来实现对对象内部所有数据的劫持, 并通过Reflect操作对象内部数据</li>
<li>ref的数据操作: 在js中要.value, 在模板中不需要(内部解析模板时会自动添加.value)</li>
</ul>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h4 id="只有-getter-的计算属性"><a href="#只有-getter-的计算属性" class="headerlink" title="只有 getter 的计算属性"></a>只有 getter 的计算属性</h4><pre><code class="ts">const fullName = computed(() =&gt; &#123;
    return user.fistName + &#39;-&#39; + user.lastName
&#125;)
</code></pre>
<h4 id="有-getter-和-setter-的计算属性"><a href="#有-getter-和-setter-的计算属性" class="headerlink" title="有 getter 和 setter 的计算属性"></a>有 getter 和 setter 的计算属性</h4><pre><code class="ts">const fullName = computed(&#123;
    get() &#123;
        return user.fistName + &#39;-&#39; + user.lastName
    &#125;,
    set(value: string) &#123;
        const names = value.split(&#39;-&#39;)
        user.firstName = names[0]
        user.lastName = names[1]
    &#125;
&#125;)
</code></pre>
<h2 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h2><pre><code class="ts">watch(user, () =&gt; &#123;
    const name = user.firstName + &#39;-&#39; + user.lastName
&#125;, &#123;
       immediate: true,
    deep: true
&#125;)
// 默认立即开始监视
 watchEffect(() =&gt; &#123;
    fullName3.value = user.firstName + &#39;-&#39; + user.lastName
&#125;) 
</code></pre>
<h3 id="对reactive数据的某个属性进行监听"><a href="#对reactive数据的某个属性进行监听" class="headerlink" title="对reactive数据的某个属性进行监听"></a>对reactive数据的某个属性进行监听</h3><h4 id="对某个属性进行监听"><a href="#对某个属性进行监听" class="headerlink" title="对某个属性进行监听"></a>对某个属性进行监听</h4><pre><code class="ts">watch(()=&gt;person.name,(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue);
&#125;,&#123;immediate:true,deep:true&#125;)
</code></pre>
<h4 id="对两个及以上的reactive属性进行监听"><a href="#对两个及以上的reactive属性进行监听" class="headerlink" title="对两个及以上的reactive属性进行监听"></a>对两个及以上的reactive属性进行监听</h4><pre><code class="ts">watch([()=&gt;person.name,()=&gt;person.age],(newValue,oldValue)=&gt;&#123;
    console.log(newValue,oldValue);
&#125;,&#123;immediate:true,deep:true&#125;)
</code></pre>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><strong>与 2.x 版本生命周期相对应的组合式 API</strong></p>
<ul>
<li><code>beforeCreate</code> -&gt; 使用 <code>setup()</code></li>
<li><code>created</code> -&gt; 使用 <code>setup()</code></li>
<li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li>
<li><code>mounted</code> -&gt; <code>onMounted</code></li>
<li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li>
<li><code>updated</code> -&gt; <code>onUpdated</code></li>
<li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li>
<li><code>destroyed</code> -&gt; <code>onUnmounted</code></li>
<li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li>
</ul>
<p><strong>新增的钩子函数</strong></p>
<p>组合式 API 还提供了以下调试钩子函数：</p>
<ul>
<li>onRenderTracked</li>
<li>onRenderTriggered</li>
</ul>
<pre><code class="ts">import &#123;
  ref,
  onMounted,
  onUpdated,
  onUnmounted, 
  onBeforeMount, 
  onBeforeUpdate,
  onBeforeUnmount
&#125; from &quot;vue&quot;
</code></pre>
<ul>
<li>利用TS泛型强化类型检查</li>
<li>封装发ajax请求的hook函数</li>
</ul>
<pre><code class="ts">import &#123; ref &#125; from &#39;vue&#39;
import &#123; axios &#125; from &#39;axios&#39;

export const getUser&lt;T&gt; = (url: string) =&gt; &#123;
    const result = ref&lt;T | null&gt;(null)
    const loading = ref(true)
    const errorMsg = ref(null)
    axios.get(url)
    .then(response =&gt; &#123;
         result.value = response.data
        loading.value = false
    &#125;)
    ,catch(error =&gt; &#123;
        loading.value = false
        errorMsg.value = error.message || &quot;未知错误&quot;
    &#125;)
    return &#123;
        loading,
        result,
        errorMsg
    &#125;
&#125;
</code></pre>
<h2 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h2><p>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref</p>
<p>应用: 当从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用</p>
<p>问题: reactive 对象取出的所有属性值都是非响应式的（解构后非响应）</p>
<p>解决: 利用 toRefs 可以将一个响应式 reactive 对象的所有原始属性转换为响应式的 ref 属性</p>
<pre><code class="ts">import &#123; ref, reactive &#125; from &#39;vue&#39;
setup() &#123;
    const state = reactive(&#123;
        name: &#39;l&#39;,
        age: 121
    &#125;)
    const &#123; name, age &#125; = toRefs(state)
&#125;
</code></pre>
<h2 id="ref获取元素"><a href="#ref获取元素" class="headerlink" title="ref获取元素"></a>ref获取元素</h2><p>操作 dom</p>
<pre><code class="vue">&lt;template&gt;
    &lt;input type=&quot;text&quot; ref=&quot;inpRef&quot; &gt;
&lt;/template&gt;

export default &#123;
    setup() &#123;
        const inpRef = ref&lt;HTMLElement | null&gt;(null)
            onMounted() &#123;
            inpRef.value &amp;&amp; inpRef.value.focus()
        &#125;
        return &#123;
            inpRef        
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="hallowReactive-与-shallowRef"><a href="#hallowReactive-与-shallowRef" class="headerlink" title="hallowReactive 与 shallowRef"></a>hallowReactive 与 shallowRef</h2><ul>
<li>shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式)</li>
<li>shallowRef: 只处理了value的响应式, 不进行对象的reactive处理</li>
<li>什么时候用浅响应式呢?<ul>
<li>一般情况下使用ref和reactive即可</li>
<li>如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive</li>
<li>如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef</li>
</ul>
</li>
</ul>
<h2 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h2><ul>
<li>readonly:<ul>
<li>深度只读数据</li>
<li>获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。</li>
<li>只读代理是深层的：访问的任何嵌套 property 也是只读的。</li>
</ul>
</li>
<li>shallowReadonly<ul>
<li>浅只读数据</li>
<li>创建一个代理，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换</li>
</ul>
</li>
<li>应用场景:<ul>
<li>在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除</li>
</ul>
</li>
</ul>
<h2 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h2><ul>
<li>toRaw<ul>
<li>返回由 <code>reactive</code> 或 <code>readonly</code> 方法转换成响应式代理的普通对象。</li>
<li>这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发界面更新。</li>
</ul>
</li>
<li>markRaw<ul>
<li>标记一个对象，使其永远不会转换为代理。返回对象本身</li>
<li>应用场景:<ul>
<li>有些值不应被设置为响应式的，例如复杂的第三方类实例或 Vue 组件对象。</li>
<li>当渲染具有不可变数据源的大列表时，跳过代理转换可以提高性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h2><ul>
<li><p>为源响应式对象上的某个属性创建一个 ref对象, 二者内部操作的是同一个数据值, </p>
<p>更新时二者是同步的（相当于引用）</p>
</li>
<li><p>区别ref: 拷贝了一份新的数据值单独操作, 更新时相互不影响</p>
</li>
<li><p>应用: 当要将 某个prop 的 ref 传递给复合函数时，toRef 很有用</p>
</li>
</ul>
<pre><code class="ts">setup() &#123;
    const state = reactive(&#123;
        foo: &#39;name&#39;
    &#125;)
    const foo = toRef(state, &#39;foo&#39;)
    return &#123;
        foo
    &#125;
&#125;
</code></pre>
<h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h2><ul>
<li>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制（控制更新页面的时机）</li>
<li>需求: 使用 customRef 实现 debounce 的示例</li>
</ul>
<pre><code class="tsx">// 实现延迟更改
&lt;template&gt;
    &lt;input v-model=&quot;userRef&quot;&gt;
&lt;/template&gt;
export default &#123;
    const userRef = userDevouncedRef(&#39;&#39;, 200)
    return &#123;
        userRef
    &#125;
&#125;
// 实现函数防抖的自定义 ref
function userDevouncedRef&lt;T&gt;(value: T, dalay = 200) &#123;
    let timeout: number
    return customRef((track, trigger) =&gt; &#123;
        return &#123;
            get() &#123;
                // 追踪数据
                return value
            &#125;,
            set(newValue: T) &#123;
                clearTimeout(timeout)
                timeout = setTimeout(() =&gt; &#123;
                       value = newValue
                    // 告诉 Vue 触发界面更新
                    trigger()
                &#125;, delay)
            &#125;
        &#125;
    &#125;)
&#125;
</code></pre>
<h1 id="组件间传值"><a href="#组件间传值" class="headerlink" title="组件间传值"></a>组件间传值</h1><h2 id="props-amp-emit"><a href="#props-amp-emit" class="headerlink" title="props &amp; emit"></a>props &amp; emit</h2><pre><code class="vue">&lt;script setup=&quot;props, &#123;emit&#125;&quot;&gt;
    const props = defineProps(&#123;
        msg: &#123;
            type: Stirng,
            default: () =&gt; &quot;default&quot;
        &#125;
    &#125;)
    const msg = ref(props.msg)
    // emits
    const emits = defineEmits([&#39;method&#39;])
    emits(&#39;method&#39;, params)
&lt;/script&gt;
</code></pre>
<h3 id="子组件默认不对外暴露数据，我们需要用到defineExpose"><a href="#子组件默认不对外暴露数据，我们需要用到defineExpose" class="headerlink" title="子组件默认不对外暴露数据，我们需要用到defineExpose({})"></a>子组件默认不对外暴露数据，我们需要用到defineExpose({})</h3><p>子组件对外暴露之后，父组件才能调用</p>
<pre><code class="ts">defineExpose(&#123;
  list2
&#125;)
</code></pre>
<h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><p>provide<code>和</code>inject<code>提供依赖注入，功能类似 2.x 的</code>provide/inject</p>
<h4 id="实现跨层级组件-祖孙-间通信"><a href="#实现跨层级组件-祖孙-间通信" class="headerlink" title="实现跨层级组件(祖孙)间通信"></a>实现跨层级组件(祖孙)间通信</h4><pre><code class="ts">// 父组件
/*&lt;template&gt;
    &lt;son /&gt;
  &lt;template/&gt;
*/
import &#123; ref, provide &#125; from &#39;vue&#39;
setup() &#123;
    const color = ref(&#39;red&#39;)
    provide(&#39;color&#39;, color)
    return &#123;
        color
    &#125;
&#125;

// 子/子孙组件
import &#123; inject &#125; from &#39;vue&#39;
setup() &#123;
    const color = inject(&#39;color&#39;)
    return &#123;
        color
    &#125;
&#125;
</code></pre>
<h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>如果是在<script setup>定义组件内的指令，有一个语法糖可以使用：</p>
<p>任何以v开头的驼峰式命名的变量都可以被用作一个自定义指令，然后在模板中使用。</p>
<pre><code class="vue">&lt;script setup&gt; 
    const vFocus = &#123;
        mounted: (el) =&gt; el.focus()
    &#125;
&lt;/script&gt;
</code></pre>
<p>如果是使用选项式，则自定义指令需要在<code>directives</code>选项中注册</p>
<pre><code class="vue">&lt;script&gt; 
    export default &#123;
        setup() &#123;&#125;,
        derectives: &#123;
            focus: &#123;
                mounted(el) &#123;
                    el.focus()
                &#125;
            &#125;
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
<h2 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h2 id="手写组合-API"><a href="#手写组合-API" class="headerlink" title="手写组合 API"></a>手写组合 API</h2><pre><code class="ts">const reactiveHandler = &#123;
  get (target, key) &#123;

    if (key===&#39;_is_reactive&#39;) return true

    return Reflect.get(target, key)
  &#125;,

  set (target, key, value) &#123;
    const result = Reflect.set(target, key, value)
    console.log(&#39;数据已更新, 去更新界面&#39;)
    return result
  &#125;,

  deleteProperty (target, key) &#123;
    const result = Reflect.deleteProperty(target, key)
    console.log(&#39;数据已删除, 去更新界面&#39;)
    return result
  &#125;,
&#125;

/* 
自定义shallowReactive
*/
function shallowReactive(obj) &#123;
  return new Proxy(obj, reactiveHandler)
&#125;

/* 
自定义reactive
*/
function reactive (target) &#123;
  if (target &amp;&amp; typeof target===&#39;object&#39;) &#123;
    if (target instanceof Array) &#123; // 数组
      target.forEach((item, index) =&gt; &#123;
        target[index] = reactive(item)
      &#125;)
    &#125; else &#123; // 对象
      Object.keys(target).forEach(key =&gt; &#123;
        target[key] = reactive(target[key])
      &#125;)
    &#125;

    const proxy = new Proxy(target, reactiveHandler)
    return proxy
  &#125;

  return target
&#125;

/*
自定义shallowRef
*/
function shallowRef(target) &#123;
  const result = &#123;
    _value: target, // 用来保存数据的内部属性
    _is_ref: true, // 用来标识是ref对象
    get value () &#123;
      return this._value
    &#125;,
    set value (val) &#123;
      this._value = val
      console.log(&#39;set value 数据已更新, 去更新界面&#39;)
    &#125;
  &#125;

  return result
&#125;

/* 
自定义ref
*/
function ref(target) &#123;
  if (target &amp;&amp; typeof target===&#39;object&#39;) &#123;
    target = reactive(target)
  &#125;

  const result = &#123;
    _value: target, // 用来保存数据的内部属性
    _is_ref: true, // 用来标识是ref对象
    get value () &#123;
      return this._value
    &#125;,
    set value (val) &#123;
      this._value = val
      console.log(&#39;set value 数据已更新, 去更新界面&#39;)
    &#125;
  &#125;
  return result
&#125;
</code></pre>
<h1 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h1><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code class="sh">yarn add pinia
# 或者使用 npm
npm install pinia
</code></pre>
<h3 id="项目导入-pinia"><a href="#项目导入-pinia" class="headerlink" title="项目导入 pinia"></a>项目导入 pinia</h3><pre><code class="sh">import &#123; createPinia &#125; from &#39;pinia&#39;

createApp(App).use(router).use(createPinia()).mount(&#39;#app&#39;)
</code></pre>
<pre><code class="ts">// stores/counter.js
import &#123; defineStore &#125; from &#39;pinia&#39;

export const useCounterStore = defineStore(&#39;counter&#39;, &#123;
  state: () =&gt; &#123;
    return &#123; count: 0 &#125;
  &#125;,
  // 也可以定义为
  // state: () =&gt; (&#123; count: 0 &#125;)
  actions: &#123;
    increment() &#123;
      this.count++
    &#125;,
  &#125;,
&#125;)
</code></pre>
<h2 id="state的五种方式修改值"><a href="#state的五种方式修改值" class="headerlink" title="state的五种方式修改值"></a>state的五种方式修改值</h2><pre><code class="ts">state的五种方式修改值
1.直接修改值
    Test.current=2
2.通过$patch修改,支持单个或多个属性修改
    Test.$patch(&#123;current:33&#125;)
3.$patch工厂函数方式
    Test.$patch((state) =&gt; &#123;
      state.current = 99;
      state.name = &#39;范迪塞尔&#39;
    &#125;)
4.$state 缺点是必须修改整个对象
    Test.$state = &#123; current: 88, name: &#39;123&#39; &#125;
5.action
    Test.setCurrent()
</code></pre>

                </div>

                <div class="menuShow">
                    <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24">
                        <path
                            d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z"
                            fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path>
                    </svg>
                </div>
                <div class="top">
                    <svg width="8" height="14" viewBox="0 0 8 14">
                        <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd"
                            stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
</section>
<script src="/js/nav.js"></script>
<!-- 
<script src="/js/nav.js"></script>
 -->
                                        <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>

<link rel="stylesheet" href="/css/nord.css" type="text/css" />
<script src="/js/highlight.min.js"></script>
<script src="/js/highlightjs-line-numbers.js"></script>

<!-- 
<link rel="stylesheet" href="/css/nord.css">

    
<script src="/js/highlight.min.js"></script>

        
<script src="/js/highlightjs-line-numbers.js"></script>
 -->

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
            </div>
        </div>
        <script>
            const loader = document.querySelector('.load');
            const paper = document.querySelector('.paper');
            const ch_span = document.querySelector('.load .h-mes>#chs');
            const no_wait = document.querySelector('.load #noWait');
    
            const ch_array = ['" 或许再等一会.. "', '" 等待是为了更好的阅读体验 "', '" 就快加载完了 "', '" 还差一点... "', '" 感谢你的坚持 ! "']
            let i = 0, j = 0;
            var show_main = setInterval(() => {
                ch_span.innerHTML = ch_array[i];
                i > 3 ? i = 0 : i ++;
                j > 1 ? no_wait.style.display = 'block' : j ++;
            }, 1800);
            // console.log(23542365)
            window.addEventListener('load',showMain);
            no_wait.addEventListener('click', showMain);
    
            function showMain() {
                loader.style.display = 'none';
                paper.style.display = 'block';
                show_main = null;
                clearInterval(show_main);
                console.log(1)
            }
        </script>
    </body>
</html>