<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:700px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:700px)" href="/css/stylePC.css" type="text/css" />
    <link rel="stylesheet" href="/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="/css/markdown.css" type="text/css" />
    <link rel="stylesheet" href="/css/fonts.css" type="text/css" />

    <title>
        iLx1 |
            
    </title>
    <!-- 
<link rel="stylesheet" href="/css/reset.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/markdown.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/fonts.css">
 -->
<meta name="generator" content="Hexo 5.4.2"></head>
    <style>
        /*页面加载开始*/
        .load {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 35em;
            z-index: 999;
        }

        .loader {
            --path: #323641;
            --dot: #6a95bd;
            --duration: 1.5s;
            width: 55px;
            height: 55px;
            align-items: center;
            justify-items: center;
            position: relative;
        }
        .h-mes {
            width: 100%;
            height: 20%;
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-flow: column nowrap;
            justify-content: space-evenly;
            align-items: center;
        }
        .h-mes span {
            width: 100%;
            height: 10%;
            text-align: center;
        }
        .loader:before {
            content: "";
            width: 6px;
            height: 6px;
            border-radius: 50%;
            position: absolute;
            display: block;
            background: var(--dot);
            top: 37px;
            left: 19px;
            transform: translate(-18px, -18px);
        }

        .loader svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .loader svg polygon {
            fill: none;
            stroke: var(--path);
            stroke-width: 10px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .loader svg polygon {
            stroke-dasharray: 145 76 145 76;
            stroke-dashoffset: 0;
            animation: pathTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }

        .loader.triangle {
            width: 48px;
        }

        .loader.triangle:before {
            left: 21px;
            transform: translate(-10px, -18px);
            animation: dotTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }
        #noWait {
            color: rgba(51,51,51, 0.4);
            margin-top: 3em;
            cursor: pointer;
            display: none;
        }
        @keyframes pathTriangle {
            33% {
                stroke-dashoffset: 74;
            }

            66% {
                stroke-dashoffset: 147;
            }

            100% {
                stroke-dashoffset: 221;
            }
        }

        @keyframes dotTriangle {
            33% {
                transform: translate(0, 0);
            }

            66% {
                transform: translate(10px, -18px);
            }

            100% {
                transform: translate(-10px, -18px);
            }

        }
    </style>

    <body>
        <!-- 页面加载效果 -->
        <div class="load">
            <div class="loader triangle">
                <svg viewBox="0 0 86 80">
                    <polygon points="43 8 79 72 7 72"></polygon>
                </svg>
            </div>
            <div class="h-mes">
                <span id="chs">" 请稍等一会... "</span>
                <span>Please wait for a long time</span>
                <span id="noWait"><我不等啦！></span>
            </div>
        </div>
        
        <!-- 页面加载结束 -->
        <div class="backg"></div>
        <div class="paper">
            <div class="paper-main">
                
                
                <!-- <div class="bgimg"></div> -->
                <div class="cover"></div>
                <!-- <div class="bgimgB"></div> -->
                
                    <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo post-header-logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                        
                                    <section class="post-struction">
    <div class="post-main">
        
            <div class="post-main-title">
                ELECTRON+VUE
            </div>
            <div class="post-meta">
                2023-10-17
            </div>
            
                <hr>
                <div class="post-md">
                    <h1 id="ELECTRON-VUE"><a href="#ELECTRON-VUE" class="headerlink" title="ELECTRON+VUE"></a>ELECTRON+VUE</h1><h3 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h3><p><a target="_blank" rel="noopener" href="https://github.com/iLx11/electron-vue3-template">https://github.com/iLx11/electron-vue3-template</a></p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><h2 id="创建-vue3-项目-vite"><a href="#创建-vue3-项目-vite" class="headerlink" title="创建 vue3 项目(vite)"></a>创建 vue3 项目(vite)</h2><pre><code class="bash">npm create vite@latest

# -- Vue
# -- Customize with create-vue
# -- Typecript -&gt; Yes
# -- JSX Support -&gt; No
# -- Router xxxx -&gt; Yes
# -- Pinia -&gt; Yes
# -- Vitest xxxx -&gt; No
# -- End ot End -&gt; No
# -- ESlint -&gt; Yes
# -- Prettier -&gt; Yes

cd &lt;project-name&gt;

npm install
npm run dev
</code></pre>
<h2 id="加入-electron"><a href="#加入-electron" class="headerlink" title="加入 electron"></a>加入 electron</h2><pre><code class="bash">npm install electron --save-dev
</code></pre>
<h2 id="新建-electron-main-目录"><a href="#新建-electron-main-目录" class="headerlink" title="新建 electron / main 目录"></a>新建 electron / main 目录</h2><h3 id="electron-main-main-js"><a href="#electron-main-main-js" class="headerlink" title="electron / main/main.js"></a>electron / main/main.js</h3><p>electron 的入口文件，创建主窗口并监听事件</p>
<pre><code class="jsx">const &#123; app, protocol, BrowserWindow, globalShortcut &#125; = require(&#39;electron&#39;)
// 需在当前文件内开头引入 Node.js 的 &#39;path&#39; 模块
const path = require(&#39;path&#39;)
 
app.commandLine.appendSwitch(&quot;--ignore-certificate-errors&quot;, &quot;true&quot;);
// Scheme must be registered before the app is ready
protocol.registerSchemesAsPrivileged([
    &#123; scheme: &quot;app&quot;, privileges: &#123; secure: true, standard: true &#125; &#125;
]);
 
const createWindow = () =&gt; &#123;
    const win = new BrowserWindow(&#123;
        minWidth: 960,
        minHeight: 540,
        width: 960,
        height: 540,
        // 窗口是否在屏幕居中. 默认值为 false
        center: true,
        // 设置为 false 时可以创建一个无边框窗口 默认值为 true。
        frame: false,
        // 窗口的透明属性
        transparent: true,
        // 窗口是否在创建时显示。 默认值为 true。
        show: true,
        webPreferences: &#123;
            nodeIntegration: true,
            nodeIntegrationInWorker: true,
            preload: path.join(__dirname, &#39;preload.js&#39;),
            webSecurity: false,
        &#125;
    &#125;)
    win.setMenu(null)
    if (app.isPackaged) &#123;
        win.loadURL(`file://$&#123;path.join(__dirname, &#39;../dist/index.html&#39;)&#125;`)
    &#125; else &#123;
        win.loadURL(&#39;http://127.0.0.1:5173/&#39;)
        // 如果显示白屏则使用下面的地址
        // win.loadURL(&#39;http://localhost:5173/&#39;)
        win.webContents.openDevTools()
    &#125;
    globalShortcut.register(&quot;CommandOrControl+Shift+i&quot;, function () &#123;
        win.webContents.openDevTools();
    &#125;);
 
&#125;
 
app.whenReady().then(() =&gt; &#123;
 
    createWindow()
 
    app.on(&#39;activate&#39;, () =&gt; &#123;
        if (BrowserWindow.getAllWindows().length === 0) createWindow()
    &#125;)
&#125;)
 
app.on(&#39;window-all-closed&#39;, () =&gt; &#123;
    if (process.platform !== &#39;darwin&#39;) app.quit()
&#125;)
</code></pre>
<h3 id="electron-main-preload-js"><a href="#electron-main-preload-js" class="headerlink" title="electron / main/preload.js"></a>electron / main/preload.js</h3><p>渲染进程与主进程以此文件为媒介进行交流</p>
<pre><code class="jsx">const &#123; contextBridge, ipcRenderer &#125; = require(&#39;electron&#39;)

// 最小化
const minimizeWindow = () =&gt; &#123;
  ipcRenderer.send(&#39;window-min&#39;)
&#125;

// 最大化
const maximizeWindow = () =&gt; &#123;
  ipcRenderer.send(&#39;window-max&#39;)
&#125;

// 关闭窗口
const closeWindow = () =&gt; &#123;
  ipcRenderer.send(&#39;window-close&#39;)
&#125;

// 裁剪图片
const resizeImage = async (resizeWidth, resizeHeight, editorPicData) =&gt; &#123;
  const data = await ipcRenderer.invoke(&#39;pic-data-editor&#39;, resizeWidth, resizeHeight, editorPicData)
  return data
&#125;

// 生成数据
const generateResultArray = async ( picData, configArray0,  configArray1, configArray2, configArray3) =&gt; &#123;
  const data = ipcRenderer.invoke(&#39;pic-data-parse&#39;, picData, configArray0,  configArray1, configArray2, configArray3)
  return data
&#125;

contextBridge.exposeInMainWorld(&#39;myApi&#39;, &#123;
  minimizeWindow,
  maximizeWindow,
  closeWindow,
  resizeImage,
  generateResultArray
&#125;)
// 所有的 Node.js API接口 都可以在 preload 进程中被调用.
// 它拥有与Chrome扩展一样的沙盒。
window.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; &#123;
  const replaceText = (selector, text) =&gt; &#123;
    const element = document.getElementById(selector)
    if (element) element.innerText = text
  &#125;

  for (const dependency of [&#39;chrome&#39;, &#39;node&#39;, &#39;electron&#39;]) &#123;
    replaceText(`$&#123;dependency&#125;-version`, process.versions[dependency])
  &#125;
&#125;)
</code></pre>
<h3 id="在-package-json-引入-electron-的入口文件-main-js"><a href="#在-package-json-引入-electron-的入口文件-main-js" class="headerlink" title="在 package.json 引入 electron 的入口文件 main.js"></a>在 package.json 引入 electron 的入口文件 main.js</h3><pre><code class="json">&quot;name&quot;: &quot;xxxxxx&quot;,
&quot;version&quot;: &quot;1.0.0&quot;,
&quot;private&quot;: true,
&quot;main&quot;: &quot;electron/main/main.js&quot;, // here
&quot;author&quot;: &quot;iLx1&quot;,
&quot;description&quot;: &quot;xxxxxxxx&quot;,
&quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;vite | electron .&quot;,
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;run-p type-check \&quot;build-only &#123;@&#125;\&quot; --&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;build-only&quot;: &quot;vite build&quot;,
    &quot;type-check&quot;: &quot;vue-tsc --noEmit -p tsconfig.app.json --composite false&quot;,
    &quot;electron:build&quot;: &quot;vite build &amp;&amp; electron-builder&quot;
&#125;,
......
</code></pre>
<p>执行下面命令看显示的效果</p>
<pre><code class="shell">pnpm start / npm run start
</code></pre>
<h2 id="创建-electron-controller"><a href="#创建-electron-controller" class="headerlink" title="创建 electron/controller"></a>创建 electron/controller</h2><h3 id="窗口工具的监听与执行"><a href="#窗口工具的监听与执行" class="headerlink" title="窗口工具的监听与执行"></a>窗口工具的监听与执行</h3><p>electron/controller/windowControl.js</p>
<pre><code class="js">const &#123; ipcMain, BrowserWindow &#125; = require(&#39;electron&#39;)
// 最小化
ipcMain.on(&#39;window-min&#39;, event =&gt; &#123;
  const webContent = event.sender
  const win = BrowserWindow.fromWebContents(webContent)
  win.minimize()
&#125;)

// 最大化
ipcMain.on(&#39;window-max&#39;, event =&gt; &#123;
  const webContent = event.sender
  const win = BrowserWindow.fromWebContents(webContent)
  if (win.isMaximized()) &#123;
    win.restore()
  &#125; else &#123;
    win.maximize()
  &#125;
&#125;)

// 关闭
ipcMain.on(&#39;window-close&#39;, event =&gt; &#123;
  const webContent = event.sender
  const win = BrowserWindow.fromWebContents(webContent)
  win.close()
&#125;)
</code></pre>
<h3 id="在-main-js-入口文件中引入进行监听"><a href="#在-main-js-入口文件中引入进行监听" class="headerlink" title="在 main.js 入口文件中引入进行监听"></a>在 main.js 入口文件中引入进行监听</h3><p>main.js</p>
<pre><code class="js">require(&#39;../controller/windowControl.js&#39;)
</code></pre>
<h3 id="系统托盘"><a href="#系统托盘" class="headerlink" title="系统托盘"></a>系统托盘</h3><p>electron/controller/tray.js</p>
<pre><code class="js">// 创建系统托盘
const &#123; Tray, Menu &#125; = require(&#39;electron&#39;)
// const &#123; ipcRenderer &#125; = require(&#39;electron&#39;)
const path = require(&#39;path&#39;)

const createTray = (app, win) =&gt; &#123;
  let tray = new Tray(path.join(__dirname, &#39;../public/favicon.ico&#39;))
  // if (process.env.NODE_ENV === &#39;development&#39;) &#123;
  // tray = new Tray(path.join(__dirname, &#39;../public/favicon.ico&#39;))
  // &#125; else &#123;
  // tray = new Tray(path.join(path.dirname(app.getPath(&#39;exe&#39;)), &#39;/resources/public/logo.ico&#39;))
  // &#125;
  tray.setToolTip(&#39;xxxxx&#39;) // 鼠标放在托盘图标上的提示信息
  tray.on(&#39;click&#39;, (e) =&gt; &#123;
    if (e.shiftKey) &#123;
      app.quit()
    &#125; else &#123;
      win.show()
    &#125;
  &#125;)
  tray.setContextMenu(
    Menu.buildFromTemplate([
      &#123;
        label: &#39;退出&#39;,
        click: () =&gt; &#123;
          app.quit()
        &#125;
      &#125;
    ])
  )
&#125;
module.exports = createTray
</code></pre>
<p>main.js</p>
<pre><code class="js">require(&#39;../controller/tray.js&#39;)

const createWindow = () =&gt; &#123;
    ...
    createTray(app, win)
&#125;
</code></pre>
<h1 id="基础开发"><a href="#基础开发" class="headerlink" title="基础开发"></a>基础开发</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/api/app">https://www.electronjs.org/zh/docs/latest/api/app</a></p>
<h2 id="点击穿透透明区域"><a href="#点击穿透透明区域" class="headerlink" title="点击穿透透明区域"></a>点击穿透透明区域</h2><p>setIgnoreMouseEvents 可以使窗口忽略窗口内的所有鼠标事件</p>
<p>设置以下参数，只有点击会穿透窗口，鼠标移动则会正常触发</p>
<pre><code class="js">setIgnoreMouseEvents(true, &#123;forward: true&#125;)
</code></pre>
<p>在 App.vue 组件增加 mounted 钩子函数</p>
<pre><code class="js">mounted() &#123;
    const remote = require(&quot;electron&quot;).remote;
    let win = remote.getCurrentWindow();
    window.addEventListener(&quot;mousemove&quot;, event =&gt; &#123;
        // 根元素 html
        let flag = event.target === document.documentElement;
        if(flag) &#123;
            win.setIgnoreMouseEvents(true, &#123;forward: true&#125;);
        &#125; else &#123;
            win.setIgnoreMouseEvents(false);
        &#125;
    &#125;);
    win.setIgnoreMouseEvents(true, &#123; forward: true&#125;);
&#125;
</code></pre>
<p>给 html body 设置</p>
<pre><code class="css">pointer-events: none;
</code></pre>
<p>给 app 设置</p>
<pre><code class="css">pointer-events: auto;
</code></pre>
<h1 id="窗口控制"><a href="#窗口控制" class="headerlink" title="窗口控制"></a>窗口控制</h1><h2 id="阻止窗口关闭"><a href="#阻止窗口关闭" class="headerlink" title="阻止窗口关闭"></a>阻止窗口关闭</h2><pre><code class="js">window.onbeforeunload = function() &#123;
    const remote = require(&quot;electron&quot;).remote;o
    let win = remote.getCurrentWindow();
    win.destroy;
&#125;
</code></pre>
<h2 id="多窗口资源竞争"><a href="#多窗口资源竞争" class="headerlink" title="多窗口资源竞争"></a>多窗口资源竞争</h2><p>使用 Node.js 提供 <code>fs.watch</code>   来监视文件变化</p>
<h2 id="模拟窗口与子窗口"><a href="#模拟窗口与子窗口" class="headerlink" title="模拟窗口与子窗口"></a>模拟窗口与子窗口</h2><p>打开模拟窗口</p>
<pre><code class="js">const remote = require(&quot;electron&quot;).remote;
this.win = new remote.BrowerWindow(&#123;
    parent: remote.getCurrentWindow(),
    // 模态窗口会禁用父窗口
    modal: true,
    webPreferences: &#123;
        nodeIntegration: true
    &#125;
&#125;)
</code></pre>
<h1 id="页面内容"><a href="#页面内容" class="headerlink" title="页面内容"></a>页面内容</h1><h3 id="获取-webContents"><a href="#获取-webContents" class="headerlink" title="获取 webContents"></a>获取 webContents</h3><pre><code class="js">let webContent = win.webContents;
</code></pre>
<h3 id="获取激活状态的实例"><a href="#获取激活状态的实例" class="headerlink" title="获取激活状态的实例"></a>获取激活状态的实例</h3><pre><code class="js">const &#123;webContents&#125; = requitre(&#39;electron&#39;)
let webContent = webContents.getFocusedWebContents();
</code></pre>
<h3 id="获取当前窗口的-webContents"><a href="#获取当前窗口的-webContents" class="headerlink" title="获取当前窗口的 webContents"></a>获取当前窗口的 webContents</h3><pre><code class="js">let webContent = remote.getCurrentWebContents();
</code></pre>
<h3 id="根据-id-获取窗口"><a href="#根据-id-获取窗口" class="headerlink" title="根据 id 获取窗口"></a>根据 id 获取窗口</h3><pre><code class="js">let webContent = webContents.fromId(yourId);
</code></pre>
<h3 id="遍历所有对象"><a href="#遍历所有对象" class="headerlink" title="遍历所有对象"></a>遍历所有对象</h3><pre><code class="js">let webContentArr = webContents.getAllWebContents();
</code></pre>
<h1 id="页面容器"><a href="#页面容器" class="headerlink" title="页面容器"></a>页面容器</h1><h2 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h2><p>可以通过此标签在网页中嵌入另一个网页的内容</p>
<pre><code class="html">&lt;webview id=&quot;id_&quot; src=&quot;xxxxx&quot;&gt;&lt;/webview&gt;
</code></pre>
<p>此标签默认不可用，需要在创建窗口时，设置 webviewTag 属性</p>
<pre><code class="js">webPreference: &#123;
    webviewTag: true
&#125;
</code></pre>
<h2 id="BrowserView"><a href="#BrowserView" class="headerlink" title="BrowserView"></a>BrowserView</h2><p>子窗口的形式，依托于 BrowserWindow 存在，可以绑定在具体区域，像其中的一个元素一样</p>
<pre><code class="js">let view = new BrowserView(&#123;
    webPreferences: &#123;preload&#125;
&#125;);
win.setBrowserView(view);
let size = win.getSize();
view.setBounds(&#123;
    x: 0,
    y: 60,
    width: size[0],
    height: size[1] - 60
&#125;);
view.setAutoResize(&#123;
    width: true,
    height: true
&#125;);
view.webContents.loadURL(url);
</code></pre>
<h1 id="页面动效"><a href="#页面动效" class="headerlink" title="页面动效"></a>页面动效</h1><h2 id="javascript-控制动画"><a href="#javascript-控制动画" class="headerlink" title="javascript 控制动画"></a>javascript 控制动画</h2><p>动画对象可以 pause() play() reverse() onfinish</p>
<pre><code class="js">let keyframe = [&#123;
       transform: &quot;xxx&quot;,
    opacity: 0
&#125;, &#123;
    xxxx
&#125;]
let options = &#123;
    iterations: 1,
    delay: 0,
    duration: 800,
    easing: &quot;ease&quot;
&#125;
let animationObj = document.querySelector(&quot;.xx&quot;).animate(keyframes, options);
</code></pre>
<h2 id="vue3-与-ts-控制"><a href="#vue3-与-ts-控制" class="headerlink" title="vue3 与 ts 控制"></a>vue3 与 ts 控制</h2><pre><code class="tsx">const popBoxShow = ref&lt;boolean&gt;(false)
const popBoxRef = ref&lt;HTMLElement | null&gt;(null)
const popBoxText = ref&lt;string&gt;(&#39;&#39;)

let timer: any

const showPop = (text: string) =&gt; &#123;
  popBoxShow.value = true
  popBoxText.value = text
  if (timer) &#123;  
    clearTimeout(timer)
  &#125;
  timer = setTimeout(() =&gt; &#123;
    const backAnimationEffect = new KeyframeEffect(
      (popBoxRef as any).value, // element to animate
      [
        &#123;
          width: &#39;30%&#39;,
          opacity: &#39;100%&#39;, 
          top: &#39;10%&#39;
        &#125;,
        &#123;
          width: &#39;26%&#39;,
          opacity: &#39;100%&#39;, 
          top: &#39;10%&#39;,
          height: &#39;50px&#39;
        &#125;,
        &#123;
          width: &#39;35%&#39;,
          opacity: &#39;0%&#39;,
          top: &#39;8%&#39;,
          height: &#39;30px&#39;
        &#125;
      ],
      &#123;
        duration: 250
      &#125; // keyframe options
    )
    const backAnimation = new Animation(backAnimationEffect, document.timeline)
    backAnimation.play()
    backAnimation.onfinish = () =&gt; &#123;
      popBoxShow.value = false
    &#125;
  &#125;, 2000)
&#125;

defineExpose(&#123;
  showPop
&#125;)
</code></pre>
<h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h2 id="本地文件持久化存储"><a href="#本地文件持久化存储" class="headerlink" title="本地文件持久化存储"></a>本地文件持久化存储</h2><h3 id="存储在用户数据目录"><a href="#存储在用户数据目录" class="headerlink" title="存储在用户数据目录"></a>存储在用户数据目录</h3><pre><code>win: C:\Users\[your user name]\AppData\Roaming
mac: /Users/[]/Library/Application Support/
Linux: /home/[]/.config/xiangxuema
</code></pre>
<p>可以获取路径</p>
<pre><code class="js">app.getPath(&quot;userData&quot;);
</code></pre>
<h3 id="通过传入参数不同，可以获取不同用途路径"><a href="#通过传入参数不同，可以获取不同用途路径" class="headerlink" title="通过传入参数不同，可以获取不同用途路径"></a>通过传入参数不同，可以获取不同用途路径</h3><p><strong>home destop documents downloads pictures music video</strong></p>
<ul>
<li>temp -&gt; 临时文件夹</li>
<li>exe  -&gt; 当前执行程序的路径</li>
<li>appData -&gt; 用户个性化数据的目录</li>
<li>userData -&gt; 是 appData 加应用名的路径，是子路径</li>
</ul>
<h3 id="Node-js-获取"><a href="#Node-js-获取" class="headerlink" title="Node.js 获取"></a>Node.js 获取</h3><ul>
<li>require(‘os’).homedir()</li>
<li>require(‘os’).tmpdir()</li>
</ul>
<h3 id="设置路径"><a href="#设置路径" class="headerlink" title="设置路径"></a>设置路径</h3><pre><code class="js">app.setPath(&#39;appData&#39;, &#39;D:\\xxx\\xxx&#39;)
</code></pre>
<h2 id="读写本地文件"><a href="#读写本地文件" class="headerlink" title="读写本地文件"></a>读写本地文件</h2><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><pre><code class="js">let fs = require(&quot;fs-extra&quot;)
let path = require(&quot;path&quot;)

let dataPath = app.getPath(&quot;userData&quot;)
dataPath = path.join(dataPath, &quot;test.data&quot;)
fs.writeFileSync(dataPath, yourData, &#123;encoding: &#39;utf8&#39;&#125;)
</code></pre>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><pre><code class="js">let fs = require(&quot;fs-extra&quot;)
let path = require(&quot;path&quot;)

let dataPath = app.getPath(&quot;userData&quot;)
dataPath = path.join(dataPath, &quot;test.data&quot;)
let yourData = fs.readFileSync(dataPath, &#123;encoding: &#39;utf8&#39;&#125;)
</code></pre>
<h2 id="第三方持久化数据"><a href="#第三方持久化数据" class="headerlink" title="第三方持久化数据"></a>第三方持久化数据</h2><h3 id="lowdb"><a href="#lowdb" class="headerlink" title="lowdb"></a>lowdb</h3><p>基于 Lodash 的小巧 JSON 数据库</p>
<pre><code class="js">// 创建数据库访问对象
const low = require(&#39;lowdb&#39;)
const FileSync = require(&#39;lowdb/adapters/FileSync&#39;)

const adapter = new FileSync(&#39;db.json&#39;)
const db = low(adapter)
// 查找数据
db.get(&#39;posts&#39;).find(&#123;id: 1&#125;).value();
// 更新数据
db.get(&#39;posts&#39;).find(&#123;title: &#39;low&#39;&#125;).assign(&#123;
    title: &#39;hi&#39;
&#125;).write();
// 删除数据
db.get(&#39;posts&#39;).remove(&#123;
    title: &#39;low&#39;
&#125;).write();
// 排序数据
db.get(&#39;posts&#39;).filter(&#123;
    published: true
&#125;).sortBy(&#39;views&#39;).take(5).value();
</code></pre>
<h3 id="electron-store"><a href="#electron-store" class="headerlink" title="electron-store"></a>electron-store</h3><pre><code class="js">const Store = require(&#39;electron-store&#39;)
const store = new Store()

store.set(&#39;key&#39;, &#39;value&#39;)
store.get(&#39;key&#39;)
</code></pre>
<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><h2 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h2><h3 id="文件对话框"><a href="#文件对话框" class="headerlink" title="文件对话框"></a>文件对话框</h3><pre><code class="js">const &#123;dialog, app&#125; = require(&quot;electron&quot;).remote

let filePath = await  dialog.showOpenDialog(&#123;
    title: &quot;选择一个文件&quot;,
    buttonLabel: &quot;打开文件&quot;,
    defaultPath: app.getPath(&#39;pictures&#39;),
    // 多选文件
    properties: &quot;multiSelections&quot;,
    filters: [
        // 文件类型
        &#123;name: &quot;图片&quot;, extensions: [&quot;jpg&quot;, &quot;png&quot;, &quot;gif&quot;]&#125;,
        &#123;name: &quot;视频&quot;, extensions: [&quot;xxx&quot;, &quot;xxx&quot;, &quot;xxx&quot;]&#125;,
    ]
&#125;)
// 拿到文件可以进行读写操作
</code></pre>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><h3 id="窗口菜单"><a href="#窗口菜单" class="headerlink" title="窗口菜单"></a>窗口菜单</h3><h4 id="可以设置属性隐藏"><a href="#可以设置属性隐藏" class="headerlink" title="可以设置属性隐藏"></a>可以设置属性隐藏</h4><pre><code class="js">let win = new BrowserWindow(&#123;
    webPreferences: &#123;nodeIntergration: true&#125;,
    // 隐藏系统菜单
    autoHideMenuBar: true
&#125;)
</code></pre>
<h4 id="自定义菜单，覆盖自带"><a href="#自定义菜单，覆盖自带" class="headerlink" title="自定义菜单，覆盖自带"></a>自定义菜单，覆盖自带</h4><pre><code class="js">let Menu = require(&#39;electron&#39;).Menu

let templateArr = [&#123;
    label: &#39;菜单 1&#39;,
    submenu: [&#123;label: &quot;菜单 1 - 1&quot;&#125;]
&#125;,&#123;
    label: &#39;菜单 1&#39;,
    submenu: [&#123;label: &quot;菜单 1 - 1&quot;&#125;]
&#125;]
let menu = Menu.buildFromTemplate(templateArr)
Menu.setApplactionMenu(menu)
</code></pre>
<h3 id="自定义右键菜单"><a href="#自定义右键菜单" class="headerlink" title="自定义右键菜单"></a>自定义右键菜单</h3><p>写完 html 与 css 之后用 js 关联响应</p>
<pre><code class="js">window.oncontextmenu = function(e) &#123;
    e.preventDefault()
    const menu = document.querySelector(&quot;#xxx&quot;)
    menu.style.left = e.clientX + &#39;px&#39;
    menu.style.top = e.clientY + &#39;px&#39;
    menu.style.display = &#39;block&#39;
&#125;
window.onclick = function(e) &#123;
    document.querySelector(&#39;#xxx&#39;).style.display = &#39;none&#39;
&#125;
</code></pre>
<h3 id="系统右键菜单"><a href="#系统右键菜单" class="headerlink" title="系统右键菜单"></a>系统右键菜单</h3><pre><code class="js">let &#123;Menu&#125; = require(&#39;electron&#39;).remote

let menu = Menu.buildFromTemplate([
    &#123;
        label: &quot;&quot;,
        click() &#123;
            console.log(&quot;xxx&quot;)
        &#125;
    &#125;
])
window.oncontextmenu = function(e) &#123;
    e.preventDefault()
    menu.popup()
&#125;
</code></pre>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="监听快捷键"><a href="#监听快捷键" class="headerlink" title="监听快捷键"></a>监听快捷键</h3><pre><code class="js">window.onkeydown = function() &#123;
    if((event.ctrlKey || event.metakey) &amp;&amp; xxxxx))
&#125;
</code></pre>
<h3 id="监听全局按键事件"><a href="#监听全局按键事件" class="headerlink" title="监听全局按键事件"></a>监听全局按键事件</h3><p>在非激活状态下也能监听到用户按键</p>
<pre><code class="js">const &#123;globalShortcut&#125; = require(&#39;electron&#39;)
globalShortcut.register(&#39;CommandOrControl+K&#39;, () =&gt; &#123;
    console.log(&quot;按键监听&quot;)
&#125;)

// 取消注册快捷键
globalShortcut.unregister
</code></pre>
<h2 id="托盘图标"><a href="#托盘图标" class="headerlink" title="托盘图标"></a>托盘图标</h2><h3 id="托盘图标闪烁"><a href="#托盘图标闪烁" class="headerlink" title="托盘图标闪烁"></a>托盘图标闪烁</h3><p>设置托盘</p>
<pre><code class="js">let &#123;app, BrowserWindow, Tray&#125; = require(&#39;electron&#39;)
let path = require(&#39;path&#39;)

let tray
app.on(&#39;ready&#39;, () =&gt; &#123;
    let iconPath = path.join(__dirname, &#39;icon.png&#39;)
    tray = new Tray(iconPath)
&#125;)
</code></pre>
<p>托盘闪烁</p>
<pre><code class="js">let iconPath2 = path.join(__dirname, &#39;icon2.png&#39;)
let flag = true
setInterval(() =&gt; &#123;
    if(flag) &#123;
        tray.setImage(iconPath2)
        flag = false
    &#125; else &#123;
        tray.setImage(iconPath)
        flag = true
    &#125;
&#125;,600)
</code></pre>
<h3 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h3><pre><code class="js">// double-click right-click
tray.on(&#39;click&#39;, () =&gt; &#123;
    win.show()
&#125;)
</code></pre>
<h3 id="托盘注册菜单"><a href="#托盘注册菜单" class="headerlink" title="托盘注册菜单"></a>托盘注册菜单</h3><pre><code class="js">let &#123;Tray, Menu&#125; = require(&#39;electron&#39;)
let menu = Menu.buildFromTemplate([
    &#123;
        click() &#123;
            win.show()
        &#125;,
        label: &#39;显示窗口&#39;,
        type: &#39;normal&#39;
    &#125;,
    &#123;
        click() &#123;
            app.quit()
        &#125;,
        label: &#39;退出应用&#39;,
        type: &#39;normal&#39;
    &#125;
&#125;])
tray.setContextMenu(menu)
</code></pre>
<h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><h3 id="剪切板写入文本和-HTML"><a href="#剪切板写入文本和-HTML" class="headerlink" title="剪切板写入文本和 HTML"></a>剪切板写入文本和 HTML</h3><pre><code class="js">let &#123;clipboard&#125; = require(&quot;electron&quot;)

clipboard.writeText(&quot;你好&quot;)
clipboard.writeHTML(&quot;&lt;h1&gt;你好&lt;/h1&gt;&quot;)
</code></pre>
<h3 id="图片写入剪切板"><a href="#图片写入剪切板" class="headerlink" title="图片写入剪切板"></a>图片写入剪切板</h3><pre><code class="js">let path = require(&quot;path&quot;)
let &#123;clipboard, nativeImage&#125; = require(&quot;electron&quot;)

let imgPath = path.join(__static, &quot;icon.png&quot;)
let img = nativeImage.createFromPath(imgPath)
clipboard.writeImage(img)
</code></pre>
<h3 id="清除剪切板的数据"><a href="#清除剪切板的数据" class="headerlink" title="清除剪切板的数据"></a>清除剪切板的数据</h3><pre><code class="js">clipboard.clear()
</code></pre>
<h3 id="剪切板读取文本和-HTML"><a href="#剪切板读取文本和-HTML" class="headerlink" title="剪切板读取文本和 HTML"></a>剪切板读取文本和 HTML</h3><pre><code class="js">clipboard.readText()
clipboard.readHTML()
</code></pre>
<h3 id="读取显示剪切板的图片"><a href="#读取显示剪切板的图片" class="headerlink" title="读取显示剪切板的图片"></a>读取显示剪切板的图片</h3><pre><code class="js">let img = clipboard.readImage()
let dataUrl = img.toDataURL()
let imgDom = document.createElement(&#39;img&#39;)
imgDom.src = dataUrl
document.body.appendChild(imgDom)
</code></pre>
<h3 id="剪切板如果是文件"><a href="#剪切板如果是文件" class="headerlink" title="剪切板如果是文件"></a>剪切板如果是文件</h3><p>可以获取文件路径</p>
<pre><code class="js">// win
let filePath = clipboard.readBuffer(&#39;FileNameW&#39;).toString(&#39;ucs2&#39;)
filePath = filePath.replace(RegExp(String.fromCharCode(0), &#39;g&#39;), &#39;&#39;)
// mac
var filePath = clipboard.read(&#39;public.file-url&#39;).replace(&#39;file://&#39;, &#39;&#39;)
</code></pre>
<p>或者借助 <code>clipboard-files</code>  Node.js 模块</p>
<pre><code class="js">const clipboard = require(&#39;clipboard-files&#39;)
let fileNames = clipboard.readFiles()
</code></pre>
<h2 id="系统通知"><a href="#系统通知" class="headerlink" title="系统通知"></a>系统通知</h2><h3 id="HTML-API-发送系统通知"><a href="#HTML-API-发送系统通知" class="headerlink" title="HTML API 发送系统通知"></a>HTML API 发送系统通知</h3><p>首先需要获取用户授权，在渲染进程中可以不需要授权，直接创建实例</p>
<pre><code class="js">Notification.requestPermission(function(status) &#123;
    if(status === &quot;granted&quot;) &#123;
        let notification = new Notification(&#39;新的信息&#39;, &#123;
            body: &#39;消息内容&#39;
        &#125;)
    &#125; else &#123;
        // 拒绝授权
    &#125;
&#125;)
</code></pre>
<p>如果点击通知就会触发</p>
<pre><code class="js">notification.onclick = function() &#123;
    console.log(&#39;xxx&#39;)
&#125;
</code></pre>
<h3 id="主进程发送系统通知"><a href="#主进程发送系统通知" class="headerlink" title="主进程发送系统通知"></a>主进程发送系统通知</h3><p>可以多次调用显示同样通知，click 事件不能用 onclick 注册</p>
<pre><code class="js">const &#123;Notification&#125; = require(&quot;electron&quot;).remote

let notification = new Notification(&#123;
    title: &quot;消息&quot;,
       body: &quot;消息正文&quot;
&#125;)
notification.show()
notification.on(&quot;click&quot;, () =&gt; &#123;
    console.log(&quot;点击了消息&quot;)
&#125;)
</code></pre>
<h2 id="使用默认应用打开文件"><a href="#使用默认应用打开文件" class="headerlink" title="使用默认应用打开文件"></a>使用默认应用打开文件</h2><pre><code class="js">const &#123;shell&#125; = require(&quot;electron&quot;)

// 打开 URL 链接
shell.openExternal(&quot;http://xxx&quot;)
</code></pre>
<h3 id="word-文档或其他系统注册默认程序的文件"><a href="#word-文档或其他系统注册默认程序的文件" class="headerlink" title="word 文档或其他系统注册默认程序的文件"></a>word 文档或其他系统注册默认程序的文件</h3><p>是一个同步方法，可能会阻塞执行</p>
<pre><code class="js">let openFlag = shell.openItem(&quot;D:\\xxx\\xxx.docx&quot;)
</code></pre>
<h3 id="把文件移入垃圾箱"><a href="#把文件移入垃圾箱" class="headerlink" title="把文件移入垃圾箱"></a>把文件移入垃圾箱</h3><pre><code class="js">let delFlag = shell.moveItemToTrash(&quot;D:\\xx\\&quot;)
</code></pre>
<h2 id="接受拖拽到窗口的文件"><a href="#接受拖拽到窗口的文件" class="headerlink" title="接受拖拽到窗口的文件"></a>接受拖拽到窗口的文件</h2><h3 id="HTML5-API"><a href="#HTML5-API" class="headerlink" title="HTML5 API"></a>HTML5 API</h3><pre><code class="js">document.addEventListener(&#39;dragover&#39;, ev =&gt; &#123;
    // 保证 drop 事件正确触发
    ev.preventDefault()
&#125;)
document.addEventListener(&#39;drop&#39;, ev =&gt; &#123;
    // File 数组
    console.log(ev.dataTransfer.files)
    ev.preventDefault()
&#125;)
</code></pre>
<h4 id="读取拖拽的文件"><a href="#读取拖拽的文件" class="headerlink" title="读取拖拽的文件"></a>读取拖拽的文件</h4><pre><code class="js">let fr = new FileReader()
fr.onload = () =&gt; &#123;
    var buffer = new Buffer.from(fr.result)
    fs.writeFile(newFilePath, buffer, err =&gt; &#123;
        // 保存
    &#125;)
&#125;
fr.readAsArrayBuffer(fileObj)
// fr.readAsText() -&gt; 文本方式
// fr.readAsDataURL() -&gt; base64
// fr.readAsBinaryString() -&gt; 二进制
</code></pre>
<h2 id="最近打开的文件"><a href="#最近打开的文件" class="headerlink" title="最近打开的文件"></a>最近打开的文件</h2><h3 id="API-实现功能"><a href="#API-实现功能" class="headerlink" title="API 实现功能"></a>API 实现功能</h3><pre><code class="js">app.addRecentDocument(&#39;C:\XXX\XXX&#39;)
</code></pre>
<h3 id="清空最近打开的文件列表"><a href="#清空最近打开的文件列表" class="headerlink" title="清空最近打开的文件列表"></a>清空最近打开的文件列表</h3><pre><code class="js">app.clearRecentDocuments();
</code></pre>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="与-Web-服务器通信"><a href="#与-Web-服务器通信" class="headerlink" title="与 Web 服务器通信"></a>与 Web 服务器通信</h2><h3 id="禁用同源实现跨域"><a href="#禁用同源实现跨域" class="headerlink" title="禁用同源实现跨域"></a>禁用同源实现跨域</h3><p>Node.js 访问</p>
<pre><code class="js">let https = require(&quot;https&quot;)

let url = &quot;https://xxxxx&quot;
https.get(url, res =&gt; &#123;
    let html = &quot;&quot;
    res.on(&quot;data&quot;, data =&gt; (html += data))
    res.on(&quot;end&quot;, () =&gt; console.log(html))
&#125;)
</code></pre>
<h4 id="渲染层访问需要禁用同源"><a href="#渲染层访问需要禁用同源" class="headerlink" title="渲染层访问需要禁用同源"></a>渲染层访问需要禁用同源</h4><pre><code class="js">webSecurity: false
</code></pre>
<h2 id="使用-WebSocket-通信"><a href="#使用-WebSocket-通信" class="headerlink" title="使用 WebSocket 通信"></a>使用 WebSocket 通信</h2><h3 id="webSocket-客户端"><a href="#webSocket-客户端" class="headerlink" title="webSocket 客户端"></a>webSocket 客户端</h3><pre><code class="js">let websocket = new WebSocket(&quot;ws://localhost:8000/&quot;)
// 打开时触发
websocket.onopen = function(evt) 
// 关闭时触发
websocket.onclose
// 收到消息
websocket.onmessage
// 产生异常
websocket.onerror
// 发送数据
websocket.send(&quot;xxxx&quot;)
// 关闭连接
websocket.close()
</code></pre>
<h2 id="与系统其他应用通信"><a href="#与系统其他应用通信" class="headerlink" title="与系统其他应用通信"></a>与系统其他应用通信</h2><h3 id="Electron-应用与其他应用通信"><a href="#Electron-应用与其他应用通信" class="headerlink" title="Electron 应用与其他应用通信"></a>Electron 应用与其他应用通信</h3><p>IPC 命名管道技术，包含服务端和客户端，可以持久连接双向通信</p>
<p>如果有第三方程序需要发送数据，可以在 Electron 创建命名管道服务端接收数据</p>
<pre><code class="js">let net = require(&#39;net&#39;)
let PIPE_PATH = &quot;\\\\.\\ pipe\\ mypipe&quot;
let server = net.createServer(function(conn) &#123;
    conn.on(&#39;data&#39;, d =&gt; console.log(`接收到数据: $&#123;d.toString()&#125;`))
    conn.on(&#39;end&#39;, () =&gt; console.log(&quot;客户端已关闭连接&quot;))
    conn.write(&#39;建立连接后，发送信息&#39;)
&#125;)
server.on(&#39;close&#39;, () =&gt; console.log(&#39;服务关闭&#39;))
server.listen(PIPE_PATH, () =&gt; console.log(&quot;服务启动，正在监听&quot;))
</code></pre>
<p>客户端</p>
<pre><code class="js">let net = require(&#39;net&#39;)
let PIPE_PATH = &quot;\\\\.\\ pipe\\ mypipe&quot;
let client = net.connect(PIPE_PATH, () =&gt; &#123;
    console.log(&quot;连接成功&quot;)
    client.write(&quot;第一个数据包&quot;)
&#125;)
client.on(&quot;data&quot;, d =&gt; &#123;
    console.log(&quot;接收数据 -&gt; &quot;, d)
    client.end(&quot;最后的消息，发完就关闭&quot;)
&#125;)
client.on(&quot;end&quot;, () =&gt; console.log(&quot;服务端关闭了连接&quot;))
</code></pre>
<h2 id="网页与-Electron-通信"><a href="#网页与-Electron-通信" class="headerlink" title="网页与 Electron 通信"></a>网页与 Electron 通信</h2><h3 id="建立-Web-服务器"><a href="#建立-Web-服务器" class="headerlink" title="建立 Web 服务器"></a>建立 Web 服务器</h3><pre><code class="js">var http = require(&#39;http&#39;)

let server = http.createServer((request, reponse) =&gt; &#123;
    if(request.url == &quot;/electron&quot;) &#123;
        let jsonString = &#39;&#39;
        request.on(&#39;data&#39;, data =&gt; jsonString += data)
        request.on(&#39;end&#39;, () =&gt; &#123;
            let post = JSON.parse(jsonString)
            // 业务逻辑
            response.writeHead(200, &#123;
                &quot;Content-Type&quot;: &quot;text/html&quot;,
                &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;
            &#125;)
            let result = JSON.stringify(&#123;
                &quot;ok&quot;: true,
                &quot;msg&quot;: &quot;请求成功&quot;
            &#125;)
            reponse.end(result)
        &#125;)
        return 
    &#125;
&#125;)
server.on(&quot;error&quot;, err =&gt; &#123;
    // 可以发给渲染进程
&#125;)
server.listen(9416)


// 如果设置 listen(0)，需要获取具体监听的端口
server.on(&#39;listening&#39;, () =&gt; &#123;
    console.log(server.address().port)
&#125;)
</code></pre>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><p>Electron 可以自由使用操作硬件设备的能力，且默认有硬件的访问权限</p>
<h2 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h2><h3 id="获取扩展屏幕"><a href="#获取扩展屏幕" class="headerlink" title="获取扩展屏幕"></a>获取扩展屏幕</h3><p>获取主显示信息</p>
<pre><code class="js">let remote = require(&quot;electron&quot;).remote

let mainScreen = remote.screen.getPrimaryDisplay()
console.log(mainScreen)
</code></pre>
<p>控制窗口显示在外接显示器上</p>
<pre><code class="js">let &#123;screen&#125; require(&#39;electron&#39;)

let displays = screen.getAllDisplays()
let externalDisplay = displays.find(display =&gt; &#123;
    // 判断是否为外接屏幕
    return display.bounds.x !== 0 || diplay.bounds.y !== 0
&#125;)
if(externalDisplay) )&#123;
    win = new BrowserWindow(&#123;
        x: externalDisplay.bounds.x + 50,
        y: externalDisplay.bounds.y + 50,
        webPreferences: &#123;
            nodeIntegration: true
        &#125;
    &#125;)
    win.loadURL(&#39;https://xx&#39;)
&#125;
</code></pre>
<h3 id="打开系统软件盘"><a href="#打开系统软件盘" class="headerlink" title="打开系统软件盘"></a>打开系统软件盘</h3><pre><code class="js">const exec = require(&quot;child_process&quot;).exec
exec(&quot;osk.exe&quot;)
</code></pre>
<h2 id="音视频设置"><a href="#音视频设置" class="headerlink" title="音视频设置"></a>音视频设置</h2><h3 id="摄像头和麦克风"><a href="#摄像头和麦克风" class="headerlink" title="摄像头和麦克风"></a>摄像头和麦克风</h3><pre><code class="js">let option = &#123;
    audio: true,
    video: true
&#125;
let mediaStream = await navigator.mediaDevices.getUserMedia(option)
let viode = document.querySelector(&quot;video&quot;)
video.srcObject = mediaStream
video.onloadedmetadata = function(e) &#123;
    video.play()
&#125;
</code></pre>
<h3 id="可以对摄像头进行设置"><a href="#可以对摄像头进行设置" class="headerlink" title="可以对摄像头进行设置"></a>可以对摄像头进行设置</h3><pre><code class="js">// 设置视频的大小
video: &#123;widht: xxx, height: xxx&#125;
// 取设备前置摄像头
video: &#123;facingMode: &quot;user&quot;&#125;
// 后置摄像头
video: &#123;facingMode: &quot;environment&quot;&#125;
</code></pre>
<h3 id="所有摄像头的基本信息"><a href="#所有摄像头的基本信息" class="headerlink" title="所有摄像头的基本信息"></a>所有摄像头的基本信息</h3><p>获取数组中包含视频和音频设备信息</p>
<pre><code class="js">let devices = await navigator.mediaDevices.enumerateDevices()
</code></pre>
<h3 id="指定设备"><a href="#指定设备" class="headerlink" title="指定设备"></a>指定设备</h3><p>此方法如果配置的设备不可用，将会随机返回可用设备</p>
<pre><code class="js">video: &#123;deviceId: myPreferencedCameraDeviceId&#125;
</code></pre>
<p>可以指定，不可用则会抛出异常</p>
<pre><code class="js">video: &#123;deviceId: &#123;exect: myPreferencedCameraDeviceId&#125; &#125;
</code></pre>
<h2 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h2><h3 id="获取桌面应用的屏幕视频流"><a href="#获取桌面应用的屏幕视频流" class="headerlink" title="获取桌面应用的屏幕视频流"></a>获取桌面应用的屏幕视频流</h3><pre><code class="js">const &#123;desktopCapturer&#125; = require(&quot;electron&quot;)

let sources = await desktopCapturer.getSources(&#123;
    types: [&quot;window&quot;, &quot;screen&quot;]
&#125;)
let target = sources.find(v =&gt; v.name == &quot;微信&quot;)
let mediaStream = await navigator.mediaDevices.getUserMedia(&#123;
    audio: false,
    video: &#123;
        mandatory: &#123;
            chromeMediaSource: &quot;desktop&quot;,
            chromeMediaSourceId: target.id
        &#125;
    &#125;
&#125;)
var video = document.querySelector(&quot;video&quot;)
video.srcObject = mediaStream
video.onloadedmetadata = function(e) &#123;
    video.play()
&#125;
</code></pre>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><h3 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h3><ul>
<li><strong>charging</strong> -&gt; 正在充电时值为 true</li>
<li><strong>chargingTime</strong> -&gt; 距离电池充满还剩多少时间，如果是 0 则表示充满</li>
<li><strong>dischargingTime</strong> -&gt; 电池用完时间</li>
<li><strong>level</strong> -&gt; 充电水平</li>
</ul>
<pre><code class="js">let batteryManager = await navigator.getBattery()
</code></pre>
<h3 id="可控事件"><a href="#可控事件" class="headerlink" title="可控事件"></a>可控事件</h3><ul>
<li><strong>onchargingchange</strong></li>
<li><strong>onchargingtimechanged</strong></li>
<li><strong>ondischargingtimechanged</strong></li>
<li><strong>onlevelchange</strong></li>
</ul>
<h2 id="监控系统挂起与锁屏事件"><a href="#监控系统挂起与锁屏事件" class="headerlink" title="监控系统挂起与锁屏事件"></a>监控系统挂起与锁屏事件</h2><pre><code class="js">const &#123;powerMonitor&#125; = require(&quot;electron&quot;).remote

powerMonitor.on(&quot;suspend&quot;, () =&gt; &#123;
    console.log(&quot;sys is going to sleep&quot;)
&#125;)
powerMonitor.on(&quot;resume&quot;, () =&gt; &#123;
    console.log(&quot;sys is going to wakeup&quot;)
&#125;)
</code></pre>
<h3 id="锁屏与解锁"><a href="#锁屏与解锁" class="headerlink" title="锁屏与解锁"></a>锁屏与解锁</h3><pre><code class="js">powerMonitor.on(&quot;lock-screen&quot;, () =&gt; &#123;
    console.log(&quot;sys is lock screen&quot;)
&#125;)
powerMonitor.on(&quot;unlock-screen&quot;, () =&gt; &#123;
    console.log(&quot;sys is unlock screen&quot;)
&#125;)
</code></pre>
<h3 id="阻止系统锁屏"><a href="#阻止系统锁屏" class="headerlink" title="阻止系统锁屏"></a>阻止系统锁屏</h3><pre><code class="js">const &#123;powerSaveBlocker&#125; = require(&quot;electron&quot;)

// 阻止锁屏
cosnt id = powerSaveBlocker.start(&quot;prevent-display-sleep&quot;)

// 取消阻止
powerSaveBlocker.stop(id)

// 判断是否阻止
powerSaveBlocker.isStarted(id)
</code></pre>
<h2 id="导出-PDF"><a href="#导出-PDF" class="headerlink" title="导出 PDF"></a>导出 PDF</h2><h3 id="导出页面内容"><a href="#导出页面内容" class="headerlink" title="导出页面内容"></a>导出页面内容</h3><pre><code class="js">let &#123;remote&#125; = require(&quot;electron&quot;)
let path = require(&quot;path&quot;)

let webContents = remote.getCurrentWebContents()
let data = await webContents.printToPDF(&#123;&#125;)
let filePath = path.join(__static, &quot;xxx.pdf&quot;)
fs.writeFile(filePath, data, err =&gt; &#123;
    id(err) throw err
    console.log(&quot;保存成功&quot;)
&#125;)
</code></pre>
<h3 id="可以打开文件存储对话框"><a href="#可以打开文件存储对话框" class="headerlink" title="可以打开文件存储对话框"></a>可以打开文件存储对话框</h3><pre><code class="js">let pathObj = await remote.dialog.showSaveDialog(&#123;
    title: &quot;保存 PDF&quot;,
    filters: [&#123;name: &quot;pdf&quot;, extensions: [&quot;pdf&quot;]&#125;]
&#125;)
if(pathObj.cancled) return 
fs.writeFile(pathObj.filePath, data, err =&gt; &#123;
    if(err) throw err
    console.log(&quot;保存成功&quot;)
&#125;)
</code></pre>
<h2 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h2><h3 id="获取目标平台硬件信息"><a href="#获取目标平台硬件信息" class="headerlink" title="获取目标平台硬件信息"></a>获取目标平台硬件信息</h3><h4 id="Electron-API"><a href="#Electron-API" class="headerlink" title="Electron  API"></a>Electron  API</h4><pre><code class="js">// 内存使用量
let memoryUseage = process.getSystemMemoryInfo()

// CPU 使用情况
let cpuUseage = process.getCPUUseage()

// 每次调用是取本次与上次的评价值，所以用定时器读取
setInterval(() =&gt; &#123;
    cpuUseage = process.getCPUUseage()
    console.log(cpuUseage)
&#125;)
</code></pre>
<h3 id="systeminformation-包"><a href="#systeminformation-包" class="headerlink" title="systeminformation 包"></a>systeminformation 包</h3><pre><code class="js">let si = require(&#39;systeminformation&#39;)
(async function() &#123;
    // cpu 信息
    let cpuInfo = await si.cpu()
    // 内存信息
    let memInfo = await si.mem()
    // 网卡信息
    let networkInterfaces = await si.networkInterfaces()
    // 获取磁盘信息
    let diskLayout = await si.diskLayout()
&#125;)
</code></pre>
<h1 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h1><h2 id="生成图标"><a href="#生成图标" class="headerlink" title="生成图标"></a>生成图标</h2><h3 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h3><pre><code class="shell">pnpm i electron-icon-builder --dev
</code></pre>
<h3 id="在-package-json-中配置"><a href="#在-package-json-中配置" class="headerlink" title="在 package.json 中配置"></a>在 package.json 中配置</h3><pre><code class="json">&quot;build-icon&quot;: &quot;electron-icon-builder --input=./public/icon.png --output=build --flatten&quot;
</code></pre>
<h1 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h1><h2 id="窗口记录"><a href="#窗口记录" class="headerlink" title="窗口记录"></a>窗口记录</h2><pre><code class="js">setState() &#123;
    let win = remote.getCurrentWindow();
    // 返回 Rectangle 对象，包含窗口在屏幕上的坐标和大小
    let rect = win.getBounds();
    let isMaxsize = win.isMaximized();
&#125;
</code></pre>
<h1 id="electron打包"><a href="#electron打包" class="headerlink" title="electron打包"></a>electron打包</h1><p>安装electron打包开发依赖</p>
<blockquote>
<p>最新版本：npm install –save-dev electron-builder</p>
<p>指定版本：npm install –save-dev <a href="mailto:&#x65;&#108;&#101;&#x63;&#116;&#x72;&#111;&#x6e;&#45;&#98;&#x75;&#x69;&#x6c;&#x64;&#101;&#114;&#64;&#x32;&#x33;&#46;&#54;&#x2e;&#x30;">&#x65;&#108;&#101;&#x63;&#116;&#x72;&#111;&#x6e;&#45;&#98;&#x75;&#x69;&#x6c;&#x64;&#101;&#114;&#64;&#x32;&#x33;&#46;&#54;&#x2e;&#x30;</a></p>
</blockquote>
<h3 id="package-json-中配置"><a href="#package-json-中配置" class="headerlink" title="package.json 中配置"></a>package.json 中配置</h3><pre><code class="json">&quot;build&quot;: &#123;
    &quot;appId&quot;: &quot;com.xxxxx.xxxx&quot;,//包名  
    &quot;productName&quot;: &quot;xxxxxx&quot;, //项目名 这也是生成的exe文件的前缀名
    &quot;asar&quot;: false,
    &quot;copyright&quot;: &quot;Copyright © 2022 electron&quot;,//版权  信息
    &quot;publish&quot;: &#123;
      &quot;provider&quot;: &quot;github&quot;,// 服务器提供商 也可以是GitHub等等
      &quot;url&quot;: &quot;&quot;// 服务器地址
      &quot;owner&quot;: &quot;iLx11&quot;,
      &quot;repo&quot;: &quot;screen-go&quot;
    &#125;,
    &quot;directories&quot;: &#123; // 输出文件夹
      &quot;output&quot;: &quot;dist_electron/&quot;
    &#125;,
    &quot;extraResources&quot;: [
      &#123;
        &quot;from&quot;: &quot;./public&quot;,
        &quot;to&quot;: &quot;./public&quot;
      &#125;
    ],
    &quot;files&quot;: [ // 打包的electron需要包含的文件,一般就是与electron的有关的打包进去
      &quot;./dist&quot;, // vue 打包文件
      &quot;./electron&quot; // electron 主文件
    ],
    &quot;mac&quot;: &#123;
      &quot;artifactName&quot;: &quot;$&#123;productName&#125;_$&#123;version&#125;.$&#123;ext&#125;&quot;,
      &quot;target&quot;: [
        &quot;dmg&quot;
      ]
    &#125;,
    &quot;win&quot;: &#123;
      &quot;icon&quot;: &quot;public/favicon.ico&quot;,
      &quot;target&quot;: [
        &#123;
          &quot;target&quot;: &quot;nsis&quot;,
          &quot;arch&quot;: [
            &quot;ia32&quot;
          ]
        &#125;
      ],
      &quot;artifactName&quot;: &quot;$&#123;productName&#125;_$&#123;version&#125;.$&#123;ext&#125;&quot;
    &#125;,
    &quot;nsis&quot;: &#123;
      &quot;oneClick&quot;: false,// 是否一键安装
      &quot;perMachine&quot;: false,
      &quot;allowToChangeInstallationDirectory&quot;: true,// 允许修改安装目录
      &quot;deleteAppDataOnUninstall&quot;: false,
      &quot;installerIcon&quot;: &quot;public/favicon.ico&quot;,// 安装图标
      &quot;uninstallerIcon&quot;: &quot;public/favicon.ico&quot;,// 创建桌面图标
      &quot;createDesktopShortcut&quot;: true,// 创建桌面图标
      &quot;createStartMenuShortcut&quot;: true,// 创建开始菜单图标
      &quot;shortcutName&quot;: &quot;xxxxx&quot; // 图标名称
    &#125;,
    &quot;releaseInfo&quot;: &#123;
      &quot;releaseNotes&quot;: &quot;版本更新的具体内容&quot;
    &#125;
  &#125;
</code></pre>
<h3 id="执行打包"><a href="#执行打包" class="headerlink" title="执行打包"></a>执行打包</h3><pre><code class="shell">pnpm electron:build / npm run electron:build
</code></pre>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43239880/article/details/129563632?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_43239880/article/details/129563632?spm=1001.2014.3001.5501</a></p>
<p><a target="_blank" rel="noopener" href="https://www.electronjs.org/zh/docs/latest/tutorial/ipc">https://www.electronjs.org/zh/docs/latest/tutorial/ipc</a></p>
<ol>
<li>主进程向渲染进程通讯</li>
</ol>
<ul>
<li>主进程使用 <code>win.webContents.send</code> 发送消息</li>
<li>渲染进程使用 <code>ipcRenderer.on</code> 接收消息</li>
</ul>
<ol start="2">
<li>渲染进程向主进程通信</li>
</ol>
<ul>
<li><ul>
<li>渲染进程使用 <code>ipcRenderer.send</code> 或者 <code>ipcRenderer.invoke</code> 发送消息</li>
<li>主进程使用 <code>ipcMain.on</code>或者<code>ipcMain.handle</code> 接收消息</li>
</ul>
</li>
</ul>
<h1 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h1><h4 id="electron-打包-桌面端框架Electron使用问题整理和总结"><a href="#electron-打包-桌面端框架Electron使用问题整理和总结" class="headerlink" title="electron 打包_桌面端框架Electron使用问题整理和总结"></a>electron 打包_桌面端框架Electron使用问题整理和总结</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39607450/article/details/110647391">https://blog.csdn.net/weixin_39607450/article/details/110647391</a></p>
<p>-</p>
<h4 id="vue3-vite-assets动态引入图片的三种方法及解决打包后图片路径错误不显示的问题"><a href="#vue3-vite-assets动态引入图片的三种方法及解决打包后图片路径错误不显示的问题" class="headerlink" title="vue3+vite assets动态引入图片的三种方法及解决打包后图片路径错误不显示的问题"></a>vue3+vite assets动态引入图片的三种方法及解决打包后图片路径错误不显示的问题</h4><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/278408.htm">https://www.jb51.net/article/278408.htm</a></p>
<p>content:</p>
<p>vite官方文档的解释：<a target="_blank" rel="noopener" href="https://vitejs.bootcss.com/guide/assets.html">https://vitejs.bootcss.com/guide/assets.html</a> </p>
<p>我们看到实际上我们不希望资源文件被webpack编译<strong>可以把图片放到public 目录会更省事，不管是开发环境还是生产环境，可以始终以根目录保持图片路径的一致</strong>，这点跟webpack是一致的</p>
<h5 id="第一种方式（适用于处理单个链接的资源文件）"><a href="#第一种方式（适用于处理单个链接的资源文件）" class="headerlink" title="第一种方式（适用于处理单个链接的资源文件）"></a>第一种方式（适用于处理单个链接的资源文件）</h5><pre><code class="js">import homeIcon from &#39;@/assets/images/home/home_icon.png&#39;
&lt;img :src=&quot;homeIcon&quot;/&gt;
</code></pre>
<h5 id="第二种方式（适用于处理多个链接的资源文件）"><a href="#第二种方式（适用于处理多个链接的资源文件）" class="headerlink" title="第二种方式（适用于处理多个链接的资源文件）"></a>第二种方式（适用于处理多个链接的资源文件）</h5><p><strong>推荐，这种方式传入的变量可以动态传入文件路径！！</strong></p>
<p><a href="https://links.jianshu.com/go?to=https://link.zhihu.com/?target=https://cn.vitejs.dev/guide/assets.html%23new-url-url-import-meta-url">静态资源处理 | Vite 官方中文文档</a><br>new URL() + import.meta.url</p>
<p><strong>这里我们假设：</strong><br>工具文件目录： <code>src/util/pub-use.ts</code><br>pub-use.ts</p>
<pre><code>// 获取assets静态资源export defaultconst getAssetsFile = (url: string) =&gt; &#123;  returnnewURL(`../assets/images/$&#123;url&#125;`, import.meta.url).href&#125;
</code></pre>
<p>使用</p>
<pre><code>import usePub from &#39;@/util/public-use&#39;setup () &#123; const Pub = usePub() const getAssetsFile = Pub.getAssetsFile return&#123; getAssetsFile &#125;&#125;
</code></pre>
<p>可以包含文件路径</p>
<pre><code>&lt;img :src=&quot;getAssetsFile(&#39;/home/home_icon.png&#39;)&quot;/&gt;
</code></pre>
<h5 id="第三种方式（适用于处理多个链接的资源文件）"><a href="#第三种方式（适用于处理多个链接的资源文件）" class="headerlink" title="第三种方式（适用于处理多个链接的资源文件）"></a>第三种方式（适用于处理多个链接的资源文件）</h5><p><strong>不推荐，这种方式引入的文件必须指定到具体文件夹路径，传入的变量中只能为文件名，不能包含文件路径</strong></p>
<p>使用vite的<code>import.meta.glob</code>或<code>import.meta.globEager</code>，两者的区别是前者懒加载资源，后者直接引入。</p>
<p><strong>这里我们假设：</strong><br>工具文件目录： <code>src/util/pub-use.ts</code><br>pub-use.ts</p>
<pre><code class="js">// 获取assets静态资源
export defaultconst getAssetsHomeFile = (url: string) =&gt; &#123;  
    const path = `../assets/images/home/$&#123;url&#125;`;  
    const modules = import.meta.globEager(&quot;../assets/images/home/*&quot;);  
    return modules[path].default;
&#125;
</code></pre>
<p>使用</p>
<pre><code class="js">import usePub from &#39;@/util/public-use&#39;
setup () &#123; 
    const Pub = usePub() 
    const getAssetsHomeFile = Pub.getAssetsHomeFile  
    return&#123; getAssetsHomeFile &#125;
&#125;
</code></pre>
<p>不能包含文件路径</p>
<pre><code class="html">&lt;img :src=&quot;getAssetsHomeFile(&#39;home_icon.png&#39;)&quot;/&gt;
</code></pre>
<h5 id="补充：如果是背景图片引入的方式（一定要使用相对路径）"><a href="#补充：如果是背景图片引入的方式（一定要使用相对路径）" class="headerlink" title="补充：如果是背景图片引入的方式（一定要使用相对路径）"></a>补充：如果是背景图片引入的方式（一定要使用相对路径）</h5><pre><code class="css">.imgText &#123; background-image: url(&#39;../../assets/images/1462466500644.jpg&#39;);&#125;
</code></pre>
<p>-</p>
<h4 id="vite-Some-chunks-are-larger-than-500-kBs-after-minification-Consider-Using-dynamic-import"><a href="#vite-Some-chunks-are-larger-than-500-kBs-after-minification-Consider-Using-dynamic-import" class="headerlink" title="vite Some chunks are larger than 500 kBs after minification. Consider: - Using dynamic import()"></a>vite Some chunks are larger than 500 kBs after minification. Consider: - Using dynamic import()</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45284938/article/details/129707796">https://blog.csdn.net/qq_45284938/article/details/129707796</a></p>
<p>vite.config:</p>
<pre><code class="js">outDir: BUILD_DIR, // 指定打包文件的输出目录
emptyOutDir: true,  // 打包时先清空上一次构建生成的目录
</code></pre>
<p>完整 build：</p>
<pre><code class="json"> build: &#123;
    outDir: BUILD_DIR,
    sourcemap: false,
    minify: &#39;terser&#39;,
    chunkSizeWarningLimit: 1500,
    emptyOutDir: true,
    terserOptions: &#123;
      compress: &#123;
        drop_console: true,
        drop_debugger: true
      &#125;
    &#125;,
    rollupOptions: &#123;
      output: &#123;
        manualChunks(id) &#123;
          if (id.includes(&#39;node_modules&#39;)) &#123;
            return id.toString().split(&#39;node_modules/&#39;)[1].split(&#39;/&#39;)[0].toString();
          &#125;
        &#125;,
        chunkFileNames: (chunkInfo) =&gt; &#123;
          const facadeModuleId = chunkInfo.facadeModuleId ? chunkInfo.facadeModuleId.split(&#39;/&#39;) : [];
          const fileName = facadeModuleId[facadeModuleId.length - 2] || &#39;[name]&#39;;
          return `js/$&#123;fileName&#125;/[name].[hash].js`;
        &#125;
      &#125;
    &#125;
  &#125;,
</code></pre>
<p>-</p>
<h4 id="Electron报错Unable-to-load-preload-script"><a href="#Electron报错Unable-to-load-preload-script" class="headerlink" title="Electron报错Unable to load preload script"></a>Electron报错Unable to load preload script</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s5s5s5s5s/article/details/127493590">https://blog.csdn.net/s5s5s5s5s/article/details/127493590</a></p>
<p>preload 文件有错，或许是代码次序问题，暴露的函数要在定义之后</p>
<p>-</p>
<h4 id="【Electron】require和contextBridge导致的contextIsolation相悖问题"><a href="#【Electron】require和contextBridge导致的contextIsolation相悖问题" class="headerlink" title="【Electron】require和contextBridge导致的contextIsolation相悖问题"></a>【Electron】require和contextBridge导致的contextIsolation相悖问题</h4><h4 id="amp-amp-解决electron中出现Uncaught-ReferenceError-require-is-not-defined"><a href="#amp-amp-解决electron中出现Uncaught-ReferenceError-require-is-not-defined" class="headerlink" title="&amp;&amp; 解决electron中出现Uncaught ReferenceError: require is not defined"></a>&amp;&amp; 解决electron中出现Uncaught ReferenceError: require is not defined</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41568995/article/details/120352394">https://blog.csdn.net/weixin_41568995/article/details/120352394</a></p>
<pre><code class="js">webPreferences: &#123;
    // 版本默认不支持 node，使用需添加
    nodeIntegration:true,
    // 不使用 contextBridge API 
    contextIsolation: false,
    enableRemoteModule: true,
    preload: path.join(__dirname, &#39;preload.js&#39;)
&#125;
</code></pre>
<p>-</p>
<h4 id="异步功能-await-setTimeout的组合"><a href="#异步功能-await-setTimeout的组合" class="headerlink" title="异步功能+ await + setTimeout的组合"></a>异步功能+ await + setTimeout的组合</h4><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/ask/sof/171603">https://cloud.tencent.com/developer/ask/sof/171603</a></p>
<pre><code class="js">function timeout(ms) &#123;
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
&#125;
async function sleep(fn, ...args) &#123;
    await timeout(3000);
    return fn(...args);
&#125;
</code></pre>
<p>或简短</p>
<pre><code class="js"> await new Promise(resolve =&gt; setTimeout(resolve, 1000));
</code></pre>
<p>-</p>
<h4 id="Electron-Vite渲染进程无法import内置模块的问题"><a href="#Electron-Vite渲染进程无法import内置模块的问题" class="headerlink" title="Electron+Vite渲染进程无法import内置模块的问题"></a>Electron+Vite渲染进程无法import内置模块的问题</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/540056695">https://zhuanlan.zhihu.com/p/540056695</a></p>
<p>使用 <code>optimizer</code>  插件</p>
<p>不推荐，主进程与渲染进程分开好一点</p>
<pre><code class="js">//vite.config.ts
import &#123; defineConfig &#125; from &quot;vite&quot;;
import optimizer from &quot;vite-plugin-optimizer&quot;;
let getReplacer = () =&gt; &#123;
  let externalModels = [&quot;electron&quot;, &quot;os&quot;, &quot;fs&quot;, &quot;path&quot;, &quot;events&quot;, &quot;child_process&quot;, &quot;crypto&quot;, &quot;http&quot;, &quot;buffer&quot;, &quot;url&quot;, &quot;better-sqlite3&quot;, &quot;knex&quot;];
  let result = &#123;&#125;;
  for (let item of externalModels) &#123;
    result[item] = () =&gt; (&#123;
      find: new RegExp(`^$&#123;item&#125;$`),
      code: `const $&#123;item&#125; = require(&#39;$&#123;item&#125;&#39;);export &#123; $&#123;item&#125; as default &#125;`,
    &#125;);
  &#125;
  return result;
&#125;;
export default defineConfig(&#123;
  plugins: [optimizer(getReplacer())],
&#125;);
</code></pre>
<p>-</p>
<h4 id="Error-Module-“crypto“-has-been-externalized-for-browser-compatibility-and-cannot-be-accessed-in-…"><a href="#Error-Module-“crypto“-has-been-externalized-for-browser-compatibility-and-cannot-be-accessed-in-…" class="headerlink" title="Error: Module “crypto“ has been externalized for browser compatibility and cannot be accessed in …"></a>Error: Module “crypto“ has been externalized for browser compatibility and cannot be accessed in …</h4><p><a target="_blank" rel="noopener" href="https://codeantenna.com/a/prLQN2PBl9">https://codeantenna.com/a/prLQN2PBl9</a></p>
<p>使用vite构建项目的时候需要用到crypto进行加密出现的错误。问题出在vite本身使用了crypto，我们如果通过npm i crypto -S会导致vite构建时报错。</p>
<p>换个库或者是使用上面的方法</p>
<p>-</p>

                </div>

                <div class="menuShow">
                    <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24">
                        <path
                            d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z"
                            fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path>
                    </svg>
                </div>
                <div class="top">
                    <svg width="8" height="14" viewBox="0 0 8 14">
                        <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd"
                            stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
</section>
<script src="/js/nav.js"></script>
<!-- 
<script src="/js/nav.js"></script>
 -->
                                        <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>

<link rel="stylesheet" href="/css/nord.css" type="text/css" />
<script src="/js/highlight.min.js"></script>
<script src="/js/highlightjs-line-numbers.js"></script>

<!-- 
<link rel="stylesheet" href="/css/nord.css">

    
<script src="/js/highlight.min.js"></script>

        
<script src="/js/highlightjs-line-numbers.js"></script>
 -->

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
            </div>
        </div>
        <script>
            const loader = document.querySelector('.load');
            const paper = document.querySelector('.paper');
            const ch_span = document.querySelector('.load .h-mes>#chs');
            const no_wait = document.querySelector('.load #noWait');
    
            const ch_array = ['" 或许再等一会.. "', '" 等待是为了更好的阅读体验 "', '" 就快加载完了 "', '" 还差一点... "', '" 感谢你的坚持 ! "']
            let i = 0, j = 0;
            var show_main = setInterval(() => {
                ch_span.innerHTML = ch_array[i];
                i > 3 ? i = 0 : i ++;
                j > 1 ? no_wait.style.display = 'block' : j ++;
            }, 1800);
            // console.log(23542365)
            window.addEventListener('load',showMain);
            no_wait.addEventListener('click', showMain);
    
            function showMain() {
                loader.style.display = 'none';
                paper.style.display = 'block';
                show_main = null;
                clearInterval(show_main);
                console.log(1)
            }
        </script>
    </body>
</html>