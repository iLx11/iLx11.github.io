<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link rel="stylesheet" media="screen and (max-width:700px)" href="/css/style.css" type="text/css" />
    <link rel="stylesheet" media="screen and (min-width:700px)" href="/css/stylePC.css" type="text/css" />
    <link rel="stylesheet" href="/css/reset.css" type="text/css" />
    <link rel="stylesheet" href="/css/markdown.css" type="text/css" />
    <link rel="stylesheet" href="/css/fonts.css" type="text/css" />

    <title>
        iLx1 |
            
    </title>
    <!-- 
<link rel="stylesheet" href="/css/reset.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/markdown.css">
 -->
    <!-- 
<link rel="stylesheet" href="/css/fonts.css">
 -->
<meta name="generator" content="Hexo 5.4.2"></head>
    <style>
        /*页面加载开始*/
        .load {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 35em;
            z-index: 999;
        }

        .loader {
            --path: #323641;
            --dot: #6a95bd;
            --duration: 1.5s;
            width: 55px;
            height: 55px;
            align-items: center;
            justify-items: center;
            position: relative;
        }
        .h-mes {
            width: 100%;
            height: 20%;
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-flow: column nowrap;
            justify-content: space-evenly;
            align-items: center;
        }
        .h-mes span {
            width: 100%;
            height: 10%;
            text-align: center;
        }
        .loader:before {
            content: "";
            width: 6px;
            height: 6px;
            border-radius: 50%;
            position: absolute;
            display: block;
            background: var(--dot);
            top: 37px;
            left: 19px;
            transform: translate(-18px, -18px);
        }

        .loader svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        .loader svg polygon {
            fill: none;
            stroke: var(--path);
            stroke-width: 10px;
            stroke-linejoin: round;
            stroke-linecap: round;
        }

        .loader svg polygon {
            stroke-dasharray: 145 76 145 76;
            stroke-dashoffset: 0;
            animation: pathTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }

        .loader.triangle {
            width: 48px;
        }

        .loader.triangle:before {
            left: 21px;
            transform: translate(-10px, -18px);
            animation: dotTriangle var(--duration) cubic-bezier(0.785, 0.135, 0.15, 0.86) infinite;
        }
        #noWait {
            color: rgba(51,51,51, 0.4);
            margin-top: 3em;
            cursor: pointer;
            display: none;
        }
        @keyframes pathTriangle {
            33% {
                stroke-dashoffset: 74;
            }

            66% {
                stroke-dashoffset: 147;
            }

            100% {
                stroke-dashoffset: 221;
            }
        }

        @keyframes dotTriangle {
            33% {
                transform: translate(0, 0);
            }

            66% {
                transform: translate(10px, -18px);
            }

            100% {
                transform: translate(-10px, -18px);
            }

        }
    </style>

    <body>
        <!-- 页面加载效果 -->
        <div class="load">
            <div class="loader triangle">
                <svg viewBox="0 0 86 80">
                    <polygon points="43 8 79 72 7 72"></polygon>
                </svg>
            </div>
            <div class="h-mes">
                <span id="chs">" 请稍等一会... "</span>
                <span>Please wait for a long time</span>
                <span id="noWait"><我不等啦！></span>
            </div>
        </div>
        
        <!-- 页面加载结束 -->
        <div class="backg"></div>
        <div class="paper">
            <div class="paper-main">
                
                
                <!-- <div class="bgimg"></div> -->
                <div class="cover"></div>
                <!-- <div class="bgimgB"></div> -->
                
                    <div class="post-header">
    <div class="themePage2">Light</div>
    <a class="logo post-header-logo" href="/">iLx1</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                        
                                    <section class="post-struction">
    <div class="post-main">
        
            <div class="post-main-title">
                TS笔记
            </div>
            <div class="post-meta">
                2023-02-16
            </div>
            
                <hr>
                <div class="post-md">
                    <h2 id="TypeScript-的介绍"><a href="#TypeScript-的介绍" class="headerlink" title="TypeScript 的介绍"></a>TypeScript 的介绍</h2><p>TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScript代码。</p>
<p>-</p>
<h2 id="TypeScript-的特点"><a href="#TypeScript-的特点" class="headerlink" title="TypeScript 的特点"></a>TypeScript 的特点</h2><p>TypeScript 主要有 3 大特点：</p>
<ul>
<li><strong>始于JavaScript，归于JavaScript</strong></li>
</ul>
<p>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>
<ul>
<li><strong>强大的类型系统</strong></li>
</ul>
<p><strong>类型系统</strong>允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>
<ul>
<li><strong>先进的 JavaScript</strong></li>
</ul>
<p>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>
<p>-</p>
<h1 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h1><p>命令行运行如下命令，全局安装 TypeScript：</p>
<pre><code class="bash">npm install -g typescript
//
yarn global add typescript
</code></pre>
<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>
<pre><code class="bash">tsc -V 
</code></pre>
<p>-</p>
<h3 id="运行TS"><a href="#运行TS" class="headerlink" title="运行TS"></a>运行TS</h3><p>在命令行上，运行 TypeScript 编译器：</p>
<pre><code class="bash">tsc helloworld.ts
</code></pre>
<p>输出结果为一个 <code>helloworld.js</code> 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>
<p>在命令行上，通过 Node.js 运行这段代码：</p>
<pre><code class="bash">node helloworld.js
</code></pre>
<p>-</p>
<h3 id="vscode自动编译"><a href="#vscode自动编译" class="headerlink" title="vscode自动编译"></a>vscode自动编译</h3><pre><code>1). 生成配置文件tsconfig.json
    tsc --init
2). 修改tsconfig.json配置
    &quot;outDir&quot;: &quot;./js&quot;,
    &quot;strict&quot;: false,    
3). 启动监视任务: 
    终端 -&gt; 运行任务 -&gt; 监视tsconfig.json
</code></pre>
<p>-</p>
<p>-</p>
<h1 id="TS基础语法"><a href="#TS基础语法" class="headerlink" title="TS基础语法"></a>TS基础语法</h1><p>-</p>
<h2 id="一、类型注解"><a href="#一、类型注解" class="headerlink" title="一、类型注解"></a>一、类型注解</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><pre><code class="ts">//bool
let isDone: boolean = false;

//number
//支持 十进制 二进制 八进制 十六进制
let num: number = 123;

//string
let str: string = &quot;name&quot;;

//undefined / null
let u: undefined = undefined;
let n: null = null;
</code></pre>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code class="ts">let array: number[] = [];

//泛型
let array: Array&lt;number&gt; = [];
</code></pre>
<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，<code>各元素的类型不必相同</code>。 比如，你可以定义一对值分别为 <code>string</code> 和 <code>number</code> 类型的元组。</p>
<pre><code class="ts">let tArray: [string, number];
//right
tArray = [&quot;str&quot;, 123];
//wrong
tArray = [123, &quot;str&quot;];
</code></pre>
<p>-</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>默认从0开始</p>
<pre><code class="ts">enum Colorful &#123;
    red = 2,
    blue, 
    yellow,
    green
&#125;

let meColor: Colorful = Colorful.blue;
</code></pre>
<p>-</p>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code> 类型来标记这些变量：</p>
<pre><code class="ts">let notdecide: any = 123;
notdecide = &#39;string&#39;; // ok
notdecide = true;  // ok

// 数组
let array: any[] = [&#39;123&#39;, 123, true];
</code></pre>
<p>-</p>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它<code>表示没有任何类型</code>。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<p>-</p>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p><code>object</code> 表示非原始类型，也就是除 <code>number</code>，<code>string</code>，<code>boolean</code>之外的类型。</p>
<p>使用 <code>object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code></p>
<p>-</p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种</p>
<p>（或）</p>
<pre><code class="ts">function func(x: number | string ): string &#123;
    return x.toString();
&#125;
</code></pre>
<p>-</p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<blockquote>
<pre><code class="typescript">类型断言(Type Assertion): 可以用来手动指定一个值的类型
语法:
    方式一: &lt;类型&gt;值
    方式二: 值 as 类型  tsx中只能用这种方式
</code></pre>
</blockquote>
<pre><code class="ts">// 需求: 定义一个函数得到一个字符串或者数值数据的长度
function getLength(x: number | string) &#123;
  if ((&lt;string&gt;x).length) &#123;
    return (x as string).length
  &#125; else &#123;
    return x.toString().length
  &#125;
</code></pre>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>类型推断: TS会在没有明确的指定类型的时候推测出一个类型</p>
<blockquote>
<ol>
<li>定义变量时赋值了, 推断为对应的类型. </li>
<li>定义变量时没有赋值, 推断为any类型</li>
</ol>
</blockquote>
<pre><code class="typescript">/* 定义变量时赋值了, 推断为对应的类型 */
let num = 123 // number
// b9 = &#39;abc&#39; // error

/* 定义变量时没有赋值, 推断为any类型 */
let anything  // any类型
b10 = 123
b10 = &#39;abc&#39;
</code></pre>
<p>-</p>
<p>-</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。<code>接口是对象的状态(属性)和行为(方法)的抽象(描述)</code></p>
<p>-</p>
<p>创建对象，对属性进行约束</p>
<pre><code class="ts">interface Person &#123;
    // 必须属性
    // 只读属性
    readonly id: number,
    name: string, 
    sex: string,
    // 可选属性
    age?: number
&#125;

let person: Person &#123;
    id: 1,
    name: &#39;123&#39;,
    sex: &#39;男&#39;
&#125;
</code></pre>
<p>-</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><pre><code class="ts">/* 
接口可以描述函数类型(参数的类型与返回的类型)
*/

interface SearchFunc &#123;
  (source: string, subString: string): boolean
&#125;
</code></pre>
<p>实例</p>
<pre><code class="ts">const mySearch: SearchFunc = function (source: string, sub: string): boolean &#123;
  return source.search(sub) &gt; -1
&#125;
</code></pre>
<p>-</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><h4 id="接口的实现类"><a href="#接口的实现类" class="headerlink" title="接口的实现类"></a>接口的实现类</h4><pre><code class="ts">interface Alarm &#123;
  alert(): any;
&#125;

interface Light &#123;
    LightOn(): void;
&#125;

// 类可以实现多个接口
class Clock implements Alarm, Light &#123;
    alert() &#123;
        console.log(&quot;the alarm&quot;)
    &#125;
    LightOn() &#123;
        console.log(&quot;the light is on&quot;)
    &#125;
&#125;
</code></pre>
<p>-</p>
<h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><pre><code class="ts">interface lightAlarm extends Alarm, Ligth &#123;&#125;
</code></pre>
<p>-</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h3><h3 id="默认为-public"><a href="#默认为-public" class="headerlink" title="#默认为 public"></a><a target="_blank" rel="noopener" href="https://24kcs.github.io/vue3_study/chapter2/3_class.html#%E9%BB%98%E8%AE%A4%E4%B8%BA-public">#</a>默认为 public</h3><p>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code> 来做修饰；例如，C# 要求必须明确地使用 <code>public</code> 指定成员是可见的。 在 TypeScript 里，成员都默认为 <code>public</code>。</p>
<p>你也可以明确的将一个成员标记成 <code>public</code>。 我们可以用下面的方式来重写上面的 <code>Animal</code> 类：</p>
<h3 id="理解-private"><a href="#理解-private" class="headerlink" title="#理解 private"></a><a target="_blank" rel="noopener" href="https://24kcs.github.io/vue3_study/chapter2/3_class.html#%E7%90%86%E8%A7%A3-private">#</a>理解 private</h3><p>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问。</p>
<h3 id="理解-protected"><a href="#理解-protected" class="headerlink" title="#理解 protected"></a><a target="_blank" rel="noopener" href="https://24kcs.github.io/vue3_study/chapter2/3_class.html#%E7%90%86%E8%A7%A3-protected">#</a>理解 protected</h3><p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。</p>
<pre><code class="ts">class Animal &#123;
  public name: string

  public constructor (name: string) &#123;
    this.name = name
  &#125;

  public run (distance: number=0) &#123;
    console.log(`$&#123;this.name&#125; run $&#123;distance&#125;m`)
  &#125;
&#125;

class Person extends Animal &#123;
  private age: number = 18
  protected sex: string = &#39;男&#39;
    // 重写父类方法
  run (distance: number=5) &#123;
    console.log(&#39;Person jumping...&#39;)
    // 调用父的一般方法
    super.run(distance)
  &#125;
&#125;
</code></pre>
<p>-</p>
<h3 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h3><p><code>readonly</code> 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化</p>
<pre><code class="ts">class Person &#123;
    readonly name: string = &#39;qwe&#39;
    // 参数属性
    constructor(readonly name: string) &#123;
          
    &#125;
&#125;
</code></pre>
<p>-</p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<pre><code class="ts">class Person &#123;
  firstName: string = &#39;A&#39;
  lastName: string = &#39;B&#39;
  get fullName () &#123;
    return this.firstName + &#39;-&#39; + this.lastName
  &#125;
  set fullName (value) &#123;
    const names = value.split(&#39;-&#39;)
    this.firstName = names[0]
    this.lastName = names[1]
  &#125;
&#125;
const p = new Person()
console.log(p.fullName)
</code></pre>
<p>-</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><blockquote>
<p>静态属性, 是类对象的属性<br>非静态属性, 是类的实例对象的属性</p>
</blockquote>
<pre><code class="typescript">class Person &#123;
  name1: string = &#39;A&#39;
  static personalId: string = &#39;HUMAN001&#39;
&#125;

console.log( Person.personalId )
</code></pre>
<p>-</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们不能被实例化。不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>-</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<p>TypeScript 里我们可以在参数名旁使用 <code>?</code> 实现可选参数的功能。</p>
<pre><code class="ts">function getName(firstName: string=&#39;L&#39;, lastName?: string): string &#123;&#125;
// const getName = (firstName: string=&#39;L&#39;, lastName?: string): string =&gt; &#123;&#125;
</code></pre>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><pre><code class="ts">function info(x: string, ...args: string[]): string &#123;&#125;
</code></pre>
<p>-</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载: 函数名相同, 而形参不同的多个函数</p>
<pre><code class="typescript">// 重载函数声明
function add (x: string, y: string): string
function add (x: number, y: number): number

// 定义函数实现
function add(x: string | number, y: string | number): string | number &#123;
  // 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y
  if (typeof x === &#39;string&#39; &amp;&amp; typeof y === &#39;string&#39;) &#123;
    return x + y
  &#125; else if (typeof x === &#39;number&#39; &amp;&amp; typeof y === &#39;number&#39;) &#123;
    return x + y
  &#125;
&#125;
</code></pre>
<p>-</p>
<p>-</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性</p>
<p>-</p>
<h3 id="多个泛型参数的函数"><a href="#多个泛型参数的函数" class="headerlink" title="多个泛型参数的函数"></a>多个泛型参数的函数</h3><p>一个函数可以定义多个泛型参数</p>
<pre><code class="typescript">function swap &lt;K, V&gt; (a: K, b: V): [K, V] &#123;
  return [a, b]
&#125;
const result = swap&lt;string, number&gt;(&#39;abc&#39;, 123)
// （字符串的方法，数字的方法）
console.log(result[0].length, result[1].toFixed())
</code></pre>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>在定义接口时, 为接口中的属性或方法定义泛型类型<br>在使用接口时, 再指定具体的泛型类型</p>

                </div>

                <div class="menuShow">
                    <svg t="1663413277234" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2403" width="24" height="24">
                        <path
                            d="M640 192H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM960 544H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h736c17.7 0 32 14.3 32 32s-14.3 32-32 32zM640 896H224c-17.7 0-32-14.3-32-32s14.3-32 32-32h416c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 192H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 544H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32zM96 896H64c-17.7 0-32-14.3-32-32s14.3-32 32-32h32c17.7 0 32 14.3 32 32s-14.3 32-32 32z"
                            fill="#707070" p-id="2404" data-spm-anchor-id="a313x.7781069.0.i0" class="selected"></path>
                    </svg>
                </div>
                <div class="top">
                    <svg width="8" height="14" viewBox="0 0 8 14">
                        <path d="M7 1L1 7l6 6" stroke="#fff" stroke-width="2" fill="none" fill-rule="evenodd"
                            stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                </div>
    </div>
    <div class="menu">
        <ul>
        </ul>
    </div>
</section>
<script src="/js/nav.js"></script>
<!-- 
<script src="/js/nav.js"></script>
 -->
                                        <div class="footer">
    <span>Copyright © 2022 iLx1</span>
</div>

<link rel="stylesheet" href="/css/nord.css" type="text/css" />
<script src="/js/highlight.min.js"></script>
<script src="/js/highlightjs-line-numbers.js"></script>

<!-- 
<link rel="stylesheet" href="/css/nord.css">

    
<script src="/js/highlight.min.js"></script>

        
<script src="/js/highlightjs-line-numbers.js"></script>
 -->

<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>
            </div>
        </div>
        <script>
            const loader = document.querySelector('.load');
            const paper = document.querySelector('.paper');
            const ch_span = document.querySelector('.load .h-mes>#chs');
            const no_wait = document.querySelector('.load #noWait');
    
            const ch_array = ['" 或许再等一会.. "', '" 等待是为了更好的阅读体验 "', '" 就快加载完了 "', '" 还差一点... "', '" 感谢你的坚持 ! "']
            let i = 0, j = 0;
            var show_main = setInterval(() => {
                ch_span.innerHTML = ch_array[i];
                i > 3 ? i = 0 : i ++;
                j > 1 ? no_wait.style.display = 'block' : j ++;
            }, 1800);
            // console.log(23542365)
            window.addEventListener('load',showMain);
            no_wait.addEventListener('click', showMain);
    
            function showMain() {
                loader.style.display = 'none';
                paper.style.display = 'block';
                show_main = null;
                clearInterval(show_main);
                console.log(1)
            }
        </script>
    </body>
</html>